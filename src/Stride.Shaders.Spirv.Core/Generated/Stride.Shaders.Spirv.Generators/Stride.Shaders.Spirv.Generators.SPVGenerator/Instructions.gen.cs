using static Stride.Shaders.Spirv.Specification;
using CommunityToolkit.HighPerformance;
using CommunityToolkit.HighPerformance.Buffers;
using Stride.Shaders.Spirv.Core.Buffers;
using System.Numerics;

namespace Stride.Shaders.Spirv.Core;
public struct OpSDSLShader : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLShader()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLShader | (1 << 16);
    }

    public OpSDSLShader(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLShader(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public string ShaderName
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLShader(string shaderName)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ShaderName = shaderName;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLShader, ..ShaderName.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "shaderName":
                    ShaderName = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpSDSLShader(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLShader(OpData data) => new(data);
}

public struct OpSDSLShaderEnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLShaderEnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLShaderEnd | (1 << 16);
    }

    public OpSDSLShaderEnd(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLShaderEnd(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLShaderEnd, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpSDSLShaderEnd(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLShaderEnd(OpData data) => new(data);
}

public struct OpSDSLEffect : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLEffect()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLEffect | (1 << 16);
    }

    public OpSDSLEffect(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLEffect(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public string EffectName
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLEffect(string effectName)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        EffectName = effectName;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLEffect, ..EffectName.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "effectName":
                    EffectName = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpSDSLEffect(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLEffect(OpData data) => new(data);
}

public struct OpSDSLComposition : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLComposition()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLComposition | (1 << 16);
    }

    public OpSDSLComposition(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLComposition(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public string CompositionPath
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLComposition(string compositionPath)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        CompositionPath = compositionPath;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLComposition, ..CompositionPath.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "compositionPath":
                    CompositionPath = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpSDSLComposition(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLComposition(OpData data) => new(data);
}

public struct OpSDSLCompositionEnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLCompositionEnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLCompositionEnd | (1 << 16);
    }

    public OpSDSLCompositionEnd(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLCompositionEnd(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLCompositionEnd, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpSDSLCompositionEnd(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLCompositionEnd(OpData data) => new(data);
}

public struct OpSDSLMixinInherit : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLMixinInherit()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLMixinInherit | (1 << 16);
    }

    public OpSDSLMixinInherit(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLMixinInherit(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Shader
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLMixinInherit(int shader)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Shader = shader;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLMixinInherit, Shader];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "shader":
                    Shader = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSDSLMixinInherit(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLMixinInherit(OpData data) => new(data);
}

public struct OpSDSLCompose : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLCompose()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLCompose | (1 << 16);
    }

    public OpSDSLCompose(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLCompose(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public string Mixin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLCompose(string mixin, string name)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Mixin = mixin;
        Name = name;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLCompose, ..Mixin.AsDisposableLiteralValue().Words, ..Name.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "mixin":
                    Mixin = o.ToLiteral<string>();
                    break;
                case "name":
                    Name = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpSDSLCompose(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLCompose(OpData data) => new(data);
}

public struct OpSDSLStage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLStage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLStage | (1 << 16);
    }

    public OpSDSLStage(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLStage(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int StagedElement
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLStage(int stagedElement)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        StagedElement = stagedElement;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLStage, StagedElement];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "stagedElement":
                    StagedElement = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSDSLStage(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLStage(OpData data) => new(data);
}

public struct OpSDSLImportShader : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLImportShader()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLImportShader | (1 << 16);
    }

    public OpSDSLImportShader(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLImportShader(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string ShaderName
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDSLImportShader inst) => inst.ResultId;
    public OpSDSLImportShader(int resultId, string shaderName, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        ShaderName = shaderName;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLImportShader, ResultId, ..ShaderName.AsDisposableLiteralValue().Words, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "shaderName":
                    ShaderName = o.ToLiteral<string>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSDSLImportShader(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLImportShader(OpData data) => new(data);
}

public struct OpSDSLImportFunction : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLImportFunction()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLImportFunction | (1 << 16);
    }

    public OpSDSLImportFunction(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLImportFunction(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FunctionType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string FunctionName
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shader
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public FunctionFlagsMask Flags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDSLImportFunction inst) => inst.ResultId;
    public OpSDSLImportFunction(int resultId, int functionType, string functionName, int shader, FunctionFlagsMask flags)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        FunctionType = functionType;
        FunctionName = functionName;
        Shader = shader;
        Flags = flags;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLImportFunction, ResultId, FunctionType, ..FunctionName.AsDisposableLiteralValue().Words, Shader, (int)Flags];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "functionType":
                    FunctionType = o.ToLiteral<int>();
                    break;
                case "functionName":
                    FunctionName = o.ToLiteral<string>();
                    break;
                case "shader":
                    Shader = o.ToLiteral<int>();
                    break;
                case "flags":
                    Flags = o.ToEnum<FunctionFlagsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpSDSLImportFunction(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLImportFunction(OpData data) => new(data);
}

public struct OpSDSLImportVariable : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLImportVariable()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLImportVariable | (1 << 16);
    }

    public OpSDSLImportVariable(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLImportVariable(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string VariableName
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shader
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public VariableFlagsMask Flags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDSLImportVariable inst) => inst.ResultId;
    public OpSDSLImportVariable(int resultId, int resultType, string variableName, int shader, VariableFlagsMask flags)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        ResultType = resultType;
        VariableName = variableName;
        Shader = shader;
        Flags = flags;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLImportVariable, ResultId, ResultType, ..VariableName.AsDisposableLiteralValue().Words, Shader, (int)Flags];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "variableName":
                    VariableName = o.ToLiteral<string>();
                    break;
                case "shader":
                    Shader = o.ToLiteral<int>();
                    break;
                case "flags":
                    Flags = o.ToEnum<VariableFlagsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpSDSLImportVariable(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLImportVariable(OpData data) => new(data);
}

public struct OpSDSLImportStruct : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLImportStruct()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLImportStruct | (1 << 16);
    }

    public OpSDSLImportStruct(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLImportStruct(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string StructName
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shader
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDSLImportStruct inst) => inst.ResultId;
    public OpSDSLImportStruct(int resultId, string structName, int shader)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        StructName = structName;
        Shader = shader;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLImportStruct, ResultId, ..StructName.AsDisposableLiteralValue().Words, Shader];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "structName":
                    StructName = o.ToLiteral<string>();
                    break;
                case "shader":
                    Shader = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSDSLImportStruct(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLImportStruct(OpData data) => new(data);
}

public struct OpVariableSDSL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVariableSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVariableSDSL | (1 << 16);
    }

    public OpVariableSDSL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpVariableSDSL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public VariableFlagsMask Flags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? MethodInitializer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVariableSDSL inst) => inst.ResultId;
    public OpVariableSDSL(int resultType, int resultId, StorageClass storageclass, VariableFlagsMask flags, int? methodInitializer)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Storageclass = storageclass;
        Flags = flags;
        MethodInitializer = methodInitializer;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVariableSDSL, ResultType, ResultId, (int)Storageclass, (int)Flags, ..(MethodInitializer is null ? (Span<int>)[] : [MethodInitializer.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "storageclass":
                    Storageclass = o.ToEnum<StorageClass>();
                    break;
                case "flags":
                    Flags = o.ToEnum<VariableFlagsMask>();
                    break;
                case "methodInitializer":
                    if (o.Words.Length > 0)
                        MethodInitializer = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpVariableSDSL(OpDataIndex odi) => new(odi);
    public static implicit operator OpVariableSDSL(OpData data) => new(data);
}

public struct OpMemberAccessSDSL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemberAccessSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemberAccessSDSL | (1 << 16);
    }

    public OpMemberAccessSDSL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpMemberAccessSDSL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Instance
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Member
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpMemberAccessSDSL inst) => inst.ResultId;
    public OpMemberAccessSDSL(int resultType, int resultId, int instance, int member)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Instance = instance;
        Member = member;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemberAccessSDSL, ResultType, ResultId, Instance, Member];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "instance":
                    Instance = o.ToLiteral<int>();
                    break;
                case "member":
                    Member = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpMemberAccessSDSL(OpDataIndex odi) => new(odi);
    public static implicit operator OpMemberAccessSDSL(OpData data) => new(data);
}

public struct OpTypeFunctionSDSL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeFunctionSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeFunctionSDSL | (1 << 16);
    }

    public OpTypeFunctionSDSL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeFunctionSDSL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReturnType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<(int, int)> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeFunctionSDSL inst) => inst.ResultId;
    public OpTypeFunctionSDSL(int resultId, int returnType, LiteralArray<(int, int)> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        ReturnType = returnType;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeFunctionSDSL, ResultId, ReturnType, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "returnType":
                    ReturnType = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<(int, int)>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeFunctionSDSL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeFunctionSDSL(OpData data) => new(data);
}

public struct OpSDSLFunctionInfo : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLFunctionInfo()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLFunctionInfo | (1 << 16);
    }

    public OpSDSLFunctionInfo(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLFunctionInfo(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public FunctionFlagsMask Flags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Parent
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLFunctionInfo(FunctionFlagsMask flags, int parent)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Flags = flags;
        Parent = parent;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLFunctionInfo, (int)Flags, Parent];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "flags":
                    Flags = o.ToEnum<FunctionFlagsMask>();
                    break;
                case "parent":
                    Parent = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSDSLFunctionInfo(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLFunctionInfo(OpData data) => new(data);
}

public struct OpBaseSDSL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBaseSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBaseSDSL | (1 << 16);
    }

    public OpBaseSDSL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpBaseSDSL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBaseSDSL inst) => inst.ResultId;
    public OpBaseSDSL(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBaseSDSL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpBaseSDSL(OpDataIndex odi) => new(odi);
    public static implicit operator OpBaseSDSL(OpData data) => new(data);
}

public struct OpThisSDSL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpThisSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpThisSDSL | (1 << 16);
    }

    public OpThisSDSL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpThisSDSL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpThisSDSL inst) => inst.ResultId;
    public OpThisSDSL(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpThisSDSL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpThisSDSL(OpDataIndex odi) => new(odi);
    public static implicit operator OpThisSDSL(OpData data) => new(data);
}

public struct OpStageSDSL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpStageSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpStageSDSL | (1 << 16);
    }

    public OpStageSDSL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpStageSDSL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpStageSDSL inst) => inst.ResultId;
    public OpStageSDSL(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpStageSDSL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpStageSDSL(OpDataIndex odi) => new(odi);
    public static implicit operator OpStageSDSL(OpData data) => new(data);
}

public struct OpSDSLMixin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLMixin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLMixin | (1 << 16);
    }

    public OpSDSLMixin(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLMixin(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public string Mixin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLMixin(string mixin, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Mixin = mixin;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLMixin, ..Mixin.AsDisposableLiteralValue().Words, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "mixin":
                    Mixin = o.ToLiteral<string>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSDSLMixin(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLMixin(OpData data) => new(data);
}

public struct OpSDSLMixinCompose : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLMixinCompose()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLMixinCompose | (1 << 16);
    }

    public OpSDSLMixinCompose(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLMixinCompose(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public string Identifier
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Mixin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLMixinCompose(string identifier, string mixin)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Identifier = identifier;
        Mixin = mixin;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLMixinCompose, ..Identifier.AsDisposableLiteralValue().Words, ..Mixin.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "identifier":
                    Identifier = o.ToLiteral<string>();
                    break;
                case "mixin":
                    Mixin = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpSDSLMixinCompose(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLMixinCompose(OpData data) => new(data);
}

public struct OpSDSLMixinComposeArray : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLMixinComposeArray()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLMixinComposeArray | (1 << 16);
    }

    public OpSDSLMixinComposeArray(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLMixinComposeArray(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public string Identifier
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Mixin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSDSLMixinComposeArray(string identifier, string mixin)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Identifier = identifier;
        Mixin = mixin;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLMixinComposeArray, ..Identifier.AsDisposableLiteralValue().Words, ..Mixin.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "identifier":
                    Identifier = o.ToLiteral<string>();
                    break;
                case "mixin":
                    Mixin = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpSDSLMixinComposeArray(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLMixinComposeArray(OpData data) => new(data);
}

public struct OpSDSLGenericParameter : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDSLGenericParameter()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDSLGenericParameter | (1 << 16);
    }

    public OpSDSLGenericParameter(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDSLGenericParameter(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDSLGenericParameter inst) => inst.ResultId;
    public OpSDSLGenericParameter(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDSLGenericParameter, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSDSLGenericParameter(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDSLGenericParameter(OpData data) => new(data);
}

public struct OpConstantStringSDSL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantStringSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantStringSDSL | (1 << 16);
    }

    public OpConstantStringSDSL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConstantStringSDSL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string LiteralString
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantStringSDSL inst) => inst.ResultId;
    public OpConstantStringSDSL(int resultId, string literalString)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        LiteralString = literalString;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantStringSDSL, ResultId, ..LiteralString.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "literalString":
                    LiteralString = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpConstantStringSDSL(OpDataIndex odi) => new(odi);
    public static implicit operator OpConstantStringSDSL(OpData data) => new(data);
}

public struct OpTypeGenericSDSL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeGenericSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeGenericSDSL | (1 << 16);
    }

    public OpTypeGenericSDSL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeGenericSDSL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GenericParameterKindSDSL Kind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeGenericSDSL inst) => inst.ResultId;
    public OpTypeGenericSDSL(int resultId, GenericParameterKindSDSL kind)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        Kind = kind;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeGenericSDSL, ResultId, (int)Kind];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "kind":
                    Kind = o.ToEnum<GenericParameterKindSDSL>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeGenericSDSL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeGenericSDSL(OpData data) => new(data);
}

public struct OpForeachSDSL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpForeachSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpForeachSDSL | (1 << 16);
    }

    public OpForeachSDSL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpForeachSDSL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Collection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpForeachSDSL inst) => inst.ResultId;
    public OpForeachSDSL(int resultType, int resultId, int collection)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Collection = collection;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpForeachSDSL, ResultType, ResultId, Collection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "collection":
                    Collection = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpForeachSDSL(OpDataIndex odi) => new(odi);
    public static implicit operator OpForeachSDSL(OpData data) => new(data);
}

public struct OpForeachEndSDSL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpForeachEndSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpForeachEndSDSL | (1 << 16);
    }

    public OpForeachEndSDSL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpForeachEndSDSL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpForeachEndSDSL, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpForeachEndSDSL(OpDataIndex odi) => new(odi);
    public static implicit operator OpForeachEndSDSL(OpData data) => new(data);
}

public struct OpUnresolvableShaderSDSL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUnresolvableShaderSDSL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUnresolvableShaderSDSL | (1 << 16);
    }

    public OpUnresolvableShaderSDSL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUnresolvableShaderSDSL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public string ShaderCode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ShaderCodeNameEnd
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUnresolvableShaderSDSL(string shaderCode, int shaderCodeNameEnd)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ShaderCode = shaderCode;
        ShaderCodeNameEnd = shaderCodeNameEnd;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUnresolvableShaderSDSL, ..ShaderCode.AsDisposableLiteralValue().Words, ..ShaderCodeNameEnd.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "shaderCode":
                    ShaderCode = o.ToLiteral<string>();
                    break;
                case "shaderCodeNameEnd":
                    ShaderCodeNameEnd = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUnresolvableShaderSDSL(OpDataIndex odi) => new(odi);
    public static implicit operator OpUnresolvableShaderSDSL(OpData data) => new(data);
}

public struct OpNop : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNop()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpNop | (1 << 16);
    }

    public OpNop(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpNop(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpNop, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpNop(OpDataIndex odi) => new(odi);
    public static implicit operator OpNop(OpData data) => new(data);
}

public struct OpUndef : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUndef()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUndef | (1 << 16);
    }

    public OpUndef(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUndef(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUndef inst) => inst.ResultId;
    public OpUndef(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUndef, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUndef(OpDataIndex odi) => new(odi);
    public static implicit operator OpUndef(OpData data) => new(data);
}

public struct OpSourceContinued : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSourceContinued()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSourceContinued | (1 << 16);
    }

    public OpSourceContinued(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSourceContinued(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public string ContinuedSource
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSourceContinued(string continuedSource)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ContinuedSource = continuedSource;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSourceContinued, ..ContinuedSource.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "continuedSource":
                    ContinuedSource = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpSourceContinued(OpDataIndex odi) => new(odi);
    public static implicit operator OpSourceContinued(OpData data) => new(data);
}

public struct OpSource : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSource()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSource | (1 << 16);
    }

    public OpSource(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSource(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public SourceLanguage Sourcelanguage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Version
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? File
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string? Source
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSource(SourceLanguage sourcelanguage, int version, int? file, string? source)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Sourcelanguage = sourcelanguage;
        Version = version;
        File = file;
        Source = source;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSource, (int)Sourcelanguage, ..Version.AsDisposableLiteralValue().Words, ..(File is null ? (Span<int>)[] : [File.Value]), ..(Source is null ? (Span<int>)[] : Source.AsDisposableLiteralValue().Words)];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "sourcelanguage":
                    Sourcelanguage = o.ToEnum<SourceLanguage>();
                    break;
                case "version":
                    Version = o.ToLiteral<int>();
                    break;
                case "file":
                    if (o.Words.Length > 0)
                        File = o.ToLiteral<int?>();
                    break;
                case "source":
                    if (o.Words.Length > 0)
                        Source = o.ToLiteral<string?>();
                    break;
            }
        }
    }

    public static implicit operator OpSource(OpDataIndex odi) => new(odi);
    public static implicit operator OpSource(OpData data) => new(data);
}

public struct OpSourceExtension : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSourceExtension()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSourceExtension | (1 << 16);
    }

    public OpSourceExtension(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSourceExtension(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public string Extension
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSourceExtension(string extension)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Extension = extension;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSourceExtension, ..Extension.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "extension":
                    Extension = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpSourceExtension(OpDataIndex odi) => new(odi);
    public static implicit operator OpSourceExtension(OpData data) => new(data);
}

public struct OpName : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpName()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpName | (1 << 16);
    }

    public OpName(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpName(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpName(int target, string name)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Target = target;
        Name = name;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpName, Target, ..Name.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "target":
                    Target = o.ToLiteral<int>();
                    break;
                case "name":
                    Name = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpName(OpDataIndex odi) => new(odi);
    public static implicit operator OpName(OpData data) => new(data);
}

public struct OpMemberName : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemberName()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemberName | (1 << 16);
    }

    public OpMemberName(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpMemberName(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Type
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Member
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemberName(int type, int member, string name)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Type = type;
        Member = member;
        Name = name;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemberName, Type, ..Member.AsDisposableLiteralValue().Words, ..Name.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "type":
                    Type = o.ToLiteral<int>();
                    break;
                case "member":
                    Member = o.ToLiteral<int>();
                    break;
                case "name":
                    Name = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpMemberName(OpDataIndex odi) => new(odi);
    public static implicit operator OpMemberName(OpData data) => new(data);
}

public struct OpString : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpString()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpString | (1 << 16);
    }

    public OpString(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpString(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpString inst) => inst.ResultId;
    public OpString(int resultId, string value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpString, ResultId, ..Value.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpString(OpDataIndex odi) => new(odi);
    public static implicit operator OpString(OpData data) => new(data);
}

public struct OpLine : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLine()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLine | (1 << 16);
    }

    public OpLine(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpLine(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int File
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Line
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Column
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLine(int file, int line, int column)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        File = file;
        Line = line;
        Column = column;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLine, File, ..Line.AsDisposableLiteralValue().Words, ..Column.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "file":
                    File = o.ToLiteral<int>();
                    break;
                case "line":
                    Line = o.ToLiteral<int>();
                    break;
                case "column":
                    Column = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpLine(OpDataIndex odi) => new(odi);
    public static implicit operator OpLine(OpData data) => new(data);
}

public struct OpExtension : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExtension()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtension | (1 << 16);
    }

    public OpExtension(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpExtension(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExtension(string name)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Name = name;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtension, ..Name.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "name":
                    Name = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpExtension(OpDataIndex odi) => new(odi);
    public static implicit operator OpExtension(OpData data) => new(data);
}

public struct OpExtInstImport : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExtInstImport()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInstImport | (1 << 16);
    }

    public OpExtInstImport(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpExtInstImport(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpExtInstImport inst) => inst.ResultId;
    public OpExtInstImport(int resultId, string name)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        Name = name;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInstImport, ResultId, ..Name.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "name":
                    Name = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpExtInstImport(OpDataIndex odi) => new(odi);
    public static implicit operator OpExtInstImport(OpData data) => new(data);
}

public struct OpExtInst : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExtInst()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public OpExtInst(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpExtInst(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Instruction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpExtInst inst) => inst.ResultId;
    public OpExtInst(int resultType, int resultId, int set, int instruction, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Instruction = instruction;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "instruction":
                    Instruction = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpExtInst(OpDataIndex odi) => new(odi);
    public static implicit operator OpExtInst(OpData data) => new(data);
}

public struct OpMemoryModel : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemoryModel()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemoryModel | (1 << 16);
    }

    public OpMemoryModel(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpMemoryModel(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public AddressingModel Addressingmodel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public MemoryModel Memorymodel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemoryModel(AddressingModel addressingmodel, MemoryModel memorymodel)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Addressingmodel = addressingmodel;
        Memorymodel = memorymodel;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemoryModel, (int)Addressingmodel, (int)Memorymodel];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "addressingmodel":
                    Addressingmodel = o.ToEnum<AddressingModel>();
                    break;
                case "memorymodel":
                    Memorymodel = o.ToEnum<MemoryModel>();
                    break;
            }
        }
    }

    public static implicit operator OpMemoryModel(OpDataIndex odi) => new(odi);
    public static implicit operator OpMemoryModel(OpData data) => new(data);
}

public struct OpEntryPoint : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEntryPoint()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEntryPoint | (1 << 16);
    }

    public OpEntryPoint(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpEntryPoint(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public ExecutionModel Executionmodel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EntryPoint
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEntryPoint(ExecutionModel executionmodel, int entryPoint, string name, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Executionmodel = executionmodel;
        EntryPoint = entryPoint;
        Name = name;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEntryPoint, (int)Executionmodel, EntryPoint, ..Name.AsDisposableLiteralValue().Words, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "executionmodel":
                    Executionmodel = o.ToEnum<ExecutionModel>();
                    break;
                case "entryPoint":
                    EntryPoint = o.ToLiteral<int>();
                    break;
                case "name":
                    Name = o.ToLiteral<string>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpEntryPoint(OpDataIndex odi) => new(odi);
    public static implicit operator OpEntryPoint(OpData data) => new(data);
}

public struct OpExecutionMode : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExecutionMode()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExecutionMode | (1 << 16);
    }

    public OpExecutionMode(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpExecutionMode(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int EntryPoint
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ExecutionMode> Mode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExecutionMode(int entryPoint, ParameterizedFlag<ExecutionMode> mode)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        EntryPoint = entryPoint;
        Mode = mode;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExecutionMode, EntryPoint, ..(Span<int>)[(int)Mode.Value, ..Mode.Span]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "entryPoint":
                    EntryPoint = o.ToLiteral<int>();
                    break;
                case "mode":
                    Mode = o.ToEnum<ExecutionMode>();
                    break;
            }
        }
    }

    public static implicit operator OpExecutionMode(OpDataIndex odi) => new(odi);
    public static implicit operator OpExecutionMode(OpData data) => new(data);
}

public struct OpCapability : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCapability()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCapability | (1 << 16);
    }

    public OpCapability(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCapability(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public Capability Capability
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCapability(Capability capability)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Capability = capability;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCapability, (int)Capability];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "capability":
                    Capability = o.ToEnum<Capability>();
                    break;
            }
        }
    }

    public static implicit operator OpCapability(OpDataIndex odi) => new(odi);
    public static implicit operator OpCapability(OpData data) => new(data);
}

public struct OpTypeVoid : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeVoid()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeVoid | (1 << 16);
    }

    public OpTypeVoid(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeVoid(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeVoid inst) => inst.ResultId;
    public OpTypeVoid(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeVoid, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeVoid(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeVoid(OpData data) => new(data);
}

public struct OpTypeBool : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeBool()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeBool | (1 << 16);
    }

    public OpTypeBool(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeBool(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeBool inst) => inst.ResultId;
    public OpTypeBool(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeBool, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeBool(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeBool(OpData data) => new(data);
}

public struct OpTypeInt : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeInt()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeInt | (1 << 16);
    }

    public OpTypeInt(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeInt(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Width
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Signedness
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeInt inst) => inst.ResultId;
    public OpTypeInt(int resultId, int width, int signedness)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        Width = width;
        Signedness = signedness;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeInt, ResultId, ..Width.AsDisposableLiteralValue().Words, ..Signedness.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "width":
                    Width = o.ToLiteral<int>();
                    break;
                case "signedness":
                    Signedness = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeInt(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeInt(OpData data) => new(data);
}

public struct OpTypeFloat : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeFloat()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeFloat | (1 << 16);
    }

    public OpTypeFloat(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeFloat(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Width
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public FPEncoding? FloatingPointEncoding
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeFloat inst) => inst.ResultId;
    public OpTypeFloat(int resultId, int width, FPEncoding? floatingPointEncoding)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        Width = width;
        FloatingPointEncoding = floatingPointEncoding;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeFloat, ResultId, ..Width.AsDisposableLiteralValue().Words, ..(FloatingPointEncoding is null ? (Span<int>)[] : [(int)FloatingPointEncoding.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "width":
                    Width = o.ToLiteral<int>();
                    break;
                case "floatingPointEncoding":
                    if (o.Words.Length > 0)
                        FloatingPointEncoding = o.ToEnum<FPEncoding>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeFloat(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeFloat(OpData data) => new(data);
}

public struct OpTypeVector : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeVector()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeVector | (1 << 16);
    }

    public OpTypeVector(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeVector(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ComponentType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ComponentCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeVector inst) => inst.ResultId;
    public OpTypeVector(int resultId, int componentType, int componentCount)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        ComponentType = componentType;
        ComponentCount = componentCount;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeVector, ResultId, ComponentType, ..ComponentCount.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "componentType":
                    ComponentType = o.ToLiteral<int>();
                    break;
                case "componentCount":
                    ComponentCount = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeVector(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeVector(OpData data) => new(data);
}

public struct OpTypeMatrix : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeMatrix()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeMatrix | (1 << 16);
    }

    public OpTypeMatrix(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeMatrix(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ColumnType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ColumnCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeMatrix inst) => inst.ResultId;
    public OpTypeMatrix(int resultId, int columnType, int columnCount)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        ColumnType = columnType;
        ColumnCount = columnCount;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeMatrix, ResultId, ColumnType, ..ColumnCount.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "columnType":
                    ColumnType = o.ToLiteral<int>();
                    break;
                case "columnCount":
                    ColumnCount = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeMatrix(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeMatrix(OpData data) => new(data);
}

public struct OpTypeImage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeImage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeImage | (1 << 16);
    }

    public OpTypeImage(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeImage(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public Dim Dim
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Depth
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Arrayed
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MS
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Sampled
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ImageFormat Imageformat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public AccessQualifier? Accessqualifier
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeImage inst) => inst.ResultId;
    public OpTypeImage(int resultId, int sampledType, Dim dim, int depth, int arrayed, int mS, int sampled, ImageFormat imageformat, AccessQualifier? accessqualifier)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        SampledType = sampledType;
        Dim = dim;
        Depth = depth;
        Arrayed = arrayed;
        MS = mS;
        Sampled = sampled;
        Imageformat = imageformat;
        Accessqualifier = accessqualifier;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeImage, ResultId, SampledType, (int)Dim, ..Depth.AsDisposableLiteralValue().Words, ..Arrayed.AsDisposableLiteralValue().Words, ..MS.AsDisposableLiteralValue().Words, ..Sampled.AsDisposableLiteralValue().Words, (int)Imageformat, ..(Accessqualifier is null ? (Span<int>)[] : [(int)Accessqualifier.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledType":
                    SampledType = o.ToLiteral<int>();
                    break;
                case "dim":
                    Dim = o.ToEnum<Dim>();
                    break;
                case "depth":
                    Depth = o.ToLiteral<int>();
                    break;
                case "arrayed":
                    Arrayed = o.ToLiteral<int>();
                    break;
                case "mS":
                    MS = o.ToLiteral<int>();
                    break;
                case "sampled":
                    Sampled = o.ToLiteral<int>();
                    break;
                case "imageformat":
                    Imageformat = o.ToEnum<ImageFormat>();
                    break;
                case "accessqualifier":
                    if (o.Words.Length > 0)
                        Accessqualifier = o.ToEnum<AccessQualifier>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeImage(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeImage(OpData data) => new(data);
}

public struct OpTypeSampler : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeSampler()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeSampler | (1 << 16);
    }

    public OpTypeSampler(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeSampler(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeSampler inst) => inst.ResultId;
    public OpTypeSampler(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeSampler, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeSampler(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeSampler(OpData data) => new(data);
}

public struct OpTypeSampledImage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeSampledImage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeSampledImage | (1 << 16);
    }

    public OpTypeSampledImage(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeSampledImage(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ImageType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeSampledImage inst) => inst.ResultId;
    public OpTypeSampledImage(int resultId, int imageType)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        ImageType = imageType;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeSampledImage, ResultId, ImageType];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "imageType":
                    ImageType = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeSampledImage(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeSampledImage(OpData data) => new(data);
}

public struct OpTypeArray : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeArray()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeArray | (1 << 16);
    }

    public OpTypeArray(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeArray(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ElementType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Length
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeArray inst) => inst.ResultId;
    public OpTypeArray(int resultId, int elementType, int length)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        ElementType = elementType;
        Length = length;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeArray, ResultId, ElementType, Length];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "elementType":
                    ElementType = o.ToLiteral<int>();
                    break;
                case "length":
                    Length = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeArray(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeArray(OpData data) => new(data);
}

public struct OpTypeRuntimeArray : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeRuntimeArray()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeRuntimeArray | (1 << 16);
    }

    public OpTypeRuntimeArray(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeRuntimeArray(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ElementType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeRuntimeArray inst) => inst.ResultId;
    public OpTypeRuntimeArray(int resultId, int elementType)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        ElementType = elementType;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeRuntimeArray, ResultId, ElementType];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "elementType":
                    ElementType = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeRuntimeArray(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeRuntimeArray(OpData data) => new(data);
}

public struct OpTypeStruct : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeStruct()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeStruct | (1 << 16);
    }

    public OpTypeStruct(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeStruct(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeStruct inst) => inst.ResultId;
    public OpTypeStruct(int resultId, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeStruct, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeStruct(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeStruct(OpData data) => new(data);
}

public struct OpTypeOpaque : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeOpaque()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeOpaque | (1 << 16);
    }

    public OpTypeOpaque(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeOpaque(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Thenameoftheopaquetype
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeOpaque inst) => inst.ResultId;
    public OpTypeOpaque(int resultId, string thenameoftheopaquetype)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        Thenameoftheopaquetype = thenameoftheopaquetype;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeOpaque, ResultId, ..Thenameoftheopaquetype.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "thenameoftheopaquetype":
                    Thenameoftheopaquetype = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeOpaque(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeOpaque(OpData data) => new(data);
}

public struct OpTypePointer : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypePointer()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypePointer | (1 << 16);
    }

    public OpTypePointer(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypePointer(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Type
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypePointer inst) => inst.ResultId;
    public OpTypePointer(int resultId, StorageClass storageclass, int type)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        Storageclass = storageclass;
        Type = type;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypePointer, ResultId, (int)Storageclass, Type];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "storageclass":
                    Storageclass = o.ToEnum<StorageClass>();
                    break;
                case "type":
                    Type = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypePointer(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypePointer(OpData data) => new(data);
}

public struct OpTypeFunction : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeFunction()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeFunction | (1 << 16);
    }

    public OpTypeFunction(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeFunction(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReturnType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeFunction inst) => inst.ResultId;
    public OpTypeFunction(int resultId, int returnType, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        ReturnType = returnType;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeFunction, ResultId, ReturnType, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "returnType":
                    ReturnType = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeFunction(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeFunction(OpData data) => new(data);
}

public struct OpTypeEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeEvent | (1 << 16);
    }

    public OpTypeEvent(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeEvent(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeEvent inst) => inst.ResultId;
    public OpTypeEvent(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeEvent, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeEvent(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeEvent(OpData data) => new(data);
}

public struct OpTypeDeviceEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeDeviceEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeDeviceEvent | (1 << 16);
    }

    public OpTypeDeviceEvent(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeDeviceEvent(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeDeviceEvent inst) => inst.ResultId;
    public OpTypeDeviceEvent(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeDeviceEvent, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeDeviceEvent(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeDeviceEvent(OpData data) => new(data);
}

public struct OpTypeReserveId : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeReserveId()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeReserveId | (1 << 16);
    }

    public OpTypeReserveId(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeReserveId(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeReserveId inst) => inst.ResultId;
    public OpTypeReserveId(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeReserveId, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeReserveId(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeReserveId(OpData data) => new(data);
}

public struct OpTypeQueue : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeQueue()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeQueue | (1 << 16);
    }

    public OpTypeQueue(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeQueue(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeQueue inst) => inst.ResultId;
    public OpTypeQueue(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeQueue, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeQueue(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeQueue(OpData data) => new(data);
}

public struct OpTypePipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypePipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypePipe | (1 << 16);
    }

    public OpTypePipe(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypePipe(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public AccessQualifier Qualifier
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypePipe inst) => inst.ResultId;
    public OpTypePipe(int resultId, AccessQualifier qualifier)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        Qualifier = qualifier;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypePipe, ResultId, (int)Qualifier];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "qualifier":
                    Qualifier = o.ToEnum<AccessQualifier>();
                    break;
            }
        }
    }

    public static implicit operator OpTypePipe(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypePipe(OpData data) => new(data);
}

public struct OpTypeForwardPointer : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeForwardPointer()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeForwardPointer | (1 << 16);
    }

    public OpTypeForwardPointer(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeForwardPointer(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int PointerType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeForwardPointer(int pointerType, StorageClass storageclass)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        PointerType = pointerType;
        Storageclass = storageclass;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeForwardPointer, PointerType, (int)Storageclass];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointerType":
                    PointerType = o.ToLiteral<int>();
                    break;
                case "storageclass":
                    Storageclass = o.ToEnum<StorageClass>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeForwardPointer(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeForwardPointer(OpData data) => new(data);
}

public struct OpConstantTrue : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantTrue()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantTrue | (1 << 16);
    }

    public OpConstantTrue(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConstantTrue(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantTrue inst) => inst.ResultId;
    public OpConstantTrue(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantTrue, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConstantTrue(OpDataIndex odi) => new(odi);
    public static implicit operator OpConstantTrue(OpData data) => new(data);
}

public struct OpConstantFalse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantFalse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantFalse | (1 << 16);
    }

    public OpConstantFalse(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConstantFalse(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantFalse inst) => inst.ResultId;
    public OpConstantFalse(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantFalse, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConstantFalse(OpDataIndex odi) => new(odi);
    public static implicit operator OpConstantFalse(OpData data) => new(data);
}

public struct OpConstant<T> : IMemoryInstruction where T : struct, INumber<T>
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstant()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstant | (1 << 16);
    }

    public OpConstant(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConstant(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public T Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstant<T> inst) => inst.ResultId;
    public OpConstant(int resultType, int resultId, LiteralValue<T> value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstant, ResultType, ResultId, ..Value.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<LiteralValue<T>>();
                    break;
            }
        }
    }

    public static implicit operator OpConstant<T>(OpDataIndex odi) => new(odi);
    public static implicit operator OpConstant<T>(OpData data) => new(data);
}

public struct OpConstantComposite : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantComposite()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantComposite | (1 << 16);
    }

    public OpConstantComposite(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConstantComposite(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantComposite inst) => inst.ResultId;
    public OpConstantComposite(int resultType, int resultId, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantComposite, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConstantComposite(OpDataIndex odi) => new(odi);
    public static implicit operator OpConstantComposite(OpData data) => new(data);
}

public struct OpConstantSampler : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantSampler()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantSampler | (1 << 16);
    }

    public OpConstantSampler(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConstantSampler(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public SamplerAddressingMode Sampleraddressingmode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public SamplerFilterMode Samplerfiltermode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantSampler inst) => inst.ResultId;
    public OpConstantSampler(int resultType, int resultId, SamplerAddressingMode sampleraddressingmode, int param, SamplerFilterMode samplerfiltermode)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Sampleraddressingmode = sampleraddressingmode;
        Param = param;
        Samplerfiltermode = samplerfiltermode;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantSampler, ResultType, ResultId, (int)Sampleraddressingmode, ..Param.AsDisposableLiteralValue().Words, (int)Samplerfiltermode];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampleraddressingmode":
                    Sampleraddressingmode = o.ToEnum<SamplerAddressingMode>();
                    break;
                case "param":
                    Param = o.ToLiteral<int>();
                    break;
                case "samplerfiltermode":
                    Samplerfiltermode = o.ToEnum<SamplerFilterMode>();
                    break;
            }
        }
    }

    public static implicit operator OpConstantSampler(OpDataIndex odi) => new(odi);
    public static implicit operator OpConstantSampler(OpData data) => new(data);
}

public struct OpConstantNull : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantNull()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantNull | (1 << 16);
    }

    public OpConstantNull(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConstantNull(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantNull inst) => inst.ResultId;
    public OpConstantNull(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantNull, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConstantNull(OpDataIndex odi) => new(odi);
    public static implicit operator OpConstantNull(OpData data) => new(data);
}

public struct OpSpecConstantTrue : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantTrue()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantTrue | (1 << 16);
    }

    public OpSpecConstantTrue(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSpecConstantTrue(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSpecConstantTrue inst) => inst.ResultId;
    public OpSpecConstantTrue(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantTrue, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSpecConstantTrue(OpDataIndex odi) => new(odi);
    public static implicit operator OpSpecConstantTrue(OpData data) => new(data);
}

public struct OpSpecConstantFalse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantFalse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantFalse | (1 << 16);
    }

    public OpSpecConstantFalse(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSpecConstantFalse(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSpecConstantFalse inst) => inst.ResultId;
    public OpSpecConstantFalse(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantFalse, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSpecConstantFalse(OpDataIndex odi) => new(odi);
    public static implicit operator OpSpecConstantFalse(OpData data) => new(data);
}

public struct OpSpecConstant<T> : IMemoryInstruction where T : struct, INumber<T>
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstant()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstant | (1 << 16);
    }

    public OpSpecConstant(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSpecConstant(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public T Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSpecConstant<T> inst) => inst.ResultId;
    public OpSpecConstant(int resultType, int resultId, LiteralValue<T> value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstant, ResultType, ResultId, ..Value.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<LiteralValue<T>>();
                    break;
            }
        }
    }

    public static implicit operator OpSpecConstant<T>(OpDataIndex odi) => new(odi);
    public static implicit operator OpSpecConstant<T>(OpData data) => new(data);
}

public struct OpSpecConstantComposite : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantComposite()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantComposite | (1 << 16);
    }

    public OpSpecConstantComposite(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSpecConstantComposite(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSpecConstantComposite inst) => inst.ResultId;
    public OpSpecConstantComposite(int resultType, int resultId, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantComposite, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSpecConstantComposite(OpDataIndex odi) => new(odi);
    public static implicit operator OpSpecConstantComposite(OpData data) => new(data);
}

public struct OpSpecConstantOp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantOp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantOp | (1 << 16);
    }

    public OpSpecConstantOp(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSpecConstantOp(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Opcode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSpecConstantOp inst) => inst.ResultId;
    public OpSpecConstantOp(int resultType, int resultId, int opcode)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Opcode = opcode;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantOp, ResultType, ResultId, ..Opcode.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "opcode":
                    Opcode = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSpecConstantOp(OpDataIndex odi) => new(odi);
    public static implicit operator OpSpecConstantOp(OpData data) => new(data);
}

public struct OpFunction : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFunction()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFunction | (1 << 16);
    }

    public OpFunction(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFunction(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public FunctionControlMask Functioncontrol
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FunctionType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFunction inst) => inst.ResultId;
    public OpFunction(int resultType, int resultId, FunctionControlMask functioncontrol, int functionType)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Functioncontrol = functioncontrol;
        FunctionType = functionType;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFunction, ResultType, ResultId, (int)Functioncontrol, FunctionType];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "functioncontrol":
                    Functioncontrol = o.ToEnum<FunctionControlMask>();
                    break;
                case "functionType":
                    FunctionType = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFunction(OpDataIndex odi) => new(odi);
    public static implicit operator OpFunction(OpData data) => new(data);
}

public struct OpFunctionParameter : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFunctionParameter()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFunctionParameter | (1 << 16);
    }

    public OpFunctionParameter(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFunctionParameter(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFunctionParameter inst) => inst.ResultId;
    public OpFunctionParameter(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFunctionParameter, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFunctionParameter(OpDataIndex odi) => new(odi);
    public static implicit operator OpFunctionParameter(OpData data) => new(data);
}

public struct OpFunctionEnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFunctionEnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFunctionEnd | (1 << 16);
    }

    public OpFunctionEnd(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFunctionEnd(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFunctionEnd, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpFunctionEnd(OpDataIndex odi) => new(odi);
    public static implicit operator OpFunctionEnd(OpData data) => new(data);
}

public struct OpFunctionCall : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFunctionCall()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFunctionCall | (1 << 16);
    }

    public OpFunctionCall(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFunctionCall(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Function
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFunctionCall inst) => inst.ResultId;
    public OpFunctionCall(int resultType, int resultId, int function, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Function = function;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFunctionCall, ResultType, ResultId, Function, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "function":
                    Function = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFunctionCall(OpDataIndex odi) => new(odi);
    public static implicit operator OpFunctionCall(OpData data) => new(data);
}

public struct OpVariable : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVariable()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVariable | (1 << 16);
    }

    public OpVariable(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpVariable(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Initializer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVariable inst) => inst.ResultId;
    public OpVariable(int resultType, int resultId, StorageClass storageclass, int? initializer)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Storageclass = storageclass;
        Initializer = initializer;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVariable, ResultType, ResultId, (int)Storageclass, ..(Initializer is null ? (Span<int>)[] : [Initializer.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "storageclass":
                    Storageclass = o.ToEnum<StorageClass>();
                    break;
                case "initializer":
                    if (o.Words.Length > 0)
                        Initializer = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpVariable(OpDataIndex odi) => new(odi);
    public static implicit operator OpVariable(OpData data) => new(data);
}

public struct OpImageTexelPointer : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageTexelPointer()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageTexelPointer | (1 << 16);
    }

    public OpImageTexelPointer(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageTexelPointer(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Sample
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageTexelPointer inst) => inst.ResultId;
    public OpImageTexelPointer(int resultType, int resultId, int image, int coordinate, int sample)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Sample = sample;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageTexelPointer, ResultType, ResultId, Image, Coordinate, Sample];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "sample":
                    Sample = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageTexelPointer(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageTexelPointer(OpData data) => new(data);
}

public struct OpLoad : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLoad()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLoad | (1 << 16);
    }

    public OpLoad(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpLoad(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<MemoryAccessMask>? Memoryaccess
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpLoad inst) => inst.ResultId;
    public OpLoad(int resultType, int resultId, int pointer, ParameterizedFlag<MemoryAccessMask>? memoryaccess)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memoryaccess = memoryaccess;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLoad, ResultType, ResultId, Pointer, ..(Memoryaccess is null ? (Span<int>)[] : [(int)Memoryaccess.Value.Value, ..Memoryaccess.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memoryaccess":
                    if (o.Words.Length > 0)
                        Memoryaccess = o.ToEnum<MemoryAccessMask>();
                    break;
            }
        }
    }

    public static implicit operator OpLoad(OpDataIndex odi) => new(odi);
    public static implicit operator OpLoad(OpData data) => new(data);
}

public struct OpStore : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpStore()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpStore | (1 << 16);
    }

    public OpStore(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpStore(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<MemoryAccessMask>? Memoryaccess
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpStore(int pointer, int objectId, ParameterizedFlag<MemoryAccessMask>? memoryaccess)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Pointer = pointer;
        ObjectId = objectId;
        Memoryaccess = memoryaccess;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpStore, Pointer, ObjectId, ..(Memoryaccess is null ? (Span<int>)[] : [(int)Memoryaccess.Value.Value, ..Memoryaccess.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "objectId":
                    ObjectId = o.ToLiteral<int>();
                    break;
                case "memoryaccess":
                    if (o.Words.Length > 0)
                        Memoryaccess = o.ToEnum<MemoryAccessMask>();
                    break;
            }
        }
    }

    public static implicit operator OpStore(OpDataIndex odi) => new(odi);
    public static implicit operator OpStore(OpData data) => new(data);
}

public struct OpAccessChain : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAccessChain()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAccessChain | (1 << 16);
    }

    public OpAccessChain(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAccessChain(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAccessChain inst) => inst.ResultId;
    public OpAccessChain(int resultType, int resultId, int baseId, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAccessChain, ResultType, ResultId, BaseId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAccessChain(OpDataIndex odi) => new(odi);
    public static implicit operator OpAccessChain(OpData data) => new(data);
}

public struct OpInBoundsAccessChain : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpInBoundsAccessChain()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpInBoundsAccessChain | (1 << 16);
    }

    public OpInBoundsAccessChain(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpInBoundsAccessChain(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpInBoundsAccessChain inst) => inst.ResultId;
    public OpInBoundsAccessChain(int resultType, int resultId, int baseId, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpInBoundsAccessChain, ResultType, ResultId, BaseId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpInBoundsAccessChain(OpDataIndex odi) => new(odi);
    public static implicit operator OpInBoundsAccessChain(OpData data) => new(data);
}

public struct OpPtrAccessChain : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrAccessChain()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrAccessChain | (1 << 16);
    }

    public OpPtrAccessChain(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpPtrAccessChain(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Element
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpPtrAccessChain inst) => inst.ResultId;
    public OpPtrAccessChain(int resultType, int resultId, int baseId, int element, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Element = element;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrAccessChain, ResultType, ResultId, BaseId, Element, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "element":
                    Element = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpPtrAccessChain(OpDataIndex odi) => new(odi);
    public static implicit operator OpPtrAccessChain(OpData data) => new(data);
}

public struct OpArrayLength : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArrayLength()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArrayLength | (1 << 16);
    }

    public OpArrayLength(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArrayLength(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Structure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Arraymember
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArrayLength inst) => inst.ResultId;
    public OpArrayLength(int resultType, int resultId, int structure, int arraymember)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Structure = structure;
        Arraymember = arraymember;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArrayLength, ResultType, ResultId, Structure, ..Arraymember.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "structure":
                    Structure = o.ToLiteral<int>();
                    break;
                case "arraymember":
                    Arraymember = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArrayLength(OpDataIndex odi) => new(odi);
    public static implicit operator OpArrayLength(OpData data) => new(data);
}

public struct OpGenericPtrMemSemantics : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGenericPtrMemSemantics()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGenericPtrMemSemantics | (1 << 16);
    }

    public OpGenericPtrMemSemantics(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGenericPtrMemSemantics(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGenericPtrMemSemantics inst) => inst.ResultId;
    public OpGenericPtrMemSemantics(int resultType, int resultId, int pointer)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGenericPtrMemSemantics, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGenericPtrMemSemantics(OpDataIndex odi) => new(odi);
    public static implicit operator OpGenericPtrMemSemantics(OpData data) => new(data);
}

public struct OpInBoundsPtrAccessChain : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpInBoundsPtrAccessChain()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpInBoundsPtrAccessChain | (1 << 16);
    }

    public OpInBoundsPtrAccessChain(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpInBoundsPtrAccessChain(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Element
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpInBoundsPtrAccessChain inst) => inst.ResultId;
    public OpInBoundsPtrAccessChain(int resultType, int resultId, int baseId, int element, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Element = element;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpInBoundsPtrAccessChain, ResultType, ResultId, BaseId, Element, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "element":
                    Element = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpInBoundsPtrAccessChain(OpDataIndex odi) => new(odi);
    public static implicit operator OpInBoundsPtrAccessChain(OpData data) => new(data);
}

public struct OpDecorate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDecorate()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDecorate | (1 << 16);
    }

    public OpDecorate(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpDecorate(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<Decoration> Decoration
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDecorate(int target, ParameterizedFlag<Decoration> decoration)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Target = target;
        Decoration = decoration;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDecorate, Target, ..(Span<int>)[(int)Decoration.Value, ..Decoration.Span]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "target":
                    Target = o.ToLiteral<int>();
                    break;
                case "decoration":
                    Decoration = o.ToEnum<Decoration>();
                    break;
            }
        }
    }

    public static implicit operator OpDecorate(OpDataIndex odi) => new(odi);
    public static implicit operator OpDecorate(OpData data) => new(data);
}

public struct OpMemberDecorate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemberDecorate()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemberDecorate | (1 << 16);
    }

    public OpMemberDecorate(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpMemberDecorate(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int StructureType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Member
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<Decoration> Decoration
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemberDecorate(int structureType, int member, ParameterizedFlag<Decoration> decoration)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        StructureType = structureType;
        Member = member;
        Decoration = decoration;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemberDecorate, StructureType, ..Member.AsDisposableLiteralValue().Words, ..(Span<int>)[(int)Decoration.Value, ..Decoration.Span]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "structureType":
                    StructureType = o.ToLiteral<int>();
                    break;
                case "member":
                    Member = o.ToLiteral<int>();
                    break;
                case "decoration":
                    Decoration = o.ToEnum<Decoration>();
                    break;
            }
        }
    }

    public static implicit operator OpMemberDecorate(OpDataIndex odi) => new(odi);
    public static implicit operator OpMemberDecorate(OpData data) => new(data);
}

public struct OpDecorationGroup : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDecorationGroup()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDecorationGroup | (1 << 16);
    }

    public OpDecorationGroup(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpDecorationGroup(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDecorationGroup inst) => inst.ResultId;
    public OpDecorationGroup(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDecorationGroup, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpDecorationGroup(OpDataIndex odi) => new(odi);
    public static implicit operator OpDecorationGroup(OpData data) => new(data);
}

public struct OpGroupDecorate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupDecorate()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupDecorate | (1 << 16);
    }

    public OpGroupDecorate(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupDecorate(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int DecorationGroup
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupDecorate(int decorationGroup, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DecorationGroup = decorationGroup;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupDecorate, DecorationGroup, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "decorationGroup":
                    DecorationGroup = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupDecorate(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupDecorate(OpData data) => new(data);
}

public struct OpGroupMemberDecorate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupMemberDecorate()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupMemberDecorate | (1 << 16);
    }

    public OpGroupMemberDecorate(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupMemberDecorate(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int DecorationGroup
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<(int, int)> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupMemberDecorate(int decorationGroup, LiteralArray<(int, int)> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DecorationGroup = decorationGroup;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupMemberDecorate, DecorationGroup, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "decorationGroup":
                    DecorationGroup = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<(int, int)>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupMemberDecorate(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupMemberDecorate(OpData data) => new(data);
}

public struct OpVectorExtractDynamic : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVectorExtractDynamic()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVectorExtractDynamic | (1 << 16);
    }

    public OpVectorExtractDynamic(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpVectorExtractDynamic(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVectorExtractDynamic inst) => inst.ResultId;
    public OpVectorExtractDynamic(int resultType, int resultId, int vector, int index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        Index = index;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVectorExtractDynamic, ResultType, ResultId, Vector, Index];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector":
                    Vector = o.ToLiteral<int>();
                    break;
                case "index":
                    Index = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpVectorExtractDynamic(OpDataIndex odi) => new(odi);
    public static implicit operator OpVectorExtractDynamic(OpData data) => new(data);
}

public struct OpVectorInsertDynamic : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVectorInsertDynamic()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVectorInsertDynamic | (1 << 16);
    }

    public OpVectorInsertDynamic(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpVectorInsertDynamic(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Component
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVectorInsertDynamic inst) => inst.ResultId;
    public OpVectorInsertDynamic(int resultType, int resultId, int vector, int component, int index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        Component = component;
        Index = index;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVectorInsertDynamic, ResultType, ResultId, Vector, Component, Index];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector":
                    Vector = o.ToLiteral<int>();
                    break;
                case "component":
                    Component = o.ToLiteral<int>();
                    break;
                case "index":
                    Index = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpVectorInsertDynamic(OpDataIndex odi) => new(odi);
    public static implicit operator OpVectorInsertDynamic(OpData data) => new(data);
}

public struct OpVectorShuffle : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVectorShuffle()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVectorShuffle | (1 << 16);
    }

    public OpVectorShuffle(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpVectorShuffle(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVectorShuffle inst) => inst.ResultId;
    public OpVectorShuffle(int resultType, int resultId, int vector1, int vector2, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVectorShuffle, ResultType, ResultId, Vector1, Vector2, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpVectorShuffle(OpDataIndex odi) => new(odi);
    public static implicit operator OpVectorShuffle(OpData data) => new(data);
}

public struct OpCompositeConstruct : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCompositeConstruct()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCompositeConstruct | (1 << 16);
    }

    public OpCompositeConstruct(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCompositeConstruct(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCompositeConstruct inst) => inst.ResultId;
    public OpCompositeConstruct(int resultType, int resultId, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCompositeConstruct, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCompositeConstruct(OpDataIndex odi) => new(odi);
    public static implicit operator OpCompositeConstruct(OpData data) => new(data);
}

public struct OpCompositeExtract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCompositeExtract()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCompositeExtract | (1 << 16);
    }

    public OpCompositeExtract(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCompositeExtract(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Composite
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCompositeExtract inst) => inst.ResultId;
    public OpCompositeExtract(int resultType, int resultId, int composite, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Composite = composite;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCompositeExtract, ResultType, ResultId, Composite, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "composite":
                    Composite = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCompositeExtract(OpDataIndex odi) => new(odi);
    public static implicit operator OpCompositeExtract(OpData data) => new(data);
}

public struct OpCompositeInsert : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCompositeInsert()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCompositeInsert | (1 << 16);
    }

    public OpCompositeInsert(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCompositeInsert(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Composite
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCompositeInsert inst) => inst.ResultId;
    public OpCompositeInsert(int resultType, int resultId, int objectId, int composite, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        ObjectId = objectId;
        Composite = composite;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCompositeInsert, ResultType, ResultId, ObjectId, Composite, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "objectId":
                    ObjectId = o.ToLiteral<int>();
                    break;
                case "composite":
                    Composite = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCompositeInsert(OpDataIndex odi) => new(odi);
    public static implicit operator OpCompositeInsert(OpData data) => new(data);
}

public struct OpCopyObject : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCopyObject()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCopyObject | (1 << 16);
    }

    public OpCopyObject(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCopyObject(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCopyObject inst) => inst.ResultId;
    public OpCopyObject(int resultType, int resultId, int operand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCopyObject, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCopyObject(OpDataIndex odi) => new(odi);
    public static implicit operator OpCopyObject(OpData data) => new(data);
}

public struct OpTranspose : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTranspose()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTranspose | (1 << 16);
    }

    public OpTranspose(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTranspose(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTranspose inst) => inst.ResultId;
    public OpTranspose(int resultType, int resultId, int matrix)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTranspose, ResultType, ResultId, Matrix];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "matrix":
                    Matrix = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTranspose(OpDataIndex odi) => new(odi);
    public static implicit operator OpTranspose(OpData data) => new(data);
}

public struct OpSampledImage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSampledImage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSampledImage | (1 << 16);
    }

    public OpSampledImage(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSampledImage(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Sampler
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSampledImage inst) => inst.ResultId;
    public OpSampledImage(int resultType, int resultId, int image, int sampler)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Sampler = sampler;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSampledImage, ResultType, ResultId, Image, Sampler];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "sampler":
                    Sampler = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSampledImage(OpDataIndex odi) => new(odi);
    public static implicit operator OpSampledImage(OpData data) => new(data);
}

public struct OpImageSampleImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleImplicitLod | (1 << 16);
    }

    public OpImageSampleImplicitLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSampleImplicitLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleImplicitLod inst) => inst.ResultId;
    public OpImageSampleImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleImplicitLod, ResultType, ResultId, SampledImage, Coordinate, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleImplicitLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSampleImplicitLod(OpData data) => new(data);
}

public struct OpImageSampleExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleExplicitLod | (1 << 16);
    }

    public OpImageSampleExplicitLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSampleExplicitLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask> Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleExplicitLod inst) => inst.ResultId;
    public OpImageSampleExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ParameterizedFlag<ImageOperandsMask> imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleExplicitLod, ResultType, ResultId, SampledImage, Coordinate, ..(Span<int>)[(int)Imageoperands.Value, ..Imageoperands.Span]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleExplicitLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSampleExplicitLod(OpData data) => new(data);
}

public struct OpImageSampleDrefImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleDrefImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleDrefImplicitLod | (1 << 16);
    }

    public OpImageSampleDrefImplicitLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSampleDrefImplicitLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleDrefImplicitLod inst) => inst.ResultId;
    public OpImageSampleDrefImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleDrefImplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleDrefImplicitLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSampleDrefImplicitLod(OpData data) => new(data);
}

public struct OpImageSampleDrefExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleDrefExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleDrefExplicitLod | (1 << 16);
    }

    public OpImageSampleDrefExplicitLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSampleDrefExplicitLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask> Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleDrefExplicitLod inst) => inst.ResultId;
    public OpImageSampleDrefExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ParameterizedFlag<ImageOperandsMask> imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleDrefExplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, ..(Span<int>)[(int)Imageoperands.Value, ..Imageoperands.Span]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleDrefExplicitLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSampleDrefExplicitLod(OpData data) => new(data);
}

public struct OpImageSampleProjImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleProjImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleProjImplicitLod | (1 << 16);
    }

    public OpImageSampleProjImplicitLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSampleProjImplicitLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleProjImplicitLod inst) => inst.ResultId;
    public OpImageSampleProjImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleProjImplicitLod, ResultType, ResultId, SampledImage, Coordinate, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleProjImplicitLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSampleProjImplicitLod(OpData data) => new(data);
}

public struct OpImageSampleProjExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleProjExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleProjExplicitLod | (1 << 16);
    }

    public OpImageSampleProjExplicitLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSampleProjExplicitLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask> Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleProjExplicitLod inst) => inst.ResultId;
    public OpImageSampleProjExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ParameterizedFlag<ImageOperandsMask> imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleProjExplicitLod, ResultType, ResultId, SampledImage, Coordinate, ..(Span<int>)[(int)Imageoperands.Value, ..Imageoperands.Span]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleProjExplicitLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSampleProjExplicitLod(OpData data) => new(data);
}

public struct OpImageSampleProjDrefImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleProjDrefImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleProjDrefImplicitLod | (1 << 16);
    }

    public OpImageSampleProjDrefImplicitLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSampleProjDrefImplicitLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleProjDrefImplicitLod inst) => inst.ResultId;
    public OpImageSampleProjDrefImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleProjDrefImplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleProjDrefImplicitLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSampleProjDrefImplicitLod(OpData data) => new(data);
}

public struct OpImageSampleProjDrefExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleProjDrefExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleProjDrefExplicitLod | (1 << 16);
    }

    public OpImageSampleProjDrefExplicitLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSampleProjDrefExplicitLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask> Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleProjDrefExplicitLod inst) => inst.ResultId;
    public OpImageSampleProjDrefExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ParameterizedFlag<ImageOperandsMask> imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleProjDrefExplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, ..(Span<int>)[(int)Imageoperands.Value, ..Imageoperands.Span]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleProjDrefExplicitLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSampleProjDrefExplicitLod(OpData data) => new(data);
}

public struct OpImageFetch : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageFetch()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageFetch | (1 << 16);
    }

    public OpImageFetch(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageFetch(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageFetch inst) => inst.ResultId;
    public OpImageFetch(int resultType, int resultId, int image, int coordinate, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageFetch, ResultType, ResultId, Image, Coordinate, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageFetch(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageFetch(OpData data) => new(data);
}

public struct OpImageGather : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageGather()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageGather | (1 << 16);
    }

    public OpImageGather(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageGather(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Component
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageGather inst) => inst.ResultId;
    public OpImageGather(int resultType, int resultId, int sampledImage, int coordinate, int component, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Component = component;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageGather, ResultType, ResultId, SampledImage, Coordinate, Component, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "component":
                    Component = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageGather(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageGather(OpData data) => new(data);
}

public struct OpImageDrefGather : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageDrefGather()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageDrefGather | (1 << 16);
    }

    public OpImageDrefGather(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageDrefGather(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageDrefGather inst) => inst.ResultId;
    public OpImageDrefGather(int resultType, int resultId, int sampledImage, int coordinate, int dref, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageDrefGather, ResultType, ResultId, SampledImage, Coordinate, Dref, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageDrefGather(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageDrefGather(OpData data) => new(data);
}

public struct OpImageRead : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageRead()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageRead | (1 << 16);
    }

    public OpImageRead(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageRead(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageRead inst) => inst.ResultId;
    public OpImageRead(int resultType, int resultId, int image, int coordinate, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageRead, ResultType, ResultId, Image, Coordinate, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageRead(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageRead(OpData data) => new(data);
}

public struct OpImageWrite : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageWrite()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageWrite | (1 << 16);
    }

    public OpImageWrite(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageWrite(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Texel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpImageWrite(int image, int coordinate, int texel, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Image = image;
        Coordinate = coordinate;
        Texel = texel;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageWrite, Image, Coordinate, Texel, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "texel":
                    Texel = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageWrite(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageWrite(OpData data) => new(data);
}

public struct OpImage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImage | (1 << 16);
    }

    public OpImage(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImage(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImage inst) => inst.ResultId;
    public OpImage(int resultType, int resultId, int sampledImage)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImage, ResultType, ResultId, SampledImage];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImage(OpDataIndex odi) => new(odi);
    public static implicit operator OpImage(OpData data) => new(data);
}

public struct OpImageQueryFormat : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQueryFormat()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQueryFormat | (1 << 16);
    }

    public OpImageQueryFormat(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageQueryFormat(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageQueryFormat inst) => inst.ResultId;
    public OpImageQueryFormat(int resultType, int resultId, int image)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQueryFormat, ResultType, ResultId, Image];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageQueryFormat(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageQueryFormat(OpData data) => new(data);
}

public struct OpImageQueryOrder : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQueryOrder()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQueryOrder | (1 << 16);
    }

    public OpImageQueryOrder(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageQueryOrder(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageQueryOrder inst) => inst.ResultId;
    public OpImageQueryOrder(int resultType, int resultId, int image)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQueryOrder, ResultType, ResultId, Image];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageQueryOrder(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageQueryOrder(OpData data) => new(data);
}

public struct OpImageQuerySizeLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQuerySizeLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQuerySizeLod | (1 << 16);
    }

    public OpImageQuerySizeLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageQuerySizeLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LevelofDetail
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageQuerySizeLod inst) => inst.ResultId;
    public OpImageQuerySizeLod(int resultType, int resultId, int image, int levelofDetail)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        LevelofDetail = levelofDetail;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQuerySizeLod, ResultType, ResultId, Image, LevelofDetail];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "levelofDetail":
                    LevelofDetail = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageQuerySizeLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageQuerySizeLod(OpData data) => new(data);
}

public struct OpImageQuerySize : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQuerySize()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQuerySize | (1 << 16);
    }

    public OpImageQuerySize(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageQuerySize(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageQuerySize inst) => inst.ResultId;
    public OpImageQuerySize(int resultType, int resultId, int image)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQuerySize, ResultType, ResultId, Image];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageQuerySize(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageQuerySize(OpData data) => new(data);
}

public struct OpImageQueryLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQueryLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQueryLod | (1 << 16);
    }

    public OpImageQueryLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageQueryLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageQueryLod inst) => inst.ResultId;
    public OpImageQueryLod(int resultType, int resultId, int sampledImage, int coordinate)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQueryLod, ResultType, ResultId, SampledImage, Coordinate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageQueryLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageQueryLod(OpData data) => new(data);
}

public struct OpImageQueryLevels : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQueryLevels()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQueryLevels | (1 << 16);
    }

    public OpImageQueryLevels(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageQueryLevels(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageQueryLevels inst) => inst.ResultId;
    public OpImageQueryLevels(int resultType, int resultId, int image)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQueryLevels, ResultType, ResultId, Image];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageQueryLevels(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageQueryLevels(OpData data) => new(data);
}

public struct OpImageQuerySamples : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageQuerySamples()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageQuerySamples | (1 << 16);
    }

    public OpImageQuerySamples(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageQuerySamples(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageQuerySamples inst) => inst.ResultId;
    public OpImageQuerySamples(int resultType, int resultId, int image)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageQuerySamples, ResultType, ResultId, Image];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageQuerySamples(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageQuerySamples(OpData data) => new(data);
}

public struct OpConvertFToU : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertFToU()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertFToU | (1 << 16);
    }

    public OpConvertFToU(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConvertFToU(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FloatValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertFToU inst) => inst.ResultId;
    public OpConvertFToU(int resultType, int resultId, int floatValue)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        FloatValue = floatValue;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertFToU, ResultType, ResultId, FloatValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "floatValue":
                    FloatValue = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConvertFToU(OpDataIndex odi) => new(odi);
    public static implicit operator OpConvertFToU(OpData data) => new(data);
}

public struct OpConvertFToS : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertFToS()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertFToS | (1 << 16);
    }

    public OpConvertFToS(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConvertFToS(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FloatValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertFToS inst) => inst.ResultId;
    public OpConvertFToS(int resultType, int resultId, int floatValue)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        FloatValue = floatValue;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertFToS, ResultType, ResultId, FloatValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "floatValue":
                    FloatValue = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConvertFToS(OpDataIndex odi) => new(odi);
    public static implicit operator OpConvertFToS(OpData data) => new(data);
}

public struct OpConvertSToF : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertSToF()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertSToF | (1 << 16);
    }

    public OpConvertSToF(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConvertSToF(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertSToF inst) => inst.ResultId;
    public OpConvertSToF(int resultType, int resultId, int signedValue)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SignedValue = signedValue;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertSToF, ResultType, ResultId, SignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "signedValue":
                    SignedValue = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConvertSToF(OpDataIndex odi) => new(odi);
    public static implicit operator OpConvertSToF(OpData data) => new(data);
}

public struct OpConvertUToF : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToF()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToF | (1 << 16);
    }

    public OpConvertUToF(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConvertUToF(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UnsignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertUToF inst) => inst.ResultId;
    public OpConvertUToF(int resultType, int resultId, int unsignedValue)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        UnsignedValue = unsignedValue;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToF, ResultType, ResultId, UnsignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "unsignedValue":
                    UnsignedValue = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConvertUToF(OpDataIndex odi) => new(odi);
    public static implicit operator OpConvertUToF(OpData data) => new(data);
}

public struct OpUConvert : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUConvert()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUConvert | (1 << 16);
    }

    public OpUConvert(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUConvert(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UnsignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUConvert inst) => inst.ResultId;
    public OpUConvert(int resultType, int resultId, int unsignedValue)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        UnsignedValue = unsignedValue;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUConvert, ResultType, ResultId, UnsignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "unsignedValue":
                    UnsignedValue = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUConvert(OpDataIndex odi) => new(odi);
    public static implicit operator OpUConvert(OpData data) => new(data);
}

public struct OpSConvert : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSConvert()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSConvert | (1 << 16);
    }

    public OpSConvert(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSConvert(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSConvert inst) => inst.ResultId;
    public OpSConvert(int resultType, int resultId, int signedValue)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SignedValue = signedValue;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSConvert, ResultType, ResultId, SignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "signedValue":
                    SignedValue = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSConvert(OpDataIndex odi) => new(odi);
    public static implicit operator OpSConvert(OpData data) => new(data);
}

public struct OpFConvert : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFConvert()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFConvert | (1 << 16);
    }

    public OpFConvert(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFConvert(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FloatValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFConvert inst) => inst.ResultId;
    public OpFConvert(int resultType, int resultId, int floatValue)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        FloatValue = floatValue;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFConvert, ResultType, ResultId, FloatValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "floatValue":
                    FloatValue = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFConvert(OpDataIndex odi) => new(odi);
    public static implicit operator OpFConvert(OpData data) => new(data);
}

public struct OpQuantizeToF16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpQuantizeToF16()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpQuantizeToF16 | (1 << 16);
    }

    public OpQuantizeToF16(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpQuantizeToF16(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpQuantizeToF16 inst) => inst.ResultId;
    public OpQuantizeToF16(int resultType, int resultId, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpQuantizeToF16, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpQuantizeToF16(OpDataIndex odi) => new(odi);
    public static implicit operator OpQuantizeToF16(OpData data) => new(data);
}

public struct OpConvertPtrToU : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertPtrToU()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertPtrToU | (1 << 16);
    }

    public OpConvertPtrToU(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConvertPtrToU(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertPtrToU inst) => inst.ResultId;
    public OpConvertPtrToU(int resultType, int resultId, int pointer)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertPtrToU, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConvertPtrToU(OpDataIndex odi) => new(odi);
    public static implicit operator OpConvertPtrToU(OpData data) => new(data);
}

public struct OpSatConvertSToU : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSatConvertSToU()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSatConvertSToU | (1 << 16);
    }

    public OpSatConvertSToU(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSatConvertSToU(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSatConvertSToU inst) => inst.ResultId;
    public OpSatConvertSToU(int resultType, int resultId, int signedValue)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SignedValue = signedValue;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSatConvertSToU, ResultType, ResultId, SignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "signedValue":
                    SignedValue = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSatConvertSToU(OpDataIndex odi) => new(odi);
    public static implicit operator OpSatConvertSToU(OpData data) => new(data);
}

public struct OpSatConvertUToS : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSatConvertUToS()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSatConvertUToS | (1 << 16);
    }

    public OpSatConvertUToS(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSatConvertUToS(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UnsignedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSatConvertUToS inst) => inst.ResultId;
    public OpSatConvertUToS(int resultType, int resultId, int unsignedValue)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        UnsignedValue = unsignedValue;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSatConvertUToS, ResultType, ResultId, UnsignedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "unsignedValue":
                    UnsignedValue = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSatConvertUToS(OpDataIndex odi) => new(odi);
    public static implicit operator OpSatConvertUToS(OpData data) => new(data);
}

public struct OpConvertUToPtr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToPtr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToPtr | (1 << 16);
    }

    public OpConvertUToPtr(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConvertUToPtr(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int IntegerValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertUToPtr inst) => inst.ResultId;
    public OpConvertUToPtr(int resultType, int resultId, int integerValue)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        IntegerValue = integerValue;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToPtr, ResultType, ResultId, IntegerValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "integerValue":
                    IntegerValue = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConvertUToPtr(OpDataIndex odi) => new(odi);
    public static implicit operator OpConvertUToPtr(OpData data) => new(data);
}

public struct OpPtrCastToGeneric : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrCastToGeneric()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrCastToGeneric | (1 << 16);
    }

    public OpPtrCastToGeneric(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpPtrCastToGeneric(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpPtrCastToGeneric inst) => inst.ResultId;
    public OpPtrCastToGeneric(int resultType, int resultId, int pointer)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrCastToGeneric, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpPtrCastToGeneric(OpDataIndex odi) => new(odi);
    public static implicit operator OpPtrCastToGeneric(OpData data) => new(data);
}

public struct OpGenericCastToPtr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGenericCastToPtr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGenericCastToPtr | (1 << 16);
    }

    public OpGenericCastToPtr(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGenericCastToPtr(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGenericCastToPtr inst) => inst.ResultId;
    public OpGenericCastToPtr(int resultType, int resultId, int pointer)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGenericCastToPtr, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGenericCastToPtr(OpDataIndex odi) => new(odi);
    public static implicit operator OpGenericCastToPtr(OpData data) => new(data);
}

public struct OpGenericCastToPtrExplicit : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGenericCastToPtrExplicit()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGenericCastToPtrExplicit | (1 << 16);
    }

    public OpGenericCastToPtrExplicit(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGenericCastToPtrExplicit(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGenericCastToPtrExplicit inst) => inst.ResultId;
    public OpGenericCastToPtrExplicit(int resultType, int resultId, int pointer, StorageClass storage)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Storage = storage;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGenericCastToPtrExplicit, ResultType, ResultId, Pointer, (int)Storage];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "storage":
                    Storage = o.ToEnum<StorageClass>();
                    break;
            }
        }
    }

    public static implicit operator OpGenericCastToPtrExplicit(OpDataIndex odi) => new(odi);
    public static implicit operator OpGenericCastToPtrExplicit(OpData data) => new(data);
}

public struct OpBitcast : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitcast()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitcast | (1 << 16);
    }

    public OpBitcast(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpBitcast(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitcast inst) => inst.ResultId;
    public OpBitcast(int resultType, int resultId, int operand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitcast, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpBitcast(OpDataIndex odi) => new(odi);
    public static implicit operator OpBitcast(OpData data) => new(data);
}

public struct OpSNegate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSNegate()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSNegate | (1 << 16);
    }

    public OpSNegate(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSNegate(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSNegate inst) => inst.ResultId;
    public OpSNegate(int resultType, int resultId, int operand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSNegate, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSNegate(OpDataIndex odi) => new(odi);
    public static implicit operator OpSNegate(OpData data) => new(data);
}

public struct OpFNegate : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFNegate()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFNegate | (1 << 16);
    }

    public OpFNegate(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFNegate(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFNegate inst) => inst.ResultId;
    public OpFNegate(int resultType, int resultId, int operand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFNegate, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFNegate(OpDataIndex odi) => new(odi);
    public static implicit operator OpFNegate(OpData data) => new(data);
}

public struct OpIAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIAdd | (1 << 16);
    }

    public OpIAdd(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIAdd(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIAdd inst) => inst.ResultId;
    public OpIAdd(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIAdd, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpIAdd(OpDataIndex odi) => new(odi);
    public static implicit operator OpIAdd(OpData data) => new(data);
}

public struct OpFAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFAdd | (1 << 16);
    }

    public OpFAdd(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFAdd(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFAdd inst) => inst.ResultId;
    public OpFAdd(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFAdd, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFAdd(OpDataIndex odi) => new(odi);
    public static implicit operator OpFAdd(OpData data) => new(data);
}

public struct OpISub : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpISub()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpISub | (1 << 16);
    }

    public OpISub(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpISub(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpISub inst) => inst.ResultId;
    public OpISub(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpISub, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpISub(OpDataIndex odi) => new(odi);
    public static implicit operator OpISub(OpData data) => new(data);
}

public struct OpFSub : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFSub()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFSub | (1 << 16);
    }

    public OpFSub(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFSub(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFSub inst) => inst.ResultId;
    public OpFSub(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFSub, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFSub(OpDataIndex odi) => new(odi);
    public static implicit operator OpFSub(OpData data) => new(data);
}

public struct OpIMul : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIMul()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIMul | (1 << 16);
    }

    public OpIMul(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIMul(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIMul inst) => inst.ResultId;
    public OpIMul(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIMul, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpIMul(OpDataIndex odi) => new(odi);
    public static implicit operator OpIMul(OpData data) => new(data);
}

public struct OpFMul : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFMul()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFMul | (1 << 16);
    }

    public OpFMul(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFMul(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFMul inst) => inst.ResultId;
    public OpFMul(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFMul, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFMul(OpDataIndex odi) => new(odi);
    public static implicit operator OpFMul(OpData data) => new(data);
}

public struct OpUDiv : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUDiv()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUDiv | (1 << 16);
    }

    public OpUDiv(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUDiv(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUDiv inst) => inst.ResultId;
    public OpUDiv(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUDiv, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUDiv(OpDataIndex odi) => new(odi);
    public static implicit operator OpUDiv(OpData data) => new(data);
}

public struct OpSDiv : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDiv()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDiv | (1 << 16);
    }

    public OpSDiv(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDiv(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDiv inst) => inst.ResultId;
    public OpSDiv(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDiv, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSDiv(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDiv(OpData data) => new(data);
}

public struct OpFDiv : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFDiv()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFDiv | (1 << 16);
    }

    public OpFDiv(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFDiv(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFDiv inst) => inst.ResultId;
    public OpFDiv(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFDiv, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFDiv(OpDataIndex odi) => new(odi);
    public static implicit operator OpFDiv(OpData data) => new(data);
}

public struct OpUMod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUMod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUMod | (1 << 16);
    }

    public OpUMod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUMod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUMod inst) => inst.ResultId;
    public OpUMod(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUMod, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUMod(OpDataIndex odi) => new(odi);
    public static implicit operator OpUMod(OpData data) => new(data);
}

public struct OpSRem : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSRem()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSRem | (1 << 16);
    }

    public OpSRem(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSRem(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSRem inst) => inst.ResultId;
    public OpSRem(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSRem, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSRem(OpDataIndex odi) => new(odi);
    public static implicit operator OpSRem(OpData data) => new(data);
}

public struct OpSMod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSMod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSMod | (1 << 16);
    }

    public OpSMod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSMod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSMod inst) => inst.ResultId;
    public OpSMod(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSMod, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSMod(OpDataIndex odi) => new(odi);
    public static implicit operator OpSMod(OpData data) => new(data);
}

public struct OpFRem : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFRem()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFRem | (1 << 16);
    }

    public OpFRem(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFRem(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFRem inst) => inst.ResultId;
    public OpFRem(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFRem, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFRem(OpDataIndex odi) => new(odi);
    public static implicit operator OpFRem(OpData data) => new(data);
}

public struct OpFMod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFMod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFMod | (1 << 16);
    }

    public OpFMod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFMod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFMod inst) => inst.ResultId;
    public OpFMod(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFMod, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFMod(OpDataIndex odi) => new(odi);
    public static implicit operator OpFMod(OpData data) => new(data);
}

public struct OpVectorTimesScalar : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVectorTimesScalar()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVectorTimesScalar | (1 << 16);
    }

    public OpVectorTimesScalar(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpVectorTimesScalar(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Scalar
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVectorTimesScalar inst) => inst.ResultId;
    public OpVectorTimesScalar(int resultType, int resultId, int vector, int scalar)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        Scalar = scalar;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVectorTimesScalar, ResultType, ResultId, Vector, Scalar];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector":
                    Vector = o.ToLiteral<int>();
                    break;
                case "scalar":
                    Scalar = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpVectorTimesScalar(OpDataIndex odi) => new(odi);
    public static implicit operator OpVectorTimesScalar(OpData data) => new(data);
}

public struct OpMatrixTimesScalar : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMatrixTimesScalar()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMatrixTimesScalar | (1 << 16);
    }

    public OpMatrixTimesScalar(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpMatrixTimesScalar(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Scalar
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpMatrixTimesScalar inst) => inst.ResultId;
    public OpMatrixTimesScalar(int resultType, int resultId, int matrix, int scalar)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        Scalar = scalar;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMatrixTimesScalar, ResultType, ResultId, Matrix, Scalar];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "matrix":
                    Matrix = o.ToLiteral<int>();
                    break;
                case "scalar":
                    Scalar = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpMatrixTimesScalar(OpDataIndex odi) => new(odi);
    public static implicit operator OpMatrixTimesScalar(OpData data) => new(data);
}

public struct OpVectorTimesMatrix : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVectorTimesMatrix()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVectorTimesMatrix | (1 << 16);
    }

    public OpVectorTimesMatrix(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpVectorTimesMatrix(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVectorTimesMatrix inst) => inst.ResultId;
    public OpVectorTimesMatrix(int resultType, int resultId, int vector, int matrix)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
        Matrix = matrix;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVectorTimesMatrix, ResultType, ResultId, Vector, Matrix];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector":
                    Vector = o.ToLiteral<int>();
                    break;
                case "matrix":
                    Matrix = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpVectorTimesMatrix(OpDataIndex odi) => new(odi);
    public static implicit operator OpVectorTimesMatrix(OpData data) => new(data);
}

public struct OpMatrixTimesVector : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMatrixTimesVector()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMatrixTimesVector | (1 << 16);
    }

    public OpMatrixTimesVector(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpMatrixTimesVector(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpMatrixTimesVector inst) => inst.ResultId;
    public OpMatrixTimesVector(int resultType, int resultId, int matrix, int vector)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        Vector = vector;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMatrixTimesVector, ResultType, ResultId, Matrix, Vector];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "matrix":
                    Matrix = o.ToLiteral<int>();
                    break;
                case "vector":
                    Vector = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpMatrixTimesVector(OpDataIndex odi) => new(odi);
    public static implicit operator OpMatrixTimesVector(OpData data) => new(data);
}

public struct OpMatrixTimesMatrix : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMatrixTimesMatrix()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMatrixTimesMatrix | (1 << 16);
    }

    public OpMatrixTimesMatrix(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpMatrixTimesMatrix(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LeftMatrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RightMatrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpMatrixTimesMatrix inst) => inst.ResultId;
    public OpMatrixTimesMatrix(int resultType, int resultId, int leftMatrix, int rightMatrix)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        LeftMatrix = leftMatrix;
        RightMatrix = rightMatrix;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMatrixTimesMatrix, ResultType, ResultId, LeftMatrix, RightMatrix];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "leftMatrix":
                    LeftMatrix = o.ToLiteral<int>();
                    break;
                case "rightMatrix":
                    RightMatrix = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpMatrixTimesMatrix(OpDataIndex odi) => new(odi);
    public static implicit operator OpMatrixTimesMatrix(OpData data) => new(data);
}

public struct OpOuterProduct : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpOuterProduct()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpOuterProduct | (1 << 16);
    }

    public OpOuterProduct(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpOuterProduct(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpOuterProduct inst) => inst.ResultId;
    public OpOuterProduct(int resultType, int resultId, int vector1, int vector2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpOuterProduct, ResultType, ResultId, Vector1, Vector2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpOuterProduct(OpDataIndex odi) => new(odi);
    public static implicit operator OpOuterProduct(OpData data) => new(data);
}

public struct OpDot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDot | (1 << 16);
    }

    public OpDot(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpDot(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDot inst) => inst.ResultId;
    public OpDot(int resultType, int resultId, int vector1, int vector2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDot, ResultType, ResultId, Vector1, Vector2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpDot(OpDataIndex odi) => new(odi);
    public static implicit operator OpDot(OpData data) => new(data);
}

public struct OpIAddCarry : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIAddCarry()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIAddCarry | (1 << 16);
    }

    public OpIAddCarry(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIAddCarry(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIAddCarry inst) => inst.ResultId;
    public OpIAddCarry(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIAddCarry, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpIAddCarry(OpDataIndex odi) => new(odi);
    public static implicit operator OpIAddCarry(OpData data) => new(data);
}

public struct OpISubBorrow : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpISubBorrow()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpISubBorrow | (1 << 16);
    }

    public OpISubBorrow(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpISubBorrow(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpISubBorrow inst) => inst.ResultId;
    public OpISubBorrow(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpISubBorrow, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpISubBorrow(OpDataIndex odi) => new(odi);
    public static implicit operator OpISubBorrow(OpData data) => new(data);
}

public struct OpUMulExtended : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUMulExtended()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUMulExtended | (1 << 16);
    }

    public OpUMulExtended(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUMulExtended(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUMulExtended inst) => inst.ResultId;
    public OpUMulExtended(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUMulExtended, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUMulExtended(OpDataIndex odi) => new(odi);
    public static implicit operator OpUMulExtended(OpData data) => new(data);
}

public struct OpSMulExtended : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSMulExtended()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSMulExtended | (1 << 16);
    }

    public OpSMulExtended(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSMulExtended(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSMulExtended inst) => inst.ResultId;
    public OpSMulExtended(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSMulExtended, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSMulExtended(OpDataIndex odi) => new(odi);
    public static implicit operator OpSMulExtended(OpData data) => new(data);
}

public struct OpAny : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAny()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAny | (1 << 16);
    }

    public OpAny(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAny(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAny inst) => inst.ResultId;
    public OpAny(int resultType, int resultId, int vector)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAny, ResultType, ResultId, Vector];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector":
                    Vector = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAny(OpDataIndex odi) => new(odi);
    public static implicit operator OpAny(OpData data) => new(data);
}

public struct OpAll : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAll()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAll | (1 << 16);
    }

    public OpAll(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAll(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAll inst) => inst.ResultId;
    public OpAll(int resultType, int resultId, int vector)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Vector = vector;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAll, ResultType, ResultId, Vector];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector":
                    Vector = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAll(OpDataIndex odi) => new(odi);
    public static implicit operator OpAll(OpData data) => new(data);
}

public struct OpIsNan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsNan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsNan | (1 << 16);
    }

    public OpIsNan(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIsNan(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIsNan inst) => inst.ResultId;
    public OpIsNan(int resultType, int resultId, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsNan, ResultType, ResultId, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpIsNan(OpDataIndex odi) => new(odi);
    public static implicit operator OpIsNan(OpData data) => new(data);
}

public struct OpIsInf : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsInf()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsInf | (1 << 16);
    }

    public OpIsInf(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIsInf(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIsInf inst) => inst.ResultId;
    public OpIsInf(int resultType, int resultId, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsInf, ResultType, ResultId, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpIsInf(OpDataIndex odi) => new(odi);
    public static implicit operator OpIsInf(OpData data) => new(data);
}

public struct OpIsFinite : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsFinite()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsFinite | (1 << 16);
    }

    public OpIsFinite(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIsFinite(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIsFinite inst) => inst.ResultId;
    public OpIsFinite(int resultType, int resultId, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsFinite, ResultType, ResultId, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpIsFinite(OpDataIndex odi) => new(odi);
    public static implicit operator OpIsFinite(OpData data) => new(data);
}

public struct OpIsNormal : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsNormal()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsNormal | (1 << 16);
    }

    public OpIsNormal(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIsNormal(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIsNormal inst) => inst.ResultId;
    public OpIsNormal(int resultType, int resultId, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsNormal, ResultType, ResultId, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpIsNormal(OpDataIndex odi) => new(odi);
    public static implicit operator OpIsNormal(OpData data) => new(data);
}

public struct OpSignBitSet : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSignBitSet()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSignBitSet | (1 << 16);
    }

    public OpSignBitSet(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSignBitSet(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSignBitSet inst) => inst.ResultId;
    public OpSignBitSet(int resultType, int resultId, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSignBitSet, ResultType, ResultId, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSignBitSet(OpDataIndex odi) => new(odi);
    public static implicit operator OpSignBitSet(OpData data) => new(data);
}

public struct OpLessOrGreater : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLessOrGreater()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLessOrGreater | (1 << 16);
    }

    public OpLessOrGreater(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpLessOrGreater(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpLessOrGreater inst) => inst.ResultId;
    public OpLessOrGreater(int resultType, int resultId, int x, int y)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        Y = y;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLessOrGreater, ResultType, ResultId, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpLessOrGreater(OpDataIndex odi) => new(odi);
    public static implicit operator OpLessOrGreater(OpData data) => new(data);
}

public struct OpOrdered : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpOrdered()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpOrdered | (1 << 16);
    }

    public OpOrdered(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpOrdered(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpOrdered inst) => inst.ResultId;
    public OpOrdered(int resultType, int resultId, int x, int y)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        Y = y;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpOrdered, ResultType, ResultId, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpOrdered(OpDataIndex odi) => new(odi);
    public static implicit operator OpOrdered(OpData data) => new(data);
}

public struct OpUnordered : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUnordered()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUnordered | (1 << 16);
    }

    public OpUnordered(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUnordered(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUnordered inst) => inst.ResultId;
    public OpUnordered(int resultType, int resultId, int x, int y)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        X = x;
        Y = y;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUnordered, ResultType, ResultId, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUnordered(OpDataIndex odi) => new(odi);
    public static implicit operator OpUnordered(OpData data) => new(data);
}

public struct OpLogicalEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLogicalEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLogicalEqual | (1 << 16);
    }

    public OpLogicalEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpLogicalEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpLogicalEqual inst) => inst.ResultId;
    public OpLogicalEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLogicalEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpLogicalEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpLogicalEqual(OpData data) => new(data);
}

public struct OpLogicalNotEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLogicalNotEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLogicalNotEqual | (1 << 16);
    }

    public OpLogicalNotEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpLogicalNotEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpLogicalNotEqual inst) => inst.ResultId;
    public OpLogicalNotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLogicalNotEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpLogicalNotEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpLogicalNotEqual(OpData data) => new(data);
}

public struct OpLogicalOr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLogicalOr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLogicalOr | (1 << 16);
    }

    public OpLogicalOr(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpLogicalOr(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpLogicalOr inst) => inst.ResultId;
    public OpLogicalOr(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLogicalOr, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpLogicalOr(OpDataIndex odi) => new(odi);
    public static implicit operator OpLogicalOr(OpData data) => new(data);
}

public struct OpLogicalAnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLogicalAnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLogicalAnd | (1 << 16);
    }

    public OpLogicalAnd(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpLogicalAnd(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpLogicalAnd inst) => inst.ResultId;
    public OpLogicalAnd(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLogicalAnd, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpLogicalAnd(OpDataIndex odi) => new(odi);
    public static implicit operator OpLogicalAnd(OpData data) => new(data);
}

public struct OpLogicalNot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLogicalNot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLogicalNot | (1 << 16);
    }

    public OpLogicalNot(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpLogicalNot(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpLogicalNot inst) => inst.ResultId;
    public OpLogicalNot(int resultType, int resultId, int operand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLogicalNot, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpLogicalNot(OpDataIndex odi) => new(odi);
    public static implicit operator OpLogicalNot(OpData data) => new(data);
}

public struct OpSelect : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSelect()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSelect | (1 << 16);
    }

    public OpSelect(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSelect(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Condition
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Object1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Object2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSelect inst) => inst.ResultId;
    public OpSelect(int resultType, int resultId, int condition, int object1, int object2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Condition = condition;
        Object1 = object1;
        Object2 = object2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSelect, ResultType, ResultId, Condition, Object1, Object2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "condition":
                    Condition = o.ToLiteral<int>();
                    break;
                case "object1":
                    Object1 = o.ToLiteral<int>();
                    break;
                case "object2":
                    Object2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSelect(OpDataIndex odi) => new(odi);
    public static implicit operator OpSelect(OpData data) => new(data);
}

public struct OpIEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIEqual | (1 << 16);
    }

    public OpIEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIEqual inst) => inst.ResultId;
    public OpIEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpIEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpIEqual(OpData data) => new(data);
}

public struct OpINotEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpINotEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpINotEqual | (1 << 16);
    }

    public OpINotEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpINotEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpINotEqual inst) => inst.ResultId;
    public OpINotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpINotEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpINotEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpINotEqual(OpData data) => new(data);
}

public struct OpUGreaterThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUGreaterThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUGreaterThan | (1 << 16);
    }

    public OpUGreaterThan(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUGreaterThan(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUGreaterThan inst) => inst.ResultId;
    public OpUGreaterThan(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUGreaterThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUGreaterThan(OpDataIndex odi) => new(odi);
    public static implicit operator OpUGreaterThan(OpData data) => new(data);
}

public struct OpSGreaterThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSGreaterThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSGreaterThan | (1 << 16);
    }

    public OpSGreaterThan(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSGreaterThan(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSGreaterThan inst) => inst.ResultId;
    public OpSGreaterThan(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSGreaterThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSGreaterThan(OpDataIndex odi) => new(odi);
    public static implicit operator OpSGreaterThan(OpData data) => new(data);
}

public struct OpUGreaterThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUGreaterThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUGreaterThanEqual | (1 << 16);
    }

    public OpUGreaterThanEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUGreaterThanEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUGreaterThanEqual inst) => inst.ResultId;
    public OpUGreaterThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUGreaterThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUGreaterThanEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpUGreaterThanEqual(OpData data) => new(data);
}

public struct OpSGreaterThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSGreaterThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSGreaterThanEqual | (1 << 16);
    }

    public OpSGreaterThanEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSGreaterThanEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSGreaterThanEqual inst) => inst.ResultId;
    public OpSGreaterThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSGreaterThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSGreaterThanEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpSGreaterThanEqual(OpData data) => new(data);
}

public struct OpULessThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpULessThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpULessThan | (1 << 16);
    }

    public OpULessThan(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpULessThan(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpULessThan inst) => inst.ResultId;
    public OpULessThan(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpULessThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpULessThan(OpDataIndex odi) => new(odi);
    public static implicit operator OpULessThan(OpData data) => new(data);
}

public struct OpSLessThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSLessThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSLessThan | (1 << 16);
    }

    public OpSLessThan(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSLessThan(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSLessThan inst) => inst.ResultId;
    public OpSLessThan(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSLessThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSLessThan(OpDataIndex odi) => new(odi);
    public static implicit operator OpSLessThan(OpData data) => new(data);
}

public struct OpULessThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpULessThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpULessThanEqual | (1 << 16);
    }

    public OpULessThanEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpULessThanEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpULessThanEqual inst) => inst.ResultId;
    public OpULessThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpULessThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpULessThanEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpULessThanEqual(OpData data) => new(data);
}

public struct OpSLessThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSLessThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSLessThanEqual | (1 << 16);
    }

    public OpSLessThanEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSLessThanEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSLessThanEqual inst) => inst.ResultId;
    public OpSLessThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSLessThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSLessThanEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpSLessThanEqual(OpData data) => new(data);
}

public struct OpFOrdEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdEqual | (1 << 16);
    }

    public OpFOrdEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFOrdEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFOrdEqual inst) => inst.ResultId;
    public OpFOrdEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFOrdEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpFOrdEqual(OpData data) => new(data);
}

public struct OpFUnordEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordEqual | (1 << 16);
    }

    public OpFUnordEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFUnordEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFUnordEqual inst) => inst.ResultId;
    public OpFUnordEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFUnordEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpFUnordEqual(OpData data) => new(data);
}

public struct OpFOrdNotEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdNotEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdNotEqual | (1 << 16);
    }

    public OpFOrdNotEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFOrdNotEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFOrdNotEqual inst) => inst.ResultId;
    public OpFOrdNotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdNotEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFOrdNotEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpFOrdNotEqual(OpData data) => new(data);
}

public struct OpFUnordNotEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordNotEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordNotEqual | (1 << 16);
    }

    public OpFUnordNotEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFUnordNotEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFUnordNotEqual inst) => inst.ResultId;
    public OpFUnordNotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordNotEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFUnordNotEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpFUnordNotEqual(OpData data) => new(data);
}

public struct OpFOrdLessThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdLessThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdLessThan | (1 << 16);
    }

    public OpFOrdLessThan(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFOrdLessThan(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFOrdLessThan inst) => inst.ResultId;
    public OpFOrdLessThan(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdLessThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFOrdLessThan(OpDataIndex odi) => new(odi);
    public static implicit operator OpFOrdLessThan(OpData data) => new(data);
}

public struct OpFUnordLessThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordLessThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordLessThan | (1 << 16);
    }

    public OpFUnordLessThan(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFUnordLessThan(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFUnordLessThan inst) => inst.ResultId;
    public OpFUnordLessThan(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordLessThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFUnordLessThan(OpDataIndex odi) => new(odi);
    public static implicit operator OpFUnordLessThan(OpData data) => new(data);
}

public struct OpFOrdGreaterThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdGreaterThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdGreaterThan | (1 << 16);
    }

    public OpFOrdGreaterThan(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFOrdGreaterThan(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFOrdGreaterThan inst) => inst.ResultId;
    public OpFOrdGreaterThan(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdGreaterThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFOrdGreaterThan(OpDataIndex odi) => new(odi);
    public static implicit operator OpFOrdGreaterThan(OpData data) => new(data);
}

public struct OpFUnordGreaterThan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordGreaterThan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordGreaterThan | (1 << 16);
    }

    public OpFUnordGreaterThan(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFUnordGreaterThan(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFUnordGreaterThan inst) => inst.ResultId;
    public OpFUnordGreaterThan(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordGreaterThan, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFUnordGreaterThan(OpDataIndex odi) => new(odi);
    public static implicit operator OpFUnordGreaterThan(OpData data) => new(data);
}

public struct OpFOrdLessThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdLessThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdLessThanEqual | (1 << 16);
    }

    public OpFOrdLessThanEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFOrdLessThanEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFOrdLessThanEqual inst) => inst.ResultId;
    public OpFOrdLessThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdLessThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFOrdLessThanEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpFOrdLessThanEqual(OpData data) => new(data);
}

public struct OpFUnordLessThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordLessThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordLessThanEqual | (1 << 16);
    }

    public OpFUnordLessThanEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFUnordLessThanEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFUnordLessThanEqual inst) => inst.ResultId;
    public OpFUnordLessThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordLessThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFUnordLessThanEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpFUnordLessThanEqual(OpData data) => new(data);
}

public struct OpFOrdGreaterThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFOrdGreaterThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFOrdGreaterThanEqual | (1 << 16);
    }

    public OpFOrdGreaterThanEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFOrdGreaterThanEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFOrdGreaterThanEqual inst) => inst.ResultId;
    public OpFOrdGreaterThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFOrdGreaterThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFOrdGreaterThanEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpFOrdGreaterThanEqual(OpData data) => new(data);
}

public struct OpFUnordGreaterThanEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFUnordGreaterThanEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFUnordGreaterThanEqual | (1 << 16);
    }

    public OpFUnordGreaterThanEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFUnordGreaterThanEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFUnordGreaterThanEqual inst) => inst.ResultId;
    public OpFUnordGreaterThanEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFUnordGreaterThanEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFUnordGreaterThanEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpFUnordGreaterThanEqual(OpData data) => new(data);
}

public struct OpShiftRightLogical : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpShiftRightLogical()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpShiftRightLogical | (1 << 16);
    }

    public OpShiftRightLogical(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpShiftRightLogical(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shift
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpShiftRightLogical inst) => inst.ResultId;
    public OpShiftRightLogical(int resultType, int resultId, int baseId, int shift)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Shift = shift;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpShiftRightLogical, ResultType, ResultId, BaseId, Shift];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "shift":
                    Shift = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpShiftRightLogical(OpDataIndex odi) => new(odi);
    public static implicit operator OpShiftRightLogical(OpData data) => new(data);
}

public struct OpShiftRightArithmetic : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpShiftRightArithmetic()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpShiftRightArithmetic | (1 << 16);
    }

    public OpShiftRightArithmetic(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpShiftRightArithmetic(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shift
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpShiftRightArithmetic inst) => inst.ResultId;
    public OpShiftRightArithmetic(int resultType, int resultId, int baseId, int shift)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Shift = shift;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpShiftRightArithmetic, ResultType, ResultId, BaseId, Shift];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "shift":
                    Shift = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpShiftRightArithmetic(OpDataIndex odi) => new(odi);
    public static implicit operator OpShiftRightArithmetic(OpData data) => new(data);
}

public struct OpShiftLeftLogical : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpShiftLeftLogical()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpShiftLeftLogical | (1 << 16);
    }

    public OpShiftLeftLogical(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpShiftLeftLogical(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Shift
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpShiftLeftLogical inst) => inst.ResultId;
    public OpShiftLeftLogical(int resultType, int resultId, int baseId, int shift)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Shift = shift;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpShiftLeftLogical, ResultType, ResultId, BaseId, Shift];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "shift":
                    Shift = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpShiftLeftLogical(OpDataIndex odi) => new(odi);
    public static implicit operator OpShiftLeftLogical(OpData data) => new(data);
}

public struct OpBitwiseOr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitwiseOr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitwiseOr | (1 << 16);
    }

    public OpBitwiseOr(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpBitwiseOr(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitwiseOr inst) => inst.ResultId;
    public OpBitwiseOr(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitwiseOr, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpBitwiseOr(OpDataIndex odi) => new(odi);
    public static implicit operator OpBitwiseOr(OpData data) => new(data);
}

public struct OpBitwiseXor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitwiseXor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitwiseXor | (1 << 16);
    }

    public OpBitwiseXor(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpBitwiseXor(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitwiseXor inst) => inst.ResultId;
    public OpBitwiseXor(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitwiseXor, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpBitwiseXor(OpDataIndex odi) => new(odi);
    public static implicit operator OpBitwiseXor(OpData data) => new(data);
}

public struct OpBitwiseAnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitwiseAnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitwiseAnd | (1 << 16);
    }

    public OpBitwiseAnd(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpBitwiseAnd(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitwiseAnd inst) => inst.ResultId;
    public OpBitwiseAnd(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitwiseAnd, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpBitwiseAnd(OpDataIndex odi) => new(odi);
    public static implicit operator OpBitwiseAnd(OpData data) => new(data);
}

public struct OpNot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpNot | (1 << 16);
    }

    public OpNot(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpNot(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpNot inst) => inst.ResultId;
    public OpNot(int resultType, int resultId, int operand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpNot, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpNot(OpDataIndex odi) => new(odi);
    public static implicit operator OpNot(OpData data) => new(data);
}

public struct OpBitFieldInsert : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitFieldInsert()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitFieldInsert | (1 << 16);
    }

    public OpBitFieldInsert(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpBitFieldInsert(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Insert
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Offset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Count
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitFieldInsert inst) => inst.ResultId;
    public OpBitFieldInsert(int resultType, int resultId, int baseId, int insert, int offset, int count)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Insert = insert;
        Offset = offset;
        Count = count;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitFieldInsert, ResultType, ResultId, BaseId, Insert, Offset, Count];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "insert":
                    Insert = o.ToLiteral<int>();
                    break;
                case "offset":
                    Offset = o.ToLiteral<int>();
                    break;
                case "count":
                    Count = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpBitFieldInsert(OpDataIndex odi) => new(odi);
    public static implicit operator OpBitFieldInsert(OpData data) => new(data);
}

public struct OpBitFieldSExtract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitFieldSExtract()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitFieldSExtract | (1 << 16);
    }

    public OpBitFieldSExtract(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpBitFieldSExtract(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Offset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Count
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitFieldSExtract inst) => inst.ResultId;
    public OpBitFieldSExtract(int resultType, int resultId, int baseId, int offset, int count)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Offset = offset;
        Count = count;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitFieldSExtract, ResultType, ResultId, BaseId, Offset, Count];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "offset":
                    Offset = o.ToLiteral<int>();
                    break;
                case "count":
                    Count = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpBitFieldSExtract(OpDataIndex odi) => new(odi);
    public static implicit operator OpBitFieldSExtract(OpData data) => new(data);
}

public struct OpBitFieldUExtract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitFieldUExtract()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitFieldUExtract | (1 << 16);
    }

    public OpBitFieldUExtract(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpBitFieldUExtract(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Offset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Count
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitFieldUExtract inst) => inst.ResultId;
    public OpBitFieldUExtract(int resultType, int resultId, int baseId, int offset, int count)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Offset = offset;
        Count = count;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitFieldUExtract, ResultType, ResultId, BaseId, Offset, Count];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "offset":
                    Offset = o.ToLiteral<int>();
                    break;
                case "count":
                    Count = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpBitFieldUExtract(OpDataIndex odi) => new(odi);
    public static implicit operator OpBitFieldUExtract(OpData data) => new(data);
}

public struct OpBitReverse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitReverse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitReverse | (1 << 16);
    }

    public OpBitReverse(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpBitReverse(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitReverse inst) => inst.ResultId;
    public OpBitReverse(int resultType, int resultId, int baseId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitReverse, ResultType, ResultId, BaseId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpBitReverse(OpDataIndex odi) => new(odi);
    public static implicit operator OpBitReverse(OpData data) => new(data);
}

public struct OpBitCount : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBitCount()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBitCount | (1 << 16);
    }

    public OpBitCount(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpBitCount(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBitCount inst) => inst.ResultId;
    public OpBitCount(int resultType, int resultId, int baseId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBitCount, ResultType, ResultId, BaseId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpBitCount(OpDataIndex odi) => new(odi);
    public static implicit operator OpBitCount(OpData data) => new(data);
}

public struct OpDPdx : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdx()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdx | (1 << 16);
    }

    public OpDPdx(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpDPdx(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDPdx inst) => inst.ResultId;
    public OpDPdx(int resultType, int resultId, int p)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        P = p;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdx, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpDPdx(OpDataIndex odi) => new(odi);
    public static implicit operator OpDPdx(OpData data) => new(data);
}

public struct OpDPdy : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdy()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdy | (1 << 16);
    }

    public OpDPdy(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpDPdy(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDPdy inst) => inst.ResultId;
    public OpDPdy(int resultType, int resultId, int p)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        P = p;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdy, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpDPdy(OpDataIndex odi) => new(odi);
    public static implicit operator OpDPdy(OpData data) => new(data);
}

public struct OpFwidth : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFwidth()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFwidth | (1 << 16);
    }

    public OpFwidth(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFwidth(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFwidth inst) => inst.ResultId;
    public OpFwidth(int resultType, int resultId, int p)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        P = p;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFwidth, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFwidth(OpDataIndex odi) => new(odi);
    public static implicit operator OpFwidth(OpData data) => new(data);
}

public struct OpDPdxFine : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdxFine()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdxFine | (1 << 16);
    }

    public OpDPdxFine(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpDPdxFine(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDPdxFine inst) => inst.ResultId;
    public OpDPdxFine(int resultType, int resultId, int p)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        P = p;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdxFine, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpDPdxFine(OpDataIndex odi) => new(odi);
    public static implicit operator OpDPdxFine(OpData data) => new(data);
}

public struct OpDPdyFine : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdyFine()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdyFine | (1 << 16);
    }

    public OpDPdyFine(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpDPdyFine(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDPdyFine inst) => inst.ResultId;
    public OpDPdyFine(int resultType, int resultId, int p)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        P = p;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdyFine, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpDPdyFine(OpDataIndex odi) => new(odi);
    public static implicit operator OpDPdyFine(OpData data) => new(data);
}

public struct OpFwidthFine : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFwidthFine()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFwidthFine | (1 << 16);
    }

    public OpFwidthFine(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFwidthFine(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFwidthFine inst) => inst.ResultId;
    public OpFwidthFine(int resultType, int resultId, int p)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        P = p;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFwidthFine, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFwidthFine(OpDataIndex odi) => new(odi);
    public static implicit operator OpFwidthFine(OpData data) => new(data);
}

public struct OpDPdxCoarse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdxCoarse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdxCoarse | (1 << 16);
    }

    public OpDPdxCoarse(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpDPdxCoarse(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDPdxCoarse inst) => inst.ResultId;
    public OpDPdxCoarse(int resultType, int resultId, int p)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        P = p;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdxCoarse, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpDPdxCoarse(OpDataIndex odi) => new(odi);
    public static implicit operator OpDPdxCoarse(OpData data) => new(data);
}

public struct OpDPdyCoarse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDPdyCoarse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDPdyCoarse | (1 << 16);
    }

    public OpDPdyCoarse(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpDPdyCoarse(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDPdyCoarse inst) => inst.ResultId;
    public OpDPdyCoarse(int resultType, int resultId, int p)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        P = p;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDPdyCoarse, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpDPdyCoarse(OpDataIndex odi) => new(odi);
    public static implicit operator OpDPdyCoarse(OpData data) => new(data);
}

public struct OpFwidthCoarse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFwidthCoarse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFwidthCoarse | (1 << 16);
    }

    public OpFwidthCoarse(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFwidthCoarse(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFwidthCoarse inst) => inst.ResultId;
    public OpFwidthCoarse(int resultType, int resultId, int p)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        P = p;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFwidthCoarse, ResultType, ResultId, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFwidthCoarse(OpDataIndex odi) => new(odi);
    public static implicit operator OpFwidthCoarse(OpData data) => new(data);
}

public struct OpEmitVertex : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEmitVertex()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEmitVertex | (1 << 16);
    }

    public OpEmitVertex(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpEmitVertex(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEmitVertex, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpEmitVertex(OpDataIndex odi) => new(odi);
    public static implicit operator OpEmitVertex(OpData data) => new(data);
}

public struct OpEndPrimitive : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEndPrimitive()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEndPrimitive | (1 << 16);
    }

    public OpEndPrimitive(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpEndPrimitive(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEndPrimitive, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpEndPrimitive(OpDataIndex odi) => new(odi);
    public static implicit operator OpEndPrimitive(OpData data) => new(data);
}

public struct OpEmitStreamVertex : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEmitStreamVertex()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEmitStreamVertex | (1 << 16);
    }

    public OpEmitStreamVertex(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpEmitStreamVertex(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Stream
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEmitStreamVertex(int stream)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Stream = stream;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEmitStreamVertex, Stream];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "stream":
                    Stream = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpEmitStreamVertex(OpDataIndex odi) => new(odi);
    public static implicit operator OpEmitStreamVertex(OpData data) => new(data);
}

public struct OpEndStreamPrimitive : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEndStreamPrimitive()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEndStreamPrimitive | (1 << 16);
    }

    public OpEndStreamPrimitive(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpEndStreamPrimitive(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Stream
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEndStreamPrimitive(int stream)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Stream = stream;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEndStreamPrimitive, Stream];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "stream":
                    Stream = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpEndStreamPrimitive(OpDataIndex odi) => new(odi);
    public static implicit operator OpEndStreamPrimitive(OpData data) => new(data);
}

public struct OpControlBarrier : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpControlBarrier()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpControlBarrier | (1 << 16);
    }

    public OpControlBarrier(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpControlBarrier(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpControlBarrier(int execution, int memory, int semantics)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Execution = execution;
        Memory = memory;
        Semantics = semantics;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpControlBarrier, Execution, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpControlBarrier(OpDataIndex odi) => new(odi);
    public static implicit operator OpControlBarrier(OpData data) => new(data);
}

public struct OpMemoryBarrier : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemoryBarrier()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemoryBarrier | (1 << 16);
    }

    public OpMemoryBarrier(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpMemoryBarrier(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemoryBarrier(int memory, int semantics)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Memory = memory;
        Semantics = semantics;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemoryBarrier, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpMemoryBarrier(OpDataIndex odi) => new(odi);
    public static implicit operator OpMemoryBarrier(OpData data) => new(data);
}

public struct OpAtomicLoad : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicLoad()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicLoad | (1 << 16);
    }

    public OpAtomicLoad(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicLoad(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicLoad inst) => inst.ResultId;
    public OpAtomicLoad(int resultType, int resultId, int pointer, int memory, int semantics)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicLoad, ResultType, ResultId, Pointer, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicLoad(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicLoad(OpData data) => new(data);
}

public struct OpAtomicStore : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicStore()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicStore | (1 << 16);
    }

    public OpAtomicStore(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicStore(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicStore(int pointer, int memory, int semantics, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicStore, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicStore(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicStore(OpData data) => new(data);
}

public struct OpAtomicExchange : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicExchange()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicExchange | (1 << 16);
    }

    public OpAtomicExchange(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicExchange(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicExchange inst) => inst.ResultId;
    public OpAtomicExchange(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicExchange, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicExchange(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicExchange(OpData data) => new(data);
}

public struct OpAtomicCompareExchange : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicCompareExchange()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicCompareExchange | (1 << 16);
    }

    public OpAtomicCompareExchange(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicCompareExchange(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Equal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Unequal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Comparator
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicCompareExchange inst) => inst.ResultId;
    public OpAtomicCompareExchange(int resultType, int resultId, int pointer, int memory, int equal, int unequal, int value, int comparator)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Equal = equal;
        Unequal = unequal;
        Value = value;
        Comparator = comparator;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicCompareExchange, ResultType, ResultId, Pointer, Memory, Equal, Unequal, Value, Comparator];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "equal":
                    Equal = o.ToLiteral<int>();
                    break;
                case "unequal":
                    Unequal = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "comparator":
                    Comparator = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicCompareExchange(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicCompareExchange(OpData data) => new(data);
}

public struct OpAtomicCompareExchangeWeak : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicCompareExchangeWeak()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicCompareExchangeWeak | (1 << 16);
    }

    public OpAtomicCompareExchangeWeak(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicCompareExchangeWeak(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Equal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Unequal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Comparator
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicCompareExchangeWeak inst) => inst.ResultId;
    public OpAtomicCompareExchangeWeak(int resultType, int resultId, int pointer, int memory, int equal, int unequal, int value, int comparator)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Equal = equal;
        Unequal = unequal;
        Value = value;
        Comparator = comparator;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicCompareExchangeWeak, ResultType, ResultId, Pointer, Memory, Equal, Unequal, Value, Comparator];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "equal":
                    Equal = o.ToLiteral<int>();
                    break;
                case "unequal":
                    Unequal = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "comparator":
                    Comparator = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicCompareExchangeWeak(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicCompareExchangeWeak(OpData data) => new(data);
}

public struct OpAtomicIIncrement : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicIIncrement()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicIIncrement | (1 << 16);
    }

    public OpAtomicIIncrement(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicIIncrement(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicIIncrement inst) => inst.ResultId;
    public OpAtomicIIncrement(int resultType, int resultId, int pointer, int memory, int semantics)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicIIncrement, ResultType, ResultId, Pointer, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicIIncrement(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicIIncrement(OpData data) => new(data);
}

public struct OpAtomicIDecrement : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicIDecrement()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicIDecrement | (1 << 16);
    }

    public OpAtomicIDecrement(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicIDecrement(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicIDecrement inst) => inst.ResultId;
    public OpAtomicIDecrement(int resultType, int resultId, int pointer, int memory, int semantics)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicIDecrement, ResultType, ResultId, Pointer, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicIDecrement(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicIDecrement(OpData data) => new(data);
}

public struct OpAtomicIAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicIAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicIAdd | (1 << 16);
    }

    public OpAtomicIAdd(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicIAdd(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicIAdd inst) => inst.ResultId;
    public OpAtomicIAdd(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicIAdd, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicIAdd(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicIAdd(OpData data) => new(data);
}

public struct OpAtomicISub : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicISub()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicISub | (1 << 16);
    }

    public OpAtomicISub(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicISub(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicISub inst) => inst.ResultId;
    public OpAtomicISub(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicISub, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicISub(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicISub(OpData data) => new(data);
}

public struct OpAtomicSMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicSMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicSMin | (1 << 16);
    }

    public OpAtomicSMin(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicSMin(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicSMin inst) => inst.ResultId;
    public OpAtomicSMin(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicSMin, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicSMin(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicSMin(OpData data) => new(data);
}

public struct OpAtomicUMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicUMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicUMin | (1 << 16);
    }

    public OpAtomicUMin(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicUMin(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicUMin inst) => inst.ResultId;
    public OpAtomicUMin(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicUMin, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicUMin(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicUMin(OpData data) => new(data);
}

public struct OpAtomicSMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicSMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicSMax | (1 << 16);
    }

    public OpAtomicSMax(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicSMax(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicSMax inst) => inst.ResultId;
    public OpAtomicSMax(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicSMax, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicSMax(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicSMax(OpData data) => new(data);
}

public struct OpAtomicUMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicUMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicUMax | (1 << 16);
    }

    public OpAtomicUMax(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicUMax(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicUMax inst) => inst.ResultId;
    public OpAtomicUMax(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicUMax, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicUMax(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicUMax(OpData data) => new(data);
}

public struct OpAtomicAnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicAnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicAnd | (1 << 16);
    }

    public OpAtomicAnd(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicAnd(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicAnd inst) => inst.ResultId;
    public OpAtomicAnd(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicAnd, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicAnd(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicAnd(OpData data) => new(data);
}

public struct OpAtomicOr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicOr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicOr | (1 << 16);
    }

    public OpAtomicOr(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicOr(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicOr inst) => inst.ResultId;
    public OpAtomicOr(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicOr, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicOr(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicOr(OpData data) => new(data);
}

public struct OpAtomicXor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicXor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicXor | (1 << 16);
    }

    public OpAtomicXor(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicXor(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicXor inst) => inst.ResultId;
    public OpAtomicXor(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicXor, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicXor(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicXor(OpData data) => new(data);
}

public struct OpPhi : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPhi()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPhi | (1 << 16);
    }

    public OpPhi(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpPhi(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<(int, int)> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpPhi inst) => inst.ResultId;
    public OpPhi(int resultType, int resultId, LiteralArray<(int, int)> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPhi, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<(int, int)>();
                    break;
            }
        }
    }

    public static implicit operator OpPhi(OpDataIndex odi) => new(odi);
    public static implicit operator OpPhi(OpData data) => new(data);
}

public struct OpLoopMerge : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLoopMerge()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLoopMerge | (1 << 16);
    }

    public OpLoopMerge(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpLoopMerge(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int MergeBlock
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ContinueTarget
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<LoopControlMask> Loopcontrol
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLoopMerge(int mergeBlock, int continueTarget, ParameterizedFlag<LoopControlMask> loopcontrol)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        MergeBlock = mergeBlock;
        ContinueTarget = continueTarget;
        Loopcontrol = loopcontrol;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLoopMerge, MergeBlock, ContinueTarget, ..(Span<int>)[(int)Loopcontrol.Value, ..Loopcontrol.Span]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "mergeBlock":
                    MergeBlock = o.ToLiteral<int>();
                    break;
                case "continueTarget":
                    ContinueTarget = o.ToLiteral<int>();
                    break;
                case "loopcontrol":
                    Loopcontrol = o.ToEnum<LoopControlMask>();
                    break;
            }
        }
    }

    public static implicit operator OpLoopMerge(OpDataIndex odi) => new(odi);
    public static implicit operator OpLoopMerge(OpData data) => new(data);
}

public struct OpSelectionMerge : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSelectionMerge()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSelectionMerge | (1 << 16);
    }

    public OpSelectionMerge(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSelectionMerge(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int MergeBlock
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public SelectionControlMask Selectioncontrol
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSelectionMerge(int mergeBlock, SelectionControlMask selectioncontrol)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        MergeBlock = mergeBlock;
        Selectioncontrol = selectioncontrol;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSelectionMerge, MergeBlock, (int)Selectioncontrol];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "mergeBlock":
                    MergeBlock = o.ToLiteral<int>();
                    break;
                case "selectioncontrol":
                    Selectioncontrol = o.ToEnum<SelectionControlMask>();
                    break;
            }
        }
    }

    public static implicit operator OpSelectionMerge(OpDataIndex odi) => new(odi);
    public static implicit operator OpSelectionMerge(OpData data) => new(data);
}

public struct OpLabel : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLabel()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLabel | (1 << 16);
    }

    public OpLabel(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpLabel(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpLabel inst) => inst.ResultId;
    public OpLabel(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLabel, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpLabel(OpDataIndex odi) => new(odi);
    public static implicit operator OpLabel(OpData data) => new(data);
}

public struct OpBranch : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBranch()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBranch | (1 << 16);
    }

    public OpBranch(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpBranch(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int TargetLabel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpBranch(int targetLabel)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        TargetLabel = targetLabel;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBranch, TargetLabel];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "targetLabel":
                    TargetLabel = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpBranch(OpDataIndex odi) => new(odi);
    public static implicit operator OpBranch(OpData data) => new(data);
}

public struct OpBranchConditional : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBranchConditional()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBranchConditional | (1 << 16);
    }

    public OpBranchConditional(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpBranchConditional(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Condition
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TrueLabel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FalseLabel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpBranchConditional(int condition, int trueLabel, int falseLabel, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Condition = condition;
        TrueLabel = trueLabel;
        FalseLabel = falseLabel;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBranchConditional, Condition, TrueLabel, FalseLabel, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "condition":
                    Condition = o.ToLiteral<int>();
                    break;
                case "trueLabel":
                    TrueLabel = o.ToLiteral<int>();
                    break;
                case "falseLabel":
                    FalseLabel = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpBranchConditional(OpDataIndex odi) => new(odi);
    public static implicit operator OpBranchConditional(OpData data) => new(data);
}

public struct OpSwitch : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSwitch()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSwitch | (1 << 16);
    }

    public OpSwitch(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSwitch(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Selector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int DefaultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<(int, int)> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSwitch(int selector, int defaultId, LiteralArray<(int, int)> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Selector = selector;
        DefaultId = defaultId;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSwitch, Selector, DefaultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "selector":
                    Selector = o.ToLiteral<int>();
                    break;
                case "defaultId":
                    DefaultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<(int, int)>();
                    break;
            }
        }
    }

    public static implicit operator OpSwitch(OpDataIndex odi) => new(odi);
    public static implicit operator OpSwitch(OpData data) => new(data);
}

public struct OpKill : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpKill()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpKill | (1 << 16);
    }

    public OpKill(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpKill(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpKill, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpKill(OpDataIndex odi) => new(odi);
    public static implicit operator OpKill(OpData data) => new(data);
}

public struct OpReturn : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReturn()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReturn | (1 << 16);
    }

    public OpReturn(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpReturn(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReturn, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpReturn(OpDataIndex odi) => new(odi);
    public static implicit operator OpReturn(OpData data) => new(data);
}

public struct OpReturnValue : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReturnValue()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReturnValue | (1 << 16);
    }

    public OpReturnValue(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpReturnValue(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReturnValue(int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReturnValue, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpReturnValue(OpDataIndex odi) => new(odi);
    public static implicit operator OpReturnValue(OpData data) => new(data);
}

public struct OpUnreachable : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUnreachable()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUnreachable | (1 << 16);
    }

    public OpUnreachable(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUnreachable(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUnreachable, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpUnreachable(OpDataIndex odi) => new(odi);
    public static implicit operator OpUnreachable(OpData data) => new(data);
}

public struct OpLifetimeStart : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLifetimeStart()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLifetimeStart | (1 << 16);
    }

    public OpLifetimeStart(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpLifetimeStart(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Size
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLifetimeStart(int pointer, int size)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Pointer = pointer;
        Size = size;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLifetimeStart, Pointer, ..Size.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "size":
                    Size = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpLifetimeStart(OpDataIndex odi) => new(odi);
    public static implicit operator OpLifetimeStart(OpData data) => new(data);
}

public struct OpLifetimeStop : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLifetimeStop()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLifetimeStop | (1 << 16);
    }

    public OpLifetimeStop(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpLifetimeStop(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Size
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLifetimeStop(int pointer, int size)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Pointer = pointer;
        Size = size;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLifetimeStop, Pointer, ..Size.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "size":
                    Size = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpLifetimeStop(OpDataIndex odi) => new(odi);
    public static implicit operator OpLifetimeStop(OpData data) => new(data);
}

public struct OpGroupAsyncCopy : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupAsyncCopy()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupAsyncCopy | (1 << 16);
    }

    public OpGroupAsyncCopy(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupAsyncCopy(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Destination
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Source
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumElements
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Stride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupAsyncCopy inst) => inst.ResultId;
    public OpGroupAsyncCopy(int resultType, int resultId, int execution, int destination, int source, int numElements, int stride, int eventId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Destination = destination;
        Source = source;
        NumElements = numElements;
        Stride = stride;
        EventId = eventId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupAsyncCopy, ResultType, ResultId, Execution, Destination, Source, NumElements, Stride, EventId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "destination":
                    Destination = o.ToLiteral<int>();
                    break;
                case "source":
                    Source = o.ToLiteral<int>();
                    break;
                case "numElements":
                    NumElements = o.ToLiteral<int>();
                    break;
                case "stride":
                    Stride = o.ToLiteral<int>();
                    break;
                case "eventId":
                    EventId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupAsyncCopy(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupAsyncCopy(OpData data) => new(data);
}

public struct OpGroupWaitEvents : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupWaitEvents()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupWaitEvents | (1 << 16);
    }

    public OpGroupWaitEvents(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupWaitEvents(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumEvents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EventsList
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupWaitEvents(int execution, int numEvents, int eventsList)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Execution = execution;
        NumEvents = numEvents;
        EventsList = eventsList;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupWaitEvents, Execution, NumEvents, EventsList];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "numEvents":
                    NumEvents = o.ToLiteral<int>();
                    break;
                case "eventsList":
                    EventsList = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupWaitEvents(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupWaitEvents(OpData data) => new(data);
}

public struct OpGroupAll : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupAll()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupAll | (1 << 16);
    }

    public OpGroupAll(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupAll(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupAll inst) => inst.ResultId;
    public OpGroupAll(int resultType, int resultId, int execution, int predicate)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupAll, ResultType, ResultId, Execution, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupAll(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupAll(OpData data) => new(data);
}

public struct OpGroupAny : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupAny()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupAny | (1 << 16);
    }

    public OpGroupAny(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupAny(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupAny inst) => inst.ResultId;
    public OpGroupAny(int resultType, int resultId, int execution, int predicate)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupAny, ResultType, ResultId, Execution, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupAny(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupAny(OpData data) => new(data);
}

public struct OpGroupBroadcast : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupBroadcast()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupBroadcast | (1 << 16);
    }

    public OpGroupBroadcast(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupBroadcast(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LocalId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupBroadcast inst) => inst.ResultId;
    public OpGroupBroadcast(int resultType, int resultId, int execution, int value, int localId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        LocalId = localId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupBroadcast, ResultType, ResultId, Execution, Value, LocalId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "localId":
                    LocalId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupBroadcast(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupBroadcast(OpData data) => new(data);
}

public struct OpGroupIAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupIAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupIAdd | (1 << 16);
    }

    public OpGroupIAdd(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupIAdd(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupIAdd inst) => inst.ResultId;
    public OpGroupIAdd(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupIAdd, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupIAdd(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupIAdd(OpData data) => new(data);
}

public struct OpGroupFAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFAdd | (1 << 16);
    }

    public OpGroupFAdd(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupFAdd(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupFAdd inst) => inst.ResultId;
    public OpGroupFAdd(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFAdd, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupFAdd(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupFAdd(OpData data) => new(data);
}

public struct OpGroupFMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFMin | (1 << 16);
    }

    public OpGroupFMin(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupFMin(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupFMin inst) => inst.ResultId;
    public OpGroupFMin(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFMin, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupFMin(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupFMin(OpData data) => new(data);
}

public struct OpGroupUMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupUMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupUMin | (1 << 16);
    }

    public OpGroupUMin(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupUMin(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupUMin inst) => inst.ResultId;
    public OpGroupUMin(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupUMin, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupUMin(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupUMin(OpData data) => new(data);
}

public struct OpGroupSMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupSMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupSMin | (1 << 16);
    }

    public OpGroupSMin(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupSMin(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupSMin inst) => inst.ResultId;
    public OpGroupSMin(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupSMin, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupSMin(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupSMin(OpData data) => new(data);
}

public struct OpGroupFMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFMax | (1 << 16);
    }

    public OpGroupFMax(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupFMax(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupFMax inst) => inst.ResultId;
    public OpGroupFMax(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFMax, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupFMax(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupFMax(OpData data) => new(data);
}

public struct OpGroupUMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupUMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupUMax | (1 << 16);
    }

    public OpGroupUMax(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupUMax(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupUMax inst) => inst.ResultId;
    public OpGroupUMax(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupUMax, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupUMax(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupUMax(OpData data) => new(data);
}

public struct OpGroupSMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupSMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupSMax | (1 << 16);
    }

    public OpGroupSMax(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupSMax(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupSMax inst) => inst.ResultId;
    public OpGroupSMax(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupSMax, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupSMax(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupSMax(OpData data) => new(data);
}

public struct OpReadPipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReadPipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReadPipe | (1 << 16);
    }

    public OpReadPipe(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpReadPipe(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpReadPipe inst) => inst.ResultId;
    public OpReadPipe(int resultType, int resultId, int pipe, int pointer, int packetSize, int packetAlignment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        Pointer = pointer;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReadPipe, ResultType, ResultId, Pipe, Pointer, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpReadPipe(OpDataIndex odi) => new(odi);
    public static implicit operator OpReadPipe(OpData data) => new(data);
}

public struct OpWritePipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpWritePipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpWritePipe | (1 << 16);
    }

    public OpWritePipe(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpWritePipe(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpWritePipe inst) => inst.ResultId;
    public OpWritePipe(int resultType, int resultId, int pipe, int pointer, int packetSize, int packetAlignment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        Pointer = pointer;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpWritePipe, ResultType, ResultId, Pipe, Pointer, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpWritePipe(OpDataIndex odi) => new(odi);
    public static implicit operator OpWritePipe(OpData data) => new(data);
}

public struct OpReservedReadPipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReservedReadPipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReservedReadPipe | (1 << 16);
    }

    public OpReservedReadPipe(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpReservedReadPipe(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpReservedReadPipe inst) => inst.ResultId;
    public OpReservedReadPipe(int resultType, int resultId, int pipe, int reserveId, int index, int pointer, int packetSize, int packetAlignment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        ReserveId = reserveId;
        Index = index;
        Pointer = pointer;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReservedReadPipe, ResultType, ResultId, Pipe, ReserveId, Index, Pointer, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "reserveId":
                    ReserveId = o.ToLiteral<int>();
                    break;
                case "index":
                    Index = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpReservedReadPipe(OpDataIndex odi) => new(odi);
    public static implicit operator OpReservedReadPipe(OpData data) => new(data);
}

public struct OpReservedWritePipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReservedWritePipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReservedWritePipe | (1 << 16);
    }

    public OpReservedWritePipe(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpReservedWritePipe(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpReservedWritePipe inst) => inst.ResultId;
    public OpReservedWritePipe(int resultType, int resultId, int pipe, int reserveId, int index, int pointer, int packetSize, int packetAlignment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        ReserveId = reserveId;
        Index = index;
        Pointer = pointer;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReservedWritePipe, ResultType, ResultId, Pipe, ReserveId, Index, Pointer, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "reserveId":
                    ReserveId = o.ToLiteral<int>();
                    break;
                case "index":
                    Index = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpReservedWritePipe(OpDataIndex odi) => new(odi);
    public static implicit operator OpReservedWritePipe(OpData data) => new(data);
}

public struct OpReserveReadPipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReserveReadPipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReserveReadPipePackets | (1 << 16);
    }

    public OpReserveReadPipePackets(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpReserveReadPipePackets(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumPackets
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpReserveReadPipePackets inst) => inst.ResultId;
    public OpReserveReadPipePackets(int resultType, int resultId, int pipe, int numPackets, int packetSize, int packetAlignment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        NumPackets = numPackets;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReserveReadPipePackets, ResultType, ResultId, Pipe, NumPackets, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "numPackets":
                    NumPackets = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpReserveReadPipePackets(OpDataIndex odi) => new(odi);
    public static implicit operator OpReserveReadPipePackets(OpData data) => new(data);
}

public struct OpReserveWritePipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReserveWritePipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReserveWritePipePackets | (1 << 16);
    }

    public OpReserveWritePipePackets(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpReserveWritePipePackets(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumPackets
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpReserveWritePipePackets inst) => inst.ResultId;
    public OpReserveWritePipePackets(int resultType, int resultId, int pipe, int numPackets, int packetSize, int packetAlignment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        NumPackets = numPackets;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReserveWritePipePackets, ResultType, ResultId, Pipe, NumPackets, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "numPackets":
                    NumPackets = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpReserveWritePipePackets(OpDataIndex odi) => new(odi);
    public static implicit operator OpReserveWritePipePackets(OpData data) => new(data);
}

public struct OpCommitReadPipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCommitReadPipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCommitReadPipe | (1 << 16);
    }

    public OpCommitReadPipe(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCommitReadPipe(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCommitReadPipe(int pipe, int reserveId, int packetSize, int packetAlignment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Pipe = pipe;
        ReserveId = reserveId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCommitReadPipe, Pipe, ReserveId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "reserveId":
                    ReserveId = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCommitReadPipe(OpDataIndex odi) => new(odi);
    public static implicit operator OpCommitReadPipe(OpData data) => new(data);
}

public struct OpCommitWritePipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCommitWritePipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCommitWritePipe | (1 << 16);
    }

    public OpCommitWritePipe(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCommitWritePipe(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCommitWritePipe(int pipe, int reserveId, int packetSize, int packetAlignment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Pipe = pipe;
        ReserveId = reserveId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCommitWritePipe, Pipe, ReserveId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "reserveId":
                    ReserveId = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCommitWritePipe(OpDataIndex odi) => new(odi);
    public static implicit operator OpCommitWritePipe(OpData data) => new(data);
}

public struct OpIsValidReserveId : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsValidReserveId()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsValidReserveId | (1 << 16);
    }

    public OpIsValidReserveId(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIsValidReserveId(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIsValidReserveId inst) => inst.ResultId;
    public OpIsValidReserveId(int resultType, int resultId, int reserveId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        ReserveId = reserveId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsValidReserveId, ResultType, ResultId, ReserveId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "reserveId":
                    ReserveId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpIsValidReserveId(OpDataIndex odi) => new(odi);
    public static implicit operator OpIsValidReserveId(OpData data) => new(data);
}

public struct OpGetNumPipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetNumPipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetNumPipePackets | (1 << 16);
    }

    public OpGetNumPipePackets(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGetNumPipePackets(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetNumPipePackets inst) => inst.ResultId;
    public OpGetNumPipePackets(int resultType, int resultId, int pipe, int packetSize, int packetAlignment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetNumPipePackets, ResultType, ResultId, Pipe, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGetNumPipePackets(OpDataIndex odi) => new(odi);
    public static implicit operator OpGetNumPipePackets(OpData data) => new(data);
}

public struct OpGetMaxPipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetMaxPipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetMaxPipePackets | (1 << 16);
    }

    public OpGetMaxPipePackets(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGetMaxPipePackets(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetMaxPipePackets inst) => inst.ResultId;
    public OpGetMaxPipePackets(int resultType, int resultId, int pipe, int packetSize, int packetAlignment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pipe = pipe;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetMaxPipePackets, ResultType, ResultId, Pipe, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGetMaxPipePackets(OpDataIndex odi) => new(odi);
    public static implicit operator OpGetMaxPipePackets(OpData data) => new(data);
}

public struct OpGroupReserveReadPipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupReserveReadPipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupReserveReadPipePackets | (1 << 16);
    }

    public OpGroupReserveReadPipePackets(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupReserveReadPipePackets(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumPackets
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupReserveReadPipePackets inst) => inst.ResultId;
    public OpGroupReserveReadPipePackets(int resultType, int resultId, int execution, int pipe, int numPackets, int packetSize, int packetAlignment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Pipe = pipe;
        NumPackets = numPackets;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupReserveReadPipePackets, ResultType, ResultId, Execution, Pipe, NumPackets, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "numPackets":
                    NumPackets = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupReserveReadPipePackets(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupReserveReadPipePackets(OpData data) => new(data);
}

public struct OpGroupReserveWritePipePackets : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupReserveWritePipePackets()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupReserveWritePipePackets | (1 << 16);
    }

    public OpGroupReserveWritePipePackets(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupReserveWritePipePackets(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumPackets
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupReserveWritePipePackets inst) => inst.ResultId;
    public OpGroupReserveWritePipePackets(int resultType, int resultId, int execution, int pipe, int numPackets, int packetSize, int packetAlignment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Pipe = pipe;
        NumPackets = numPackets;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupReserveWritePipePackets, ResultType, ResultId, Execution, Pipe, NumPackets, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "numPackets":
                    NumPackets = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupReserveWritePipePackets(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupReserveWritePipePackets(OpData data) => new(data);
}

public struct OpGroupCommitReadPipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupCommitReadPipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupCommitReadPipe | (1 << 16);
    }

    public OpGroupCommitReadPipe(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupCommitReadPipe(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupCommitReadPipe(int execution, int pipe, int reserveId, int packetSize, int packetAlignment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Execution = execution;
        Pipe = pipe;
        ReserveId = reserveId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupCommitReadPipe, Execution, Pipe, ReserveId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "reserveId":
                    ReserveId = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupCommitReadPipe(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupCommitReadPipe(OpData data) => new(data);
}

public struct OpGroupCommitWritePipe : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupCommitWritePipe()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupCommitWritePipe | (1 << 16);
    }

    public OpGroupCommitWritePipe(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupCommitWritePipe(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pipe
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReserveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpGroupCommitWritePipe(int execution, int pipe, int reserveId, int packetSize, int packetAlignment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Execution = execution;
        Pipe = pipe;
        ReserveId = reserveId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupCommitWritePipe, Execution, Pipe, ReserveId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "pipe":
                    Pipe = o.ToLiteral<int>();
                    break;
                case "reserveId":
                    ReserveId = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupCommitWritePipe(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupCommitWritePipe(OpData data) => new(data);
}

public struct OpEnqueueMarker : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEnqueueMarker()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEnqueueMarker | (1 << 16);
    }

    public OpEnqueueMarker(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpEnqueueMarker(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Queue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumEvents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int WaitEvents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RetEvent
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpEnqueueMarker inst) => inst.ResultId;
    public OpEnqueueMarker(int resultType, int resultId, int queue, int numEvents, int waitEvents, int retEvent)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Queue = queue;
        NumEvents = numEvents;
        WaitEvents = waitEvents;
        RetEvent = retEvent;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEnqueueMarker, ResultType, ResultId, Queue, NumEvents, WaitEvents, RetEvent];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "queue":
                    Queue = o.ToLiteral<int>();
                    break;
                case "numEvents":
                    NumEvents = o.ToLiteral<int>();
                    break;
                case "waitEvents":
                    WaitEvents = o.ToLiteral<int>();
                    break;
                case "retEvent":
                    RetEvent = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpEnqueueMarker(OpDataIndex odi) => new(odi);
    public static implicit operator OpEnqueueMarker(OpData data) => new(data);
}

public struct OpEnqueueKernel : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEnqueueKernel()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEnqueueKernel | (1 << 16);
    }

    public OpEnqueueKernel(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpEnqueueKernel(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Queue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Flags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NDRange
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumEvents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int WaitEvents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RetEvent
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpEnqueueKernel inst) => inst.ResultId;
    public OpEnqueueKernel(int resultType, int resultId, int queue, int flags, int nDRange, int numEvents, int waitEvents, int retEvent, int invoke, int param, int paramSize, int paramAlign, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Queue = queue;
        Flags = flags;
        NDRange = nDRange;
        NumEvents = numEvents;
        WaitEvents = waitEvents;
        RetEvent = retEvent;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEnqueueKernel, ResultType, ResultId, Queue, Flags, NDRange, NumEvents, WaitEvents, RetEvent, Invoke, Param, ParamSize, ParamAlign, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "queue":
                    Queue = o.ToLiteral<int>();
                    break;
                case "flags":
                    Flags = o.ToLiteral<int>();
                    break;
                case "nDRange":
                    NDRange = o.ToLiteral<int>();
                    break;
                case "numEvents":
                    NumEvents = o.ToLiteral<int>();
                    break;
                case "waitEvents":
                    WaitEvents = o.ToLiteral<int>();
                    break;
                case "retEvent":
                    RetEvent = o.ToLiteral<int>();
                    break;
                case "invoke":
                    Invoke = o.ToLiteral<int>();
                    break;
                case "param":
                    Param = o.ToLiteral<int>();
                    break;
                case "paramSize":
                    ParamSize = o.ToLiteral<int>();
                    break;
                case "paramAlign":
                    ParamAlign = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpEnqueueKernel(OpDataIndex odi) => new(odi);
    public static implicit operator OpEnqueueKernel(OpData data) => new(data);
}

public struct OpGetKernelNDrangeSubGroupCount : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelNDrangeSubGroupCount()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelNDrangeSubGroupCount | (1 << 16);
    }

    public OpGetKernelNDrangeSubGroupCount(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGetKernelNDrangeSubGroupCount(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NDRange
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetKernelNDrangeSubGroupCount inst) => inst.ResultId;
    public OpGetKernelNDrangeSubGroupCount(int resultType, int resultId, int nDRange, int invoke, int param, int paramSize, int paramAlign)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        NDRange = nDRange;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelNDrangeSubGroupCount, ResultType, ResultId, NDRange, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "nDRange":
                    NDRange = o.ToLiteral<int>();
                    break;
                case "invoke":
                    Invoke = o.ToLiteral<int>();
                    break;
                case "param":
                    Param = o.ToLiteral<int>();
                    break;
                case "paramSize":
                    ParamSize = o.ToLiteral<int>();
                    break;
                case "paramAlign":
                    ParamAlign = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGetKernelNDrangeSubGroupCount(OpDataIndex odi) => new(odi);
    public static implicit operator OpGetKernelNDrangeSubGroupCount(OpData data) => new(data);
}

public struct OpGetKernelNDrangeMaxSubGroupSize : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelNDrangeMaxSubGroupSize()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelNDrangeMaxSubGroupSize | (1 << 16);
    }

    public OpGetKernelNDrangeMaxSubGroupSize(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGetKernelNDrangeMaxSubGroupSize(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NDRange
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetKernelNDrangeMaxSubGroupSize inst) => inst.ResultId;
    public OpGetKernelNDrangeMaxSubGroupSize(int resultType, int resultId, int nDRange, int invoke, int param, int paramSize, int paramAlign)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        NDRange = nDRange;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelNDrangeMaxSubGroupSize, ResultType, ResultId, NDRange, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "nDRange":
                    NDRange = o.ToLiteral<int>();
                    break;
                case "invoke":
                    Invoke = o.ToLiteral<int>();
                    break;
                case "param":
                    Param = o.ToLiteral<int>();
                    break;
                case "paramSize":
                    ParamSize = o.ToLiteral<int>();
                    break;
                case "paramAlign":
                    ParamAlign = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGetKernelNDrangeMaxSubGroupSize(OpDataIndex odi) => new(odi);
    public static implicit operator OpGetKernelNDrangeMaxSubGroupSize(OpData data) => new(data);
}

public struct OpGetKernelWorkGroupSize : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelWorkGroupSize()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelWorkGroupSize | (1 << 16);
    }

    public OpGetKernelWorkGroupSize(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGetKernelWorkGroupSize(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetKernelWorkGroupSize inst) => inst.ResultId;
    public OpGetKernelWorkGroupSize(int resultType, int resultId, int invoke, int param, int paramSize, int paramAlign)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelWorkGroupSize, ResultType, ResultId, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "invoke":
                    Invoke = o.ToLiteral<int>();
                    break;
                case "param":
                    Param = o.ToLiteral<int>();
                    break;
                case "paramSize":
                    ParamSize = o.ToLiteral<int>();
                    break;
                case "paramAlign":
                    ParamAlign = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGetKernelWorkGroupSize(OpDataIndex odi) => new(odi);
    public static implicit operator OpGetKernelWorkGroupSize(OpData data) => new(data);
}

public struct OpGetKernelPreferredWorkGroupSizeMultiple : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelPreferredWorkGroupSizeMultiple()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelPreferredWorkGroupSizeMultiple | (1 << 16);
    }

    public OpGetKernelPreferredWorkGroupSizeMultiple(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGetKernelPreferredWorkGroupSizeMultiple(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetKernelPreferredWorkGroupSizeMultiple inst) => inst.ResultId;
    public OpGetKernelPreferredWorkGroupSizeMultiple(int resultType, int resultId, int invoke, int param, int paramSize, int paramAlign)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelPreferredWorkGroupSizeMultiple, ResultType, ResultId, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "invoke":
                    Invoke = o.ToLiteral<int>();
                    break;
                case "param":
                    Param = o.ToLiteral<int>();
                    break;
                case "paramSize":
                    ParamSize = o.ToLiteral<int>();
                    break;
                case "paramAlign":
                    ParamAlign = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGetKernelPreferredWorkGroupSizeMultiple(OpDataIndex odi) => new(odi);
    public static implicit operator OpGetKernelPreferredWorkGroupSizeMultiple(OpData data) => new(data);
}

public struct OpRetainEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRetainEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRetainEvent | (1 << 16);
    }

    public OpRetainEvent(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRetainEvent(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRetainEvent(int eventId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        EventId = eventId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRetainEvent, EventId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "eventId":
                    EventId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRetainEvent(OpDataIndex odi) => new(odi);
    public static implicit operator OpRetainEvent(OpData data) => new(data);
}

public struct OpReleaseEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReleaseEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReleaseEvent | (1 << 16);
    }

    public OpReleaseEvent(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpReleaseEvent(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReleaseEvent(int eventId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        EventId = eventId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReleaseEvent, EventId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "eventId":
                    EventId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpReleaseEvent(OpDataIndex odi) => new(odi);
    public static implicit operator OpReleaseEvent(OpData data) => new(data);
}

public struct OpCreateUserEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCreateUserEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCreateUserEvent | (1 << 16);
    }

    public OpCreateUserEvent(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCreateUserEvent(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCreateUserEvent inst) => inst.ResultId;
    public OpCreateUserEvent(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCreateUserEvent, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCreateUserEvent(OpDataIndex odi) => new(odi);
    public static implicit operator OpCreateUserEvent(OpData data) => new(data);
}

public struct OpIsValidEvent : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsValidEvent()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsValidEvent | (1 << 16);
    }

    public OpIsValidEvent(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIsValidEvent(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIsValidEvent inst) => inst.ResultId;
    public OpIsValidEvent(int resultType, int resultId, int eventId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        EventId = eventId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsValidEvent, ResultType, ResultId, EventId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "eventId":
                    EventId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpIsValidEvent(OpDataIndex odi) => new(odi);
    public static implicit operator OpIsValidEvent(OpData data) => new(data);
}

public struct OpSetUserEventStatus : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSetUserEventStatus()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSetUserEventStatus | (1 << 16);
    }

    public OpSetUserEventStatus(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSetUserEventStatus(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Status
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSetUserEventStatus(int eventId, int status)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        EventId = eventId;
        Status = status;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSetUserEventStatus, EventId, Status];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "eventId":
                    EventId = o.ToLiteral<int>();
                    break;
                case "status":
                    Status = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSetUserEventStatus(OpDataIndex odi) => new(odi);
    public static implicit operator OpSetUserEventStatus(OpData data) => new(data);
}

public struct OpCaptureEventProfilingInfo : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCaptureEventProfilingInfo()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCaptureEventProfilingInfo | (1 << 16);
    }

    public OpCaptureEventProfilingInfo(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCaptureEventProfilingInfo(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int EventId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ProfilingInfo
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCaptureEventProfilingInfo(int eventId, int profilingInfo, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        EventId = eventId;
        ProfilingInfo = profilingInfo;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCaptureEventProfilingInfo, EventId, ProfilingInfo, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "eventId":
                    EventId = o.ToLiteral<int>();
                    break;
                case "profilingInfo":
                    ProfilingInfo = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCaptureEventProfilingInfo(OpDataIndex odi) => new(odi);
    public static implicit operator OpCaptureEventProfilingInfo(OpData data) => new(data);
}

public struct OpGetDefaultQueue : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetDefaultQueue()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetDefaultQueue | (1 << 16);
    }

    public OpGetDefaultQueue(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGetDefaultQueue(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetDefaultQueue inst) => inst.ResultId;
    public OpGetDefaultQueue(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetDefaultQueue, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGetDefaultQueue(OpDataIndex odi) => new(odi);
    public static implicit operator OpGetDefaultQueue(OpData data) => new(data);
}

public struct OpBuildNDRange : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBuildNDRange()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBuildNDRange | (1 << 16);
    }

    public OpBuildNDRange(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpBuildNDRange(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GlobalWorkSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LocalWorkSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GlobalWorkOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpBuildNDRange inst) => inst.ResultId;
    public OpBuildNDRange(int resultType, int resultId, int globalWorkSize, int localWorkSize, int globalWorkOffset)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        GlobalWorkSize = globalWorkSize;
        LocalWorkSize = localWorkSize;
        GlobalWorkOffset = globalWorkOffset;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBuildNDRange, ResultType, ResultId, GlobalWorkSize, LocalWorkSize, GlobalWorkOffset];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "globalWorkSize":
                    GlobalWorkSize = o.ToLiteral<int>();
                    break;
                case "localWorkSize":
                    LocalWorkSize = o.ToLiteral<int>();
                    break;
                case "globalWorkOffset":
                    GlobalWorkOffset = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpBuildNDRange(OpDataIndex odi) => new(odi);
    public static implicit operator OpBuildNDRange(OpData data) => new(data);
}

public struct OpImageSparseSampleImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleImplicitLod | (1 << 16);
    }

    public OpImageSparseSampleImplicitLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSparseSampleImplicitLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseSampleImplicitLod inst) => inst.ResultId;
    public OpImageSparseSampleImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleImplicitLod, ResultType, ResultId, SampledImage, Coordinate, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseSampleImplicitLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSparseSampleImplicitLod(OpData data) => new(data);
}

public struct OpImageSparseSampleExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleExplicitLod | (1 << 16);
    }

    public OpImageSparseSampleExplicitLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSparseSampleExplicitLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask> Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseSampleExplicitLod inst) => inst.ResultId;
    public OpImageSparseSampleExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ParameterizedFlag<ImageOperandsMask> imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleExplicitLod, ResultType, ResultId, SampledImage, Coordinate, ..(Span<int>)[(int)Imageoperands.Value, ..Imageoperands.Span]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseSampleExplicitLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSparseSampleExplicitLod(OpData data) => new(data);
}

public struct OpImageSparseSampleDrefImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleDrefImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleDrefImplicitLod | (1 << 16);
    }

    public OpImageSparseSampleDrefImplicitLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSparseSampleDrefImplicitLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseSampleDrefImplicitLod inst) => inst.ResultId;
    public OpImageSparseSampleDrefImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleDrefImplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseSampleDrefImplicitLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSparseSampleDrefImplicitLod(OpData data) => new(data);
}

public struct OpImageSparseSampleDrefExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleDrefExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleDrefExplicitLod | (1 << 16);
    }

    public OpImageSparseSampleDrefExplicitLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSparseSampleDrefExplicitLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask> Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseSampleDrefExplicitLod inst) => inst.ResultId;
    public OpImageSparseSampleDrefExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ParameterizedFlag<ImageOperandsMask> imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleDrefExplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, ..(Span<int>)[(int)Imageoperands.Value, ..Imageoperands.Span]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseSampleDrefExplicitLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSparseSampleDrefExplicitLod(OpData data) => new(data);
}

public struct OpImageSparseSampleProjImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleProjImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleProjImplicitLod | (1 << 16);
    }

    public OpImageSparseSampleProjImplicitLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSparseSampleProjImplicitLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseSampleProjImplicitLod inst) => inst.ResultId;
    public OpImageSparseSampleProjImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleProjImplicitLod, ResultType, ResultId, SampledImage, Coordinate, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseSampleProjImplicitLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSparseSampleProjImplicitLod(OpData data) => new(data);
}

public struct OpImageSparseSampleProjExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleProjExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleProjExplicitLod | (1 << 16);
    }

    public OpImageSparseSampleProjExplicitLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSparseSampleProjExplicitLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask> Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseSampleProjExplicitLod inst) => inst.ResultId;
    public OpImageSparseSampleProjExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, ParameterizedFlag<ImageOperandsMask> imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleProjExplicitLod, ResultType, ResultId, SampledImage, Coordinate, ..(Span<int>)[(int)Imageoperands.Value, ..Imageoperands.Span]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseSampleProjExplicitLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSparseSampleProjExplicitLod(OpData data) => new(data);
}

public struct OpImageSparseSampleProjDrefImplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleProjDrefImplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleProjDrefImplicitLod | (1 << 16);
    }

    public OpImageSparseSampleProjDrefImplicitLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSparseSampleProjDrefImplicitLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseSampleProjDrefImplicitLod inst) => inst.ResultId;
    public OpImageSparseSampleProjDrefImplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleProjDrefImplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseSampleProjDrefImplicitLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSparseSampleProjDrefImplicitLod(OpData data) => new(data);
}

public struct OpImageSparseSampleProjDrefExplicitLod : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseSampleProjDrefExplicitLod()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseSampleProjDrefExplicitLod | (1 << 16);
    }

    public OpImageSparseSampleProjDrefExplicitLod(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSparseSampleProjDrefExplicitLod(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask> Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseSampleProjDrefExplicitLod inst) => inst.ResultId;
    public OpImageSparseSampleProjDrefExplicitLod(int resultType, int resultId, int sampledImage, int coordinate, int dref, ParameterizedFlag<ImageOperandsMask> imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseSampleProjDrefExplicitLod, ResultType, ResultId, SampledImage, Coordinate, Dref, ..(Span<int>)[(int)Imageoperands.Value, ..Imageoperands.Span]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseSampleProjDrefExplicitLod(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSparseSampleProjDrefExplicitLod(OpData data) => new(data);
}

public struct OpImageSparseFetch : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseFetch()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseFetch | (1 << 16);
    }

    public OpImageSparseFetch(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSparseFetch(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseFetch inst) => inst.ResultId;
    public OpImageSparseFetch(int resultType, int resultId, int image, int coordinate, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseFetch, ResultType, ResultId, Image, Coordinate, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseFetch(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSparseFetch(OpData data) => new(data);
}

public struct OpImageSparseGather : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseGather()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseGather | (1 << 16);
    }

    public OpImageSparseGather(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSparseGather(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Component
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseGather inst) => inst.ResultId;
    public OpImageSparseGather(int resultType, int resultId, int sampledImage, int coordinate, int component, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Component = component;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseGather, ResultType, ResultId, SampledImage, Coordinate, Component, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "component":
                    Component = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseGather(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSparseGather(OpData data) => new(data);
}

public struct OpImageSparseDrefGather : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseDrefGather()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseDrefGather | (1 << 16);
    }

    public OpImageSparseDrefGather(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSparseDrefGather(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseDrefGather inst) => inst.ResultId;
    public OpImageSparseDrefGather(int resultType, int resultId, int sampledImage, int coordinate, int dref, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Dref = dref;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseDrefGather, ResultType, ResultId, SampledImage, Coordinate, Dref, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "dref":
                    Dref = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseDrefGather(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSparseDrefGather(OpData data) => new(data);
}

public struct OpImageSparseTexelsResident : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseTexelsResident()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseTexelsResident | (1 << 16);
    }

    public OpImageSparseTexelsResident(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSparseTexelsResident(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResidentCode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseTexelsResident inst) => inst.ResultId;
    public OpImageSparseTexelsResident(int resultType, int resultId, int residentCode)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        ResidentCode = residentCode;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseTexelsResident, ResultType, ResultId, ResidentCode];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "residentCode":
                    ResidentCode = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseTexelsResident(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSparseTexelsResident(OpData data) => new(data);
}

public struct OpNoLine : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNoLine()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpNoLine | (1 << 16);
    }

    public OpNoLine(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpNoLine(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpNoLine, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpNoLine(OpDataIndex odi) => new(odi);
    public static implicit operator OpNoLine(OpData data) => new(data);
}

public struct OpAtomicFlagTestAndSet : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicFlagTestAndSet()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicFlagTestAndSet | (1 << 16);
    }

    public OpAtomicFlagTestAndSet(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicFlagTestAndSet(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicFlagTestAndSet inst) => inst.ResultId;
    public OpAtomicFlagTestAndSet(int resultType, int resultId, int pointer, int memory, int semantics)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicFlagTestAndSet, ResultType, ResultId, Pointer, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicFlagTestAndSet(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicFlagTestAndSet(OpData data) => new(data);
}

public struct OpAtomicFlagClear : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicFlagClear()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicFlagClear | (1 << 16);
    }

    public OpAtomicFlagClear(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicFlagClear(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAtomicFlagClear(int pointer, int memory, int semantics)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicFlagClear, Pointer, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicFlagClear(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicFlagClear(OpData data) => new(data);
}

public struct OpImageSparseRead : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSparseRead()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSparseRead | (1 << 16);
    }

    public OpImageSparseRead(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSparseRead(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSparseRead inst) => inst.ResultId;
    public OpImageSparseRead(int resultType, int resultId, int image, int coordinate, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSparseRead, ResultType, ResultId, Image, Coordinate, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSparseRead(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSparseRead(OpData data) => new(data);
}

public struct OpSizeOf : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSizeOf()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSizeOf | (1 << 16);
    }

    public OpSizeOf(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSizeOf(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSizeOf inst) => inst.ResultId;
    public OpSizeOf(int resultType, int resultId, int pointer)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSizeOf, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSizeOf(OpDataIndex odi) => new(odi);
    public static implicit operator OpSizeOf(OpData data) => new(data);
}

public struct OpTypePipeStorage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypePipeStorage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypePipeStorage | (1 << 16);
    }

    public OpTypePipeStorage(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypePipeStorage(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypePipeStorage inst) => inst.ResultId;
    public OpTypePipeStorage(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypePipeStorage, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypePipeStorage(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypePipeStorage(OpData data) => new(data);
}

public struct OpConstantPipeStorage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantPipeStorage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantPipeStorage | (1 << 16);
    }

    public OpConstantPipeStorage(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConstantPipeStorage(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Capacity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantPipeStorage inst) => inst.ResultId;
    public OpConstantPipeStorage(int resultType, int resultId, int packetSize, int packetAlignment, int capacity)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
        Capacity = capacity;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantPipeStorage, ResultType, ResultId, ..PacketSize.AsDisposableLiteralValue().Words, ..PacketAlignment.AsDisposableLiteralValue().Words, ..Capacity.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
                case "capacity":
                    Capacity = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConstantPipeStorage(OpDataIndex odi) => new(odi);
    public static implicit operator OpConstantPipeStorage(OpData data) => new(data);
}

public struct OpCreatePipeFromPipeStorage : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCreatePipeFromPipeStorage()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCreatePipeFromPipeStorage | (1 << 16);
    }

    public OpCreatePipeFromPipeStorage(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCreatePipeFromPipeStorage(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PipeStorage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCreatePipeFromPipeStorage inst) => inst.ResultId;
    public OpCreatePipeFromPipeStorage(int resultType, int resultId, int pipeStorage)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        PipeStorage = pipeStorage;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCreatePipeFromPipeStorage, ResultType, ResultId, PipeStorage];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pipeStorage":
                    PipeStorage = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCreatePipeFromPipeStorage(OpDataIndex odi) => new(odi);
    public static implicit operator OpCreatePipeFromPipeStorage(OpData data) => new(data);
}

public struct OpGetKernelLocalSizeForSubgroupCount : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelLocalSizeForSubgroupCount()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelLocalSizeForSubgroupCount | (1 << 16);
    }

    public OpGetKernelLocalSizeForSubgroupCount(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGetKernelLocalSizeForSubgroupCount(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SubgroupCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetKernelLocalSizeForSubgroupCount inst) => inst.ResultId;
    public OpGetKernelLocalSizeForSubgroupCount(int resultType, int resultId, int subgroupCount, int invoke, int param, int paramSize, int paramAlign)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SubgroupCount = subgroupCount;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelLocalSizeForSubgroupCount, ResultType, ResultId, SubgroupCount, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "subgroupCount":
                    SubgroupCount = o.ToLiteral<int>();
                    break;
                case "invoke":
                    Invoke = o.ToLiteral<int>();
                    break;
                case "param":
                    Param = o.ToLiteral<int>();
                    break;
                case "paramSize":
                    ParamSize = o.ToLiteral<int>();
                    break;
                case "paramAlign":
                    ParamAlign = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGetKernelLocalSizeForSubgroupCount(OpDataIndex odi) => new(odi);
    public static implicit operator OpGetKernelLocalSizeForSubgroupCount(OpData data) => new(data);
}

public struct OpGetKernelMaxNumSubgroups : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGetKernelMaxNumSubgroups()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGetKernelMaxNumSubgroups | (1 << 16);
    }

    public OpGetKernelMaxNumSubgroups(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGetKernelMaxNumSubgroups(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Invoke
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Param
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ParamAlign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGetKernelMaxNumSubgroups inst) => inst.ResultId;
    public OpGetKernelMaxNumSubgroups(int resultType, int resultId, int invoke, int param, int paramSize, int paramAlign)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Invoke = invoke;
        Param = param;
        ParamSize = paramSize;
        ParamAlign = paramAlign;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGetKernelMaxNumSubgroups, ResultType, ResultId, Invoke, Param, ParamSize, ParamAlign];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "invoke":
                    Invoke = o.ToLiteral<int>();
                    break;
                case "param":
                    Param = o.ToLiteral<int>();
                    break;
                case "paramSize":
                    ParamSize = o.ToLiteral<int>();
                    break;
                case "paramAlign":
                    ParamAlign = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGetKernelMaxNumSubgroups(OpDataIndex odi) => new(odi);
    public static implicit operator OpGetKernelMaxNumSubgroups(OpData data) => new(data);
}

public struct OpTypeNamedBarrier : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeNamedBarrier()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeNamedBarrier | (1 << 16);
    }

    public OpTypeNamedBarrier(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeNamedBarrier(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeNamedBarrier inst) => inst.ResultId;
    public OpTypeNamedBarrier(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeNamedBarrier, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeNamedBarrier(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeNamedBarrier(OpData data) => new(data);
}

public struct OpNamedBarrierInitialize : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNamedBarrierInitialize()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpNamedBarrierInitialize | (1 << 16);
    }

    public OpNamedBarrierInitialize(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpNamedBarrierInitialize(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SubgroupCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpNamedBarrierInitialize inst) => inst.ResultId;
    public OpNamedBarrierInitialize(int resultType, int resultId, int subgroupCount)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SubgroupCount = subgroupCount;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpNamedBarrierInitialize, ResultType, ResultId, SubgroupCount];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "subgroupCount":
                    SubgroupCount = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpNamedBarrierInitialize(OpDataIndex odi) => new(odi);
    public static implicit operator OpNamedBarrierInitialize(OpData data) => new(data);
}

public struct OpMemoryNamedBarrier : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemoryNamedBarrier()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemoryNamedBarrier | (1 << 16);
    }

    public OpMemoryNamedBarrier(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpMemoryNamedBarrier(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int NamedBarrier
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemoryNamedBarrier(int namedBarrier, int memory, int semantics)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        NamedBarrier = namedBarrier;
        Memory = memory;
        Semantics = semantics;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemoryNamedBarrier, NamedBarrier, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "namedBarrier":
                    NamedBarrier = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpMemoryNamedBarrier(OpDataIndex odi) => new(odi);
    public static implicit operator OpMemoryNamedBarrier(OpData data) => new(data);
}

public struct OpModuleProcessed : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpModuleProcessed()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpModuleProcessed | (1 << 16);
    }

    public OpModuleProcessed(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpModuleProcessed(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public string Process
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpModuleProcessed(string process)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Process = process;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpModuleProcessed, ..Process.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "process":
                    Process = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpModuleProcessed(OpDataIndex odi) => new(odi);
    public static implicit operator OpModuleProcessed(OpData data) => new(data);
}

public struct OpExecutionModeId : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExecutionModeId()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExecutionModeId | (1 << 16);
    }

    public OpExecutionModeId(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpExecutionModeId(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int EntryPoint
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ExecutionMode> Mode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExecutionModeId(int entryPoint, ParameterizedFlag<ExecutionMode> mode)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        EntryPoint = entryPoint;
        Mode = mode;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExecutionModeId, EntryPoint, ..(Span<int>)[(int)Mode.Value, ..Mode.Span]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "entryPoint":
                    EntryPoint = o.ToLiteral<int>();
                    break;
                case "mode":
                    Mode = o.ToEnum<ExecutionMode>();
                    break;
            }
        }
    }

    public static implicit operator OpExecutionModeId(OpDataIndex odi) => new(odi);
    public static implicit operator OpExecutionModeId(OpData data) => new(data);
}

public struct OpDecorateId : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDecorateId()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDecorateId | (1 << 16);
    }

    public OpDecorateId(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpDecorateId(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public Decoration Decoration
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDecorateId(int target, Decoration decoration)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Target = target;
        Decoration = decoration;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDecorateId, Target, (int)Decoration];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "target":
                    Target = o.ToLiteral<int>();
                    break;
                case "decoration":
                    Decoration = o.ToEnum<Decoration>();
                    break;
            }
        }
    }

    public static implicit operator OpDecorateId(OpDataIndex odi) => new(odi);
    public static implicit operator OpDecorateId(OpData data) => new(data);
}

public struct OpGroupNonUniformElect : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformElect()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformElect | (1 << 16);
    }

    public OpGroupNonUniformElect(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformElect(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformElect inst) => inst.ResultId;
    public OpGroupNonUniformElect(int resultType, int resultId, int execution)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformElect, ResultType, ResultId, Execution];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformElect(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformElect(OpData data) => new(data);
}

public struct OpGroupNonUniformAll : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformAll()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformAll | (1 << 16);
    }

    public OpGroupNonUniformAll(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformAll(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformAll inst) => inst.ResultId;
    public OpGroupNonUniformAll(int resultType, int resultId, int execution, int predicate)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformAll, ResultType, ResultId, Execution, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformAll(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformAll(OpData data) => new(data);
}

public struct OpGroupNonUniformAny : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformAny()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformAny | (1 << 16);
    }

    public OpGroupNonUniformAny(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformAny(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformAny inst) => inst.ResultId;
    public OpGroupNonUniformAny(int resultType, int resultId, int execution, int predicate)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformAny, ResultType, ResultId, Execution, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformAny(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformAny(OpData data) => new(data);
}

public struct OpGroupNonUniformAllEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformAllEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformAllEqual | (1 << 16);
    }

    public OpGroupNonUniformAllEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformAllEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformAllEqual inst) => inst.ResultId;
    public OpGroupNonUniformAllEqual(int resultType, int resultId, int execution, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformAllEqual, ResultType, ResultId, Execution, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformAllEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformAllEqual(OpData data) => new(data);
}

public struct OpGroupNonUniformBroadcast : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBroadcast()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBroadcast | (1 << 16);
    }

    public OpGroupNonUniformBroadcast(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformBroadcast(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Id
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBroadcast inst) => inst.ResultId;
    public OpGroupNonUniformBroadcast(int resultType, int resultId, int execution, int value, int id)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Id = id;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBroadcast, ResultType, ResultId, Execution, Value, Id];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "id":
                    Id = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBroadcast(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformBroadcast(OpData data) => new(data);
}

public struct OpGroupNonUniformBroadcastFirst : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBroadcastFirst()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBroadcastFirst | (1 << 16);
    }

    public OpGroupNonUniformBroadcastFirst(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformBroadcastFirst(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBroadcastFirst inst) => inst.ResultId;
    public OpGroupNonUniformBroadcastFirst(int resultType, int resultId, int execution, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBroadcastFirst, ResultType, ResultId, Execution, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBroadcastFirst(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformBroadcastFirst(OpData data) => new(data);
}

public struct OpGroupNonUniformBallot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBallot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBallot | (1 << 16);
    }

    public OpGroupNonUniformBallot(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformBallot(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBallot inst) => inst.ResultId;
    public OpGroupNonUniformBallot(int resultType, int resultId, int execution, int predicate)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Predicate = predicate;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBallot, ResultType, ResultId, Execution, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBallot(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformBallot(OpData data) => new(data);
}

public struct OpGroupNonUniformInverseBallot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformInverseBallot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformInverseBallot | (1 << 16);
    }

    public OpGroupNonUniformInverseBallot(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformInverseBallot(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformInverseBallot inst) => inst.ResultId;
    public OpGroupNonUniformInverseBallot(int resultType, int resultId, int execution, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformInverseBallot, ResultType, ResultId, Execution, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformInverseBallot(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformInverseBallot(OpData data) => new(data);
}

public struct OpGroupNonUniformBallotBitExtract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBallotBitExtract()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBallotBitExtract | (1 << 16);
    }

    public OpGroupNonUniformBallotBitExtract(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformBallotBitExtract(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBallotBitExtract inst) => inst.ResultId;
    public OpGroupNonUniformBallotBitExtract(int resultType, int resultId, int execution, int value, int index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Index = index;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBallotBitExtract, ResultType, ResultId, Execution, Value, Index];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "index":
                    Index = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBallotBitExtract(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformBallotBitExtract(OpData data) => new(data);
}

public struct OpGroupNonUniformBallotBitCount : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBallotBitCount()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBallotBitCount | (1 << 16);
    }

    public OpGroupNonUniformBallotBitCount(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformBallotBitCount(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBallotBitCount inst) => inst.ResultId;
    public OpGroupNonUniformBallotBitCount(int resultType, int resultId, int execution, GroupOperation operation, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBallotBitCount, ResultType, ResultId, Execution, (int)Operation, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBallotBitCount(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformBallotBitCount(OpData data) => new(data);
}

public struct OpGroupNonUniformBallotFindLSB : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBallotFindLSB()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBallotFindLSB | (1 << 16);
    }

    public OpGroupNonUniformBallotFindLSB(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformBallotFindLSB(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBallotFindLSB inst) => inst.ResultId;
    public OpGroupNonUniformBallotFindLSB(int resultType, int resultId, int execution, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBallotFindLSB, ResultType, ResultId, Execution, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBallotFindLSB(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformBallotFindLSB(OpData data) => new(data);
}

public struct OpGroupNonUniformBallotFindMSB : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBallotFindMSB()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBallotFindMSB | (1 << 16);
    }

    public OpGroupNonUniformBallotFindMSB(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformBallotFindMSB(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBallotFindMSB inst) => inst.ResultId;
    public OpGroupNonUniformBallotFindMSB(int resultType, int resultId, int execution, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBallotFindMSB, ResultType, ResultId, Execution, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBallotFindMSB(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformBallotFindMSB(OpData data) => new(data);
}

public struct OpGroupNonUniformShuffle : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformShuffle()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformShuffle | (1 << 16);
    }

    public OpGroupNonUniformShuffle(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformShuffle(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Id
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformShuffle inst) => inst.ResultId;
    public OpGroupNonUniformShuffle(int resultType, int resultId, int execution, int value, int id)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Id = id;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformShuffle, ResultType, ResultId, Execution, Value, Id];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "id":
                    Id = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformShuffle(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformShuffle(OpData data) => new(data);
}

public struct OpGroupNonUniformShuffleXor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformShuffleXor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformShuffleXor | (1 << 16);
    }

    public OpGroupNonUniformShuffleXor(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformShuffleXor(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformShuffleXor inst) => inst.ResultId;
    public OpGroupNonUniformShuffleXor(int resultType, int resultId, int execution, int value, int mask)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Mask = mask;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformShuffleXor, ResultType, ResultId, Execution, Value, Mask];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "mask":
                    Mask = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformShuffleXor(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformShuffleXor(OpData data) => new(data);
}

public struct OpGroupNonUniformShuffleUp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformShuffleUp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformShuffleUp | (1 << 16);
    }

    public OpGroupNonUniformShuffleUp(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformShuffleUp(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformShuffleUp inst) => inst.ResultId;
    public OpGroupNonUniformShuffleUp(int resultType, int resultId, int execution, int value, int delta)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Delta = delta;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformShuffleUp, ResultType, ResultId, Execution, Value, Delta];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "delta":
                    Delta = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformShuffleUp(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformShuffleUp(OpData data) => new(data);
}

public struct OpGroupNonUniformShuffleDown : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformShuffleDown()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformShuffleDown | (1 << 16);
    }

    public OpGroupNonUniformShuffleDown(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformShuffleDown(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformShuffleDown inst) => inst.ResultId;
    public OpGroupNonUniformShuffleDown(int resultType, int resultId, int execution, int value, int delta)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Delta = delta;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformShuffleDown, ResultType, ResultId, Execution, Value, Delta];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "delta":
                    Delta = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformShuffleDown(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformShuffleDown(OpData data) => new(data);
}

public struct OpGroupNonUniformIAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformIAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformIAdd | (1 << 16);
    }

    public OpGroupNonUniformIAdd(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformIAdd(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformIAdd inst) => inst.ResultId;
    public OpGroupNonUniformIAdd(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformIAdd, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformIAdd(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformIAdd(OpData data) => new(data);
}

public struct OpGroupNonUniformFAdd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformFAdd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformFAdd | (1 << 16);
    }

    public OpGroupNonUniformFAdd(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformFAdd(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformFAdd inst) => inst.ResultId;
    public OpGroupNonUniformFAdd(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformFAdd, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformFAdd(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformFAdd(OpData data) => new(data);
}

public struct OpGroupNonUniformIMul : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformIMul()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformIMul | (1 << 16);
    }

    public OpGroupNonUniformIMul(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformIMul(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformIMul inst) => inst.ResultId;
    public OpGroupNonUniformIMul(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformIMul, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformIMul(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformIMul(OpData data) => new(data);
}

public struct OpGroupNonUniformFMul : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformFMul()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformFMul | (1 << 16);
    }

    public OpGroupNonUniformFMul(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformFMul(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformFMul inst) => inst.ResultId;
    public OpGroupNonUniformFMul(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformFMul, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformFMul(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformFMul(OpData data) => new(data);
}

public struct OpGroupNonUniformSMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformSMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformSMin | (1 << 16);
    }

    public OpGroupNonUniformSMin(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformSMin(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformSMin inst) => inst.ResultId;
    public OpGroupNonUniformSMin(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformSMin, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformSMin(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformSMin(OpData data) => new(data);
}

public struct OpGroupNonUniformUMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformUMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformUMin | (1 << 16);
    }

    public OpGroupNonUniformUMin(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformUMin(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformUMin inst) => inst.ResultId;
    public OpGroupNonUniformUMin(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformUMin, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformUMin(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformUMin(OpData data) => new(data);
}

public struct OpGroupNonUniformFMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformFMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformFMin | (1 << 16);
    }

    public OpGroupNonUniformFMin(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformFMin(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformFMin inst) => inst.ResultId;
    public OpGroupNonUniformFMin(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformFMin, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformFMin(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformFMin(OpData data) => new(data);
}

public struct OpGroupNonUniformSMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformSMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformSMax | (1 << 16);
    }

    public OpGroupNonUniformSMax(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformSMax(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformSMax inst) => inst.ResultId;
    public OpGroupNonUniformSMax(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformSMax, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformSMax(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformSMax(OpData data) => new(data);
}

public struct OpGroupNonUniformUMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformUMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformUMax | (1 << 16);
    }

    public OpGroupNonUniformUMax(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformUMax(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformUMax inst) => inst.ResultId;
    public OpGroupNonUniformUMax(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformUMax, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformUMax(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformUMax(OpData data) => new(data);
}

public struct OpGroupNonUniformFMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformFMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformFMax | (1 << 16);
    }

    public OpGroupNonUniformFMax(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformFMax(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformFMax inst) => inst.ResultId;
    public OpGroupNonUniformFMax(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformFMax, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformFMax(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformFMax(OpData data) => new(data);
}

public struct OpGroupNonUniformBitwiseAnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBitwiseAnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBitwiseAnd | (1 << 16);
    }

    public OpGroupNonUniformBitwiseAnd(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformBitwiseAnd(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBitwiseAnd inst) => inst.ResultId;
    public OpGroupNonUniformBitwiseAnd(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBitwiseAnd, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBitwiseAnd(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformBitwiseAnd(OpData data) => new(data);
}

public struct OpGroupNonUniformBitwiseOr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBitwiseOr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBitwiseOr | (1 << 16);
    }

    public OpGroupNonUniformBitwiseOr(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformBitwiseOr(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBitwiseOr inst) => inst.ResultId;
    public OpGroupNonUniformBitwiseOr(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBitwiseOr, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBitwiseOr(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformBitwiseOr(OpData data) => new(data);
}

public struct OpGroupNonUniformBitwiseXor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformBitwiseXor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformBitwiseXor | (1 << 16);
    }

    public OpGroupNonUniformBitwiseXor(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformBitwiseXor(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformBitwiseXor inst) => inst.ResultId;
    public OpGroupNonUniformBitwiseXor(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformBitwiseXor, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformBitwiseXor(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformBitwiseXor(OpData data) => new(data);
}

public struct OpGroupNonUniformLogicalAnd : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformLogicalAnd()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformLogicalAnd | (1 << 16);
    }

    public OpGroupNonUniformLogicalAnd(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformLogicalAnd(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformLogicalAnd inst) => inst.ResultId;
    public OpGroupNonUniformLogicalAnd(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformLogicalAnd, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformLogicalAnd(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformLogicalAnd(OpData data) => new(data);
}

public struct OpGroupNonUniformLogicalOr : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformLogicalOr()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformLogicalOr | (1 << 16);
    }

    public OpGroupNonUniformLogicalOr(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformLogicalOr(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformLogicalOr inst) => inst.ResultId;
    public OpGroupNonUniformLogicalOr(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformLogicalOr, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformLogicalOr(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformLogicalOr(OpData data) => new(data);
}

public struct OpGroupNonUniformLogicalXor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformLogicalXor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformLogicalXor | (1 << 16);
    }

    public OpGroupNonUniformLogicalXor(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformLogicalXor(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformLogicalXor inst) => inst.ResultId;
    public OpGroupNonUniformLogicalXor(int resultType, int resultId, int execution, GroupOperation operation, int value, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        Value = value;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformLogicalXor, ResultType, ResultId, Execution, (int)Operation, Value, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformLogicalXor(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformLogicalXor(OpData data) => new(data);
}

public struct OpGroupNonUniformQuadBroadcast : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformQuadBroadcast()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformQuadBroadcast | (1 << 16);
    }

    public OpGroupNonUniformQuadBroadcast(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformQuadBroadcast(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformQuadBroadcast inst) => inst.ResultId;
    public OpGroupNonUniformQuadBroadcast(int resultType, int resultId, int execution, int value, int index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Index = index;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformQuadBroadcast, ResultType, ResultId, Execution, Value, Index];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "index":
                    Index = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformQuadBroadcast(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformQuadBroadcast(OpData data) => new(data);
}

public struct OpGroupNonUniformQuadSwap : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformQuadSwap()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformQuadSwap | (1 << 16);
    }

    public OpGroupNonUniformQuadSwap(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformQuadSwap(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformQuadSwap inst) => inst.ResultId;
    public OpGroupNonUniformQuadSwap(int resultType, int resultId, int execution, int value, int direction)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Direction = direction;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformQuadSwap, ResultType, ResultId, Execution, Value, Direction];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformQuadSwap(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformQuadSwap(OpData data) => new(data);
}

public struct OpCopyLogical : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCopyLogical()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCopyLogical | (1 << 16);
    }

    public OpCopyLogical(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCopyLogical(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCopyLogical inst) => inst.ResultId;
    public OpCopyLogical(int resultType, int resultId, int operand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCopyLogical, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCopyLogical(OpDataIndex odi) => new(odi);
    public static implicit operator OpCopyLogical(OpData data) => new(data);
}

public struct OpPtrEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrEqual | (1 << 16);
    }

    public OpPtrEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpPtrEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpPtrEqual inst) => inst.ResultId;
    public OpPtrEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpPtrEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpPtrEqual(OpData data) => new(data);
}

public struct OpPtrNotEqual : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrNotEqual()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrNotEqual | (1 << 16);
    }

    public OpPtrNotEqual(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpPtrNotEqual(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpPtrNotEqual inst) => inst.ResultId;
    public OpPtrNotEqual(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrNotEqual, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpPtrNotEqual(OpDataIndex odi) => new(odi);
    public static implicit operator OpPtrNotEqual(OpData data) => new(data);
}

public struct OpPtrDiff : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrDiff()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrDiff | (1 << 16);
    }

    public OpPtrDiff(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpPtrDiff(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpPtrDiff inst) => inst.ResultId;
    public OpPtrDiff(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrDiff, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpPtrDiff(OpDataIndex odi) => new(odi);
    public static implicit operator OpPtrDiff(OpData data) => new(data);
}

public struct OpColorAttachmentReadEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpColorAttachmentReadEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpColorAttachmentReadEXT | (1 << 16);
    }

    public OpColorAttachmentReadEXT(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpColorAttachmentReadEXT(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Attachment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Sample
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpColorAttachmentReadEXT inst) => inst.ResultId;
    public OpColorAttachmentReadEXT(int resultType, int resultId, int attachment, int? sample)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Attachment = attachment;
        Sample = sample;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpColorAttachmentReadEXT, ResultType, ResultId, Attachment, ..(Sample is null ? (Span<int>)[] : [Sample.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "attachment":
                    Attachment = o.ToLiteral<int>();
                    break;
                case "sample":
                    if (o.Words.Length > 0)
                        Sample = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpColorAttachmentReadEXT(OpDataIndex odi) => new(odi);
    public static implicit operator OpColorAttachmentReadEXT(OpData data) => new(data);
}

public struct OpDepthAttachmentReadEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDepthAttachmentReadEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDepthAttachmentReadEXT | (1 << 16);
    }

    public OpDepthAttachmentReadEXT(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpDepthAttachmentReadEXT(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Sample
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpDepthAttachmentReadEXT inst) => inst.ResultId;
    public OpDepthAttachmentReadEXT(int resultType, int resultId, int? sample)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Sample = sample;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDepthAttachmentReadEXT, ResultType, ResultId, ..(Sample is null ? (Span<int>)[] : [Sample.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sample":
                    if (o.Words.Length > 0)
                        Sample = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpDepthAttachmentReadEXT(OpDataIndex odi) => new(odi);
    public static implicit operator OpDepthAttachmentReadEXT(OpData data) => new(data);
}

public struct OpStencilAttachmentReadEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpStencilAttachmentReadEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpStencilAttachmentReadEXT | (1 << 16);
    }

    public OpStencilAttachmentReadEXT(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpStencilAttachmentReadEXT(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Sample
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpStencilAttachmentReadEXT inst) => inst.ResultId;
    public OpStencilAttachmentReadEXT(int resultType, int resultId, int? sample)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Sample = sample;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpStencilAttachmentReadEXT, ResultType, ResultId, ..(Sample is null ? (Span<int>)[] : [Sample.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sample":
                    if (o.Words.Length > 0)
                        Sample = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpStencilAttachmentReadEXT(OpDataIndex odi) => new(odi);
    public static implicit operator OpStencilAttachmentReadEXT(OpData data) => new(data);
}

public struct OpTerminateInvocation : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTerminateInvocation()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTerminateInvocation | (1 << 16);
    }

    public OpTerminateInvocation(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTerminateInvocation(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTerminateInvocation, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpTerminateInvocation(OpDataIndex odi) => new(odi);
    public static implicit operator OpTerminateInvocation(OpData data) => new(data);
}

public struct OpTypeUntypedPointerKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeUntypedPointerKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeUntypedPointerKHR | (1 << 16);
    }

    public OpTypeUntypedPointerKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeUntypedPointerKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeUntypedPointerKHR inst) => inst.ResultId;
    public OpTypeUntypedPointerKHR(int resultId, StorageClass storageclass)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        Storageclass = storageclass;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeUntypedPointerKHR, ResultId, (int)Storageclass];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "storageclass":
                    Storageclass = o.ToEnum<StorageClass>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeUntypedPointerKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeUntypedPointerKHR(OpData data) => new(data);
}

public struct OpUntypedVariableKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedVariableKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedVariableKHR | (1 << 16);
    }

    public OpUntypedVariableKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUntypedVariableKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public StorageClass Storageclass
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? DataType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Initializer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUntypedVariableKHR inst) => inst.ResultId;
    public OpUntypedVariableKHR(int resultType, int resultId, StorageClass storageclass, int? dataType, int? initializer)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Storageclass = storageclass;
        DataType = dataType;
        Initializer = initializer;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedVariableKHR, ResultType, ResultId, (int)Storageclass, ..(DataType is null ? (Span<int>)[] : [DataType.Value]), ..(Initializer is null ? (Span<int>)[] : [Initializer.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "storageclass":
                    Storageclass = o.ToEnum<StorageClass>();
                    break;
                case "dataType":
                    if (o.Words.Length > 0)
                        DataType = o.ToLiteral<int?>();
                    break;
                case "initializer":
                    if (o.Words.Length > 0)
                        Initializer = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpUntypedVariableKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpUntypedVariableKHR(OpData data) => new(data);
}

public struct OpUntypedAccessChainKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedAccessChainKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedAccessChainKHR | (1 << 16);
    }

    public OpUntypedAccessChainKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUntypedAccessChainKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUntypedAccessChainKHR inst) => inst.ResultId;
    public OpUntypedAccessChainKHR(int resultType, int resultId, int baseType, int baseId, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseType = baseType;
        BaseId = baseId;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedAccessChainKHR, ResultType, ResultId, BaseType, BaseId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseType":
                    BaseType = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUntypedAccessChainKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpUntypedAccessChainKHR(OpData data) => new(data);
}

public struct OpUntypedInBoundsAccessChainKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedInBoundsAccessChainKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedInBoundsAccessChainKHR | (1 << 16);
    }

    public OpUntypedInBoundsAccessChainKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUntypedInBoundsAccessChainKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUntypedInBoundsAccessChainKHR inst) => inst.ResultId;
    public OpUntypedInBoundsAccessChainKHR(int resultType, int resultId, int baseType, int baseId, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseType = baseType;
        BaseId = baseId;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedInBoundsAccessChainKHR, ResultType, ResultId, BaseType, BaseId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseType":
                    BaseType = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUntypedInBoundsAccessChainKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpUntypedInBoundsAccessChainKHR(OpData data) => new(data);
}

public struct OpSubgroupBallotKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupBallotKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupBallotKHR | (1 << 16);
    }

    public OpSubgroupBallotKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupBallotKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupBallotKHR inst) => inst.ResultId;
    public OpSubgroupBallotKHR(int resultType, int resultId, int predicate)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupBallotKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupBallotKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupBallotKHR(OpData data) => new(data);
}

public struct OpSubgroupFirstInvocationKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupFirstInvocationKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupFirstInvocationKHR | (1 << 16);
    }

    public OpSubgroupFirstInvocationKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupFirstInvocationKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupFirstInvocationKHR inst) => inst.ResultId;
    public OpSubgroupFirstInvocationKHR(int resultType, int resultId, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupFirstInvocationKHR, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupFirstInvocationKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupFirstInvocationKHR(OpData data) => new(data);
}

public struct OpUntypedPtrAccessChainKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedPtrAccessChainKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedPtrAccessChainKHR | (1 << 16);
    }

    public OpUntypedPtrAccessChainKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUntypedPtrAccessChainKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Element
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUntypedPtrAccessChainKHR inst) => inst.ResultId;
    public OpUntypedPtrAccessChainKHR(int resultType, int resultId, int baseType, int baseId, int element, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseType = baseType;
        BaseId = baseId;
        Element = element;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedPtrAccessChainKHR, ResultType, ResultId, BaseType, BaseId, Element, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseType":
                    BaseType = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "element":
                    Element = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUntypedPtrAccessChainKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpUntypedPtrAccessChainKHR(OpData data) => new(data);
}

public struct OpUntypedInBoundsPtrAccessChainKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedInBoundsPtrAccessChainKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedInBoundsPtrAccessChainKHR | (1 << 16);
    }

    public OpUntypedInBoundsPtrAccessChainKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUntypedInBoundsPtrAccessChainKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Element
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUntypedInBoundsPtrAccessChainKHR inst) => inst.ResultId;
    public OpUntypedInBoundsPtrAccessChainKHR(int resultType, int resultId, int baseType, int baseId, int element, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseType = baseType;
        BaseId = baseId;
        Element = element;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedInBoundsPtrAccessChainKHR, ResultType, ResultId, BaseType, BaseId, Element, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseType":
                    BaseType = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "element":
                    Element = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUntypedInBoundsPtrAccessChainKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpUntypedInBoundsPtrAccessChainKHR(OpData data) => new(data);
}

public struct OpUntypedArrayLengthKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedArrayLengthKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedArrayLengthKHR | (1 << 16);
    }

    public OpUntypedArrayLengthKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUntypedArrayLengthKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Structure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Arraymember
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUntypedArrayLengthKHR inst) => inst.ResultId;
    public OpUntypedArrayLengthKHR(int resultType, int resultId, int structure, int pointer, int arraymember)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Structure = structure;
        Pointer = pointer;
        Arraymember = arraymember;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedArrayLengthKHR, ResultType, ResultId, Structure, Pointer, ..Arraymember.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "structure":
                    Structure = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "arraymember":
                    Arraymember = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUntypedArrayLengthKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpUntypedArrayLengthKHR(OpData data) => new(data);
}

public struct OpUntypedPrefetchKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUntypedPrefetchKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUntypedPrefetchKHR | (1 << 16);
    }

    public OpUntypedPrefetchKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUntypedPrefetchKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int PointerType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumBytes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? RW
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Locality
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? CacheType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpUntypedPrefetchKHR(int pointerType, int numBytes, int? rW, int? locality, int? cacheType)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        PointerType = pointerType;
        NumBytes = numBytes;
        RW = rW;
        Locality = locality;
        CacheType = cacheType;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUntypedPrefetchKHR, PointerType, NumBytes, ..(RW is null ? (Span<int>)[] : [RW.Value]), ..(Locality is null ? (Span<int>)[] : [Locality.Value]), ..(CacheType is null ? (Span<int>)[] : [CacheType.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointerType":
                    PointerType = o.ToLiteral<int>();
                    break;
                case "numBytes":
                    NumBytes = o.ToLiteral<int>();
                    break;
                case "rW":
                    if (o.Words.Length > 0)
                        RW = o.ToLiteral<int?>();
                    break;
                case "locality":
                    if (o.Words.Length > 0)
                        Locality = o.ToLiteral<int?>();
                    break;
                case "cacheType":
                    if (o.Words.Length > 0)
                        CacheType = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpUntypedPrefetchKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpUntypedPrefetchKHR(OpData data) => new(data);
}

public struct OpSubgroupAllKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAllKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAllKHR | (1 << 16);
    }

    public OpSubgroupAllKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAllKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAllKHR inst) => inst.ResultId;
    public OpSubgroupAllKHR(int resultType, int resultId, int predicate)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAllKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAllKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAllKHR(OpData data) => new(data);
}

public struct OpSubgroupAnyKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAnyKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAnyKHR | (1 << 16);
    }

    public OpSubgroupAnyKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAnyKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAnyKHR inst) => inst.ResultId;
    public OpSubgroupAnyKHR(int resultType, int resultId, int predicate)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAnyKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAnyKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAnyKHR(OpData data) => new(data);
}

public struct OpSubgroupAllEqualKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAllEqualKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAllEqualKHR | (1 << 16);
    }

    public OpSubgroupAllEqualKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAllEqualKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAllEqualKHR inst) => inst.ResultId;
    public OpSubgroupAllEqualKHR(int resultType, int resultId, int predicate)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAllEqualKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAllEqualKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAllEqualKHR(OpData data) => new(data);
}

public struct OpGroupNonUniformRotateKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformRotateKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformRotateKHR | (1 << 16);
    }

    public OpGroupNonUniformRotateKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformRotateKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? ClusterSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformRotateKHR inst) => inst.ResultId;
    public OpGroupNonUniformRotateKHR(int resultType, int resultId, int execution, int value, int delta, int? clusterSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Value = value;
        Delta = delta;
        ClusterSize = clusterSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformRotateKHR, ResultType, ResultId, Execution, Value, Delta, ..(ClusterSize is null ? (Span<int>)[] : [ClusterSize.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "delta":
                    Delta = o.ToLiteral<int>();
                    break;
                case "clusterSize":
                    if (o.Words.Length > 0)
                        ClusterSize = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformRotateKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformRotateKHR(OpData data) => new(data);
}

public struct OpSubgroupReadInvocationKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupReadInvocationKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupReadInvocationKHR | (1 << 16);
    }

    public OpSubgroupReadInvocationKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupReadInvocationKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Index
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupReadInvocationKHR inst) => inst.ResultId;
    public OpSubgroupReadInvocationKHR(int resultType, int resultId, int value, int index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        Index = index;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupReadInvocationKHR, ResultType, ResultId, Value, Index];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "index":
                    Index = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupReadInvocationKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupReadInvocationKHR(OpData data) => new(data);
}

public struct OpExtInstWithForwardRefsKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExtInstWithForwardRefsKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInstWithForwardRefsKHR | (1 << 16);
    }

    public OpExtInstWithForwardRefsKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpExtInstWithForwardRefsKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Instruction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpExtInstWithForwardRefsKHR inst) => inst.ResultId;
    public OpExtInstWithForwardRefsKHR(int resultType, int resultId, int set, int instruction, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Instruction = instruction;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInstWithForwardRefsKHR, ResultType, ResultId, Set, ..Instruction.AsDisposableLiteralValue().Words, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "instruction":
                    Instruction = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpExtInstWithForwardRefsKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpExtInstWithForwardRefsKHR(OpData data) => new(data);
}

public struct OpTraceRayKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTraceRayKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTraceRayKHR | (1 << 16);
    }

    public OpTraceRayKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTraceRayKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTraceRayKHR(int accel, int rayFlags, int cullMask, int sBTOffset, int sBTStride, int missIndex, int rayOrigin, int rayTmin, int rayDirection, int rayTmax, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        SBTOffset = sBTOffset;
        SBTStride = sBTStride;
        MissIndex = missIndex;
        RayOrigin = rayOrigin;
        RayTmin = rayTmin;
        RayDirection = rayDirection;
        RayTmax = rayTmax;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTraceRayKHR, Accel, RayFlags, CullMask, SBTOffset, SBTStride, MissIndex, RayOrigin, RayTmin, RayDirection, RayTmax, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "accel":
                    Accel = o.ToLiteral<int>();
                    break;
                case "rayFlags":
                    RayFlags = o.ToLiteral<int>();
                    break;
                case "cullMask":
                    CullMask = o.ToLiteral<int>();
                    break;
                case "sBTOffset":
                    SBTOffset = o.ToLiteral<int>();
                    break;
                case "sBTStride":
                    SBTStride = o.ToLiteral<int>();
                    break;
                case "missIndex":
                    MissIndex = o.ToLiteral<int>();
                    break;
                case "rayOrigin":
                    RayOrigin = o.ToLiteral<int>();
                    break;
                case "rayTmin":
                    RayTmin = o.ToLiteral<int>();
                    break;
                case "rayDirection":
                    RayDirection = o.ToLiteral<int>();
                    break;
                case "rayTmax":
                    RayTmax = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTraceRayKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpTraceRayKHR(OpData data) => new(data);
}

public struct OpExecuteCallableKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExecuteCallableKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExecuteCallableKHR | (1 << 16);
    }

    public OpExecuteCallableKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpExecuteCallableKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int SBTIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CallableData
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExecuteCallableKHR(int sBTIndex, int callableData)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        SBTIndex = sBTIndex;
        CallableData = callableData;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExecuteCallableKHR, SBTIndex, CallableData];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "sBTIndex":
                    SBTIndex = o.ToLiteral<int>();
                    break;
                case "callableData":
                    CallableData = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpExecuteCallableKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpExecuteCallableKHR(OpData data) => new(data);
}

public struct OpConvertUToAccelerationStructureKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToAccelerationStructureKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToAccelerationStructureKHR | (1 << 16);
    }

    public OpConvertUToAccelerationStructureKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConvertUToAccelerationStructureKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertUToAccelerationStructureKHR inst) => inst.ResultId;
    public OpConvertUToAccelerationStructureKHR(int resultType, int resultId, int accel)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Accel = accel;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToAccelerationStructureKHR, ResultType, ResultId, Accel];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "accel":
                    Accel = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConvertUToAccelerationStructureKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpConvertUToAccelerationStructureKHR(OpData data) => new(data);
}

public struct OpIgnoreIntersectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIgnoreIntersectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIgnoreIntersectionKHR | (1 << 16);
    }

    public OpIgnoreIntersectionKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIgnoreIntersectionKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIgnoreIntersectionKHR, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpIgnoreIntersectionKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpIgnoreIntersectionKHR(OpData data) => new(data);
}

public struct OpTerminateRayKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTerminateRayKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTerminateRayKHR | (1 << 16);
    }

    public OpTerminateRayKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTerminateRayKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTerminateRayKHR, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpTerminateRayKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpTerminateRayKHR(OpData data) => new(data);
}

public struct OpSDot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDot | (1 << 16);
    }

    public OpSDot(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDot(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDot inst) => inst.ResultId;
    public OpSDot(int resultType, int resultId, int vector1, int vector2, PackedVectorFormat? packedVectorFormat)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        PackedVectorFormat = packedVectorFormat;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDot, ResultType, ResultId, Vector1, Vector2, ..(PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
                case "packedVectorFormat":
                    if (o.Words.Length > 0)
                        PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
                    break;
            }
        }
    }

    public static implicit operator OpSDot(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDot(OpData data) => new(data);
}

public struct OpUDot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUDot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUDot | (1 << 16);
    }

    public OpUDot(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUDot(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUDot inst) => inst.ResultId;
    public OpUDot(int resultType, int resultId, int vector1, int vector2, PackedVectorFormat? packedVectorFormat)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        PackedVectorFormat = packedVectorFormat;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUDot, ResultType, ResultId, Vector1, Vector2, ..(PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
                case "packedVectorFormat":
                    if (o.Words.Length > 0)
                        PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
                    break;
            }
        }
    }

    public static implicit operator OpUDot(OpDataIndex odi) => new(odi);
    public static implicit operator OpUDot(OpData data) => new(data);
}

public struct OpSUDot : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSUDot()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSUDot | (1 << 16);
    }

    public OpSUDot(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSUDot(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSUDot inst) => inst.ResultId;
    public OpSUDot(int resultType, int resultId, int vector1, int vector2, PackedVectorFormat? packedVectorFormat)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        PackedVectorFormat = packedVectorFormat;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSUDot, ResultType, ResultId, Vector1, Vector2, ..(PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
                case "packedVectorFormat":
                    if (o.Words.Length > 0)
                        PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
                    break;
            }
        }
    }

    public static implicit operator OpSUDot(OpDataIndex odi) => new(odi);
    public static implicit operator OpSUDot(OpData data) => new(data);
}

public struct OpSDotAccSat : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSDotAccSat()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSDotAccSat | (1 << 16);
    }

    public OpSDotAccSat(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSDotAccSat(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accumulator
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSDotAccSat inst) => inst.ResultId;
    public OpSDotAccSat(int resultType, int resultId, int vector1, int vector2, int accumulator, PackedVectorFormat? packedVectorFormat)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        Accumulator = accumulator;
        PackedVectorFormat = packedVectorFormat;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSDotAccSat, ResultType, ResultId, Vector1, Vector2, Accumulator, ..(PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
                case "accumulator":
                    Accumulator = o.ToLiteral<int>();
                    break;
                case "packedVectorFormat":
                    if (o.Words.Length > 0)
                        PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
                    break;
            }
        }
    }

    public static implicit operator OpSDotAccSat(OpDataIndex odi) => new(odi);
    public static implicit operator OpSDotAccSat(OpData data) => new(data);
}

public struct OpUDotAccSat : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUDotAccSat()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUDotAccSat | (1 << 16);
    }

    public OpUDotAccSat(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUDotAccSat(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accumulator
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUDotAccSat inst) => inst.ResultId;
    public OpUDotAccSat(int resultType, int resultId, int vector1, int vector2, int accumulator, PackedVectorFormat? packedVectorFormat)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        Accumulator = accumulator;
        PackedVectorFormat = packedVectorFormat;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUDotAccSat, ResultType, ResultId, Vector1, Vector2, Accumulator, ..(PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
                case "accumulator":
                    Accumulator = o.ToLiteral<int>();
                    break;
                case "packedVectorFormat":
                    if (o.Words.Length > 0)
                        PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
                    break;
            }
        }
    }

    public static implicit operator OpUDotAccSat(OpDataIndex odi) => new(odi);
    public static implicit operator OpUDotAccSat(OpData data) => new(data);
}

public struct OpSUDotAccSat : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSUDotAccSat()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSUDotAccSat | (1 << 16);
    }

    public OpSUDotAccSat(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSUDotAccSat(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Vector2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accumulator
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public PackedVectorFormat? PackedVectorFormat
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSUDotAccSat inst) => inst.ResultId;
    public OpSUDotAccSat(int resultType, int resultId, int vector1, int vector2, int accumulator, PackedVectorFormat? packedVectorFormat)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Vector1 = vector1;
        Vector2 = vector2;
        Accumulator = accumulator;
        PackedVectorFormat = packedVectorFormat;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSUDotAccSat, ResultType, ResultId, Vector1, Vector2, Accumulator, ..(PackedVectorFormat is null ? (Span<int>)[] : [(int)PackedVectorFormat.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "vector1":
                    Vector1 = o.ToLiteral<int>();
                    break;
                case "vector2":
                    Vector2 = o.ToLiteral<int>();
                    break;
                case "accumulator":
                    Accumulator = o.ToLiteral<int>();
                    break;
                case "packedVectorFormat":
                    if (o.Words.Length > 0)
                        PackedVectorFormat = o.ToEnum<PackedVectorFormat>();
                    break;
            }
        }
    }

    public static implicit operator OpSUDotAccSat(OpDataIndex odi) => new(odi);
    public static implicit operator OpSUDotAccSat(OpData data) => new(data);
}

public struct OpTypeCooperativeMatrixKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeCooperativeMatrixKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeCooperativeMatrixKHR | (1 << 16);
    }

    public OpTypeCooperativeMatrixKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeCooperativeMatrixKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ComponentType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Scope
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Rows
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Columns
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Use
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeCooperativeMatrixKHR inst) => inst.ResultId;
    public OpTypeCooperativeMatrixKHR(int resultId, int componentType, int scope, int rows, int columns, int use)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        ComponentType = componentType;
        Scope = scope;
        Rows = rows;
        Columns = columns;
        Use = use;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeCooperativeMatrixKHR, ResultId, ComponentType, Scope, Rows, Columns, Use];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "componentType":
                    ComponentType = o.ToLiteral<int>();
                    break;
                case "scope":
                    Scope = o.ToLiteral<int>();
                    break;
                case "rows":
                    Rows = o.ToLiteral<int>();
                    break;
                case "columns":
                    Columns = o.ToLiteral<int>();
                    break;
                case "use":
                    Use = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeCooperativeMatrixKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeCooperativeMatrixKHR(OpData data) => new(data);
}

public struct OpCooperativeMatrixLoadKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixLoadKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixLoadKHR | (1 << 16);
    }

    public OpCooperativeMatrixLoadKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCooperativeMatrixLoadKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MemoryLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Stride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<MemoryAccessMask>? MemoryOperand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixLoadKHR inst) => inst.ResultId;
    public OpCooperativeMatrixLoadKHR(int resultType, int resultId, int pointer, int memoryLayout, int? stride, ParameterizedFlag<MemoryAccessMask>? memoryOperand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        MemoryLayout = memoryLayout;
        Stride = stride;
        MemoryOperand = memoryOperand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixLoadKHR, ResultType, ResultId, Pointer, MemoryLayout, ..(Stride is null ? (Span<int>)[] : [Stride.Value]), ..(MemoryOperand is null ? (Span<int>)[] : [(int)MemoryOperand.Value.Value, ..MemoryOperand.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memoryLayout":
                    MemoryLayout = o.ToLiteral<int>();
                    break;
                case "stride":
                    if (o.Words.Length > 0)
                        Stride = o.ToLiteral<int?>();
                    break;
                case "memoryOperand":
                    if (o.Words.Length > 0)
                        MemoryOperand = o.ToEnum<MemoryAccessMask>();
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixLoadKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpCooperativeMatrixLoadKHR(OpData data) => new(data);
}

public struct OpCooperativeMatrixStoreKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixStoreKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixStoreKHR | (1 << 16);
    }

    public OpCooperativeMatrixStoreKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCooperativeMatrixStoreKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MemoryLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Stride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<MemoryAccessMask>? MemoryOperand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixStoreKHR(int pointer, int objectId, int memoryLayout, int? stride, ParameterizedFlag<MemoryAccessMask>? memoryOperand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Pointer = pointer;
        ObjectId = objectId;
        MemoryLayout = memoryLayout;
        Stride = stride;
        MemoryOperand = memoryOperand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixStoreKHR, Pointer, ObjectId, MemoryLayout, ..(Stride is null ? (Span<int>)[] : [Stride.Value]), ..(MemoryOperand is null ? (Span<int>)[] : [(int)MemoryOperand.Value.Value, ..MemoryOperand.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "objectId":
                    ObjectId = o.ToLiteral<int>();
                    break;
                case "memoryLayout":
                    MemoryLayout = o.ToLiteral<int>();
                    break;
                case "stride":
                    if (o.Words.Length > 0)
                        Stride = o.ToLiteral<int?>();
                    break;
                case "memoryOperand":
                    if (o.Words.Length > 0)
                        MemoryOperand = o.ToEnum<MemoryAccessMask>();
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixStoreKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpCooperativeMatrixStoreKHR(OpData data) => new(data);
}

public struct OpCooperativeMatrixMulAddKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixMulAddKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixMulAddKHR | (1 << 16);
    }

    public OpCooperativeMatrixMulAddKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCooperativeMatrixMulAddKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int C
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public CooperativeMatrixOperandsMask? CooperativeMatrixOperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixMulAddKHR inst) => inst.ResultId;
    public OpCooperativeMatrixMulAddKHR(int resultType, int resultId, int a, int b, int c, CooperativeMatrixOperandsMask? cooperativeMatrixOperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        B = b;
        C = c;
        CooperativeMatrixOperands = cooperativeMatrixOperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixMulAddKHR, ResultType, ResultId, A, B, C, ..(CooperativeMatrixOperands is null ? (Span<int>)[] : [(int)CooperativeMatrixOperands.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "c":
                    C = o.ToLiteral<int>();
                    break;
                case "cooperativeMatrixOperands":
                    if (o.Words.Length > 0)
                        CooperativeMatrixOperands = o.ToEnum<CooperativeMatrixOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixMulAddKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpCooperativeMatrixMulAddKHR(OpData data) => new(data);
}

public struct OpCooperativeMatrixLengthKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixLengthKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixLengthKHR | (1 << 16);
    }

    public OpCooperativeMatrixLengthKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCooperativeMatrixLengthKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Type
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixLengthKHR inst) => inst.ResultId;
    public OpCooperativeMatrixLengthKHR(int resultType, int resultId, int type)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Type = type;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixLengthKHR, ResultType, ResultId, Type];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "type":
                    Type = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixLengthKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpCooperativeMatrixLengthKHR(OpData data) => new(data);
}

public struct OpConstantCompositeReplicateEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantCompositeReplicateEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantCompositeReplicateEXT | (1 << 16);
    }

    public OpConstantCompositeReplicateEXT(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConstantCompositeReplicateEXT(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantCompositeReplicateEXT inst) => inst.ResultId;
    public OpConstantCompositeReplicateEXT(int resultType, int resultId, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantCompositeReplicateEXT, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConstantCompositeReplicateEXT(OpDataIndex odi) => new(odi);
    public static implicit operator OpConstantCompositeReplicateEXT(OpData data) => new(data);
}

public struct OpSpecConstantCompositeReplicateEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantCompositeReplicateEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantCompositeReplicateEXT | (1 << 16);
    }

    public OpSpecConstantCompositeReplicateEXT(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSpecConstantCompositeReplicateEXT(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSpecConstantCompositeReplicateEXT inst) => inst.ResultId;
    public OpSpecConstantCompositeReplicateEXT(int resultType, int resultId, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantCompositeReplicateEXT, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSpecConstantCompositeReplicateEXT(OpDataIndex odi) => new(odi);
    public static implicit operator OpSpecConstantCompositeReplicateEXT(OpData data) => new(data);
}

public struct OpCompositeConstructReplicateEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCompositeConstructReplicateEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCompositeConstructReplicateEXT | (1 << 16);
    }

    public OpCompositeConstructReplicateEXT(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCompositeConstructReplicateEXT(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCompositeConstructReplicateEXT inst) => inst.ResultId;
    public OpCompositeConstructReplicateEXT(int resultType, int resultId, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCompositeConstructReplicateEXT, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCompositeConstructReplicateEXT(OpDataIndex odi) => new(odi);
    public static implicit operator OpCompositeConstructReplicateEXT(OpData data) => new(data);
}

public struct OpTypeRayQueryKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeRayQueryKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeRayQueryKHR | (1 << 16);
    }

    public OpTypeRayQueryKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeRayQueryKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeRayQueryKHR inst) => inst.ResultId;
    public OpTypeRayQueryKHR(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeRayQueryKHR, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeRayQueryKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeRayQueryKHR(OpData data) => new(data);
}

public struct OpRayQueryInitializeKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryInitializeKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryInitializeKHR | (1 << 16);
    }

    public OpRayQueryInitializeKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryInitializeKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryInitializeKHR(int rayQuery, int accel, int rayFlags, int cullMask, int rayOrigin, int rayTMin, int rayDirection, int rayTMax)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        RayQuery = rayQuery;
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        RayOrigin = rayOrigin;
        RayTMin = rayTMin;
        RayDirection = rayDirection;
        RayTMax = rayTMax;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryInitializeKHR, RayQuery, Accel, RayFlags, CullMask, RayOrigin, RayTMin, RayDirection, RayTMax];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "accel":
                    Accel = o.ToLiteral<int>();
                    break;
                case "rayFlags":
                    RayFlags = o.ToLiteral<int>();
                    break;
                case "cullMask":
                    CullMask = o.ToLiteral<int>();
                    break;
                case "rayOrigin":
                    RayOrigin = o.ToLiteral<int>();
                    break;
                case "rayTMin":
                    RayTMin = o.ToLiteral<int>();
                    break;
                case "rayDirection":
                    RayDirection = o.ToLiteral<int>();
                    break;
                case "rayTMax":
                    RayTMax = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryInitializeKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryInitializeKHR(OpData data) => new(data);
}

public struct OpRayQueryTerminateKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryTerminateKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryTerminateKHR | (1 << 16);
    }

    public OpRayQueryTerminateKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryTerminateKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryTerminateKHR(int rayQuery)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        RayQuery = rayQuery;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryTerminateKHR, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryTerminateKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryTerminateKHR(OpData data) => new(data);
}

public struct OpRayQueryGenerateIntersectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGenerateIntersectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGenerateIntersectionKHR | (1 << 16);
    }

    public OpRayQueryGenerateIntersectionKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGenerateIntersectionKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitT
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryGenerateIntersectionKHR(int rayQuery, int hitT)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        RayQuery = rayQuery;
        HitT = hitT;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGenerateIntersectionKHR, RayQuery, HitT];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "hitT":
                    HitT = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGenerateIntersectionKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGenerateIntersectionKHR(OpData data) => new(data);
}

public struct OpRayQueryConfirmIntersectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryConfirmIntersectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryConfirmIntersectionKHR | (1 << 16);
    }

    public OpRayQueryConfirmIntersectionKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryConfirmIntersectionKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRayQueryConfirmIntersectionKHR(int rayQuery)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        RayQuery = rayQuery;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryConfirmIntersectionKHR, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryConfirmIntersectionKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryConfirmIntersectionKHR(OpData data) => new(data);
}

public struct OpRayQueryProceedKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryProceedKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryProceedKHR | (1 << 16);
    }

    public OpRayQueryProceedKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryProceedKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryProceedKHR inst) => inst.ResultId;
    public OpRayQueryProceedKHR(int resultType, int resultId, int rayQuery)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryProceedKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryProceedKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryProceedKHR(OpData data) => new(data);
}

public struct OpRayQueryGetIntersectionTypeKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionTypeKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionTypeKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionTypeKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetIntersectionTypeKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionTypeKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionTypeKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionTypeKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionTypeKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetIntersectionTypeKHR(OpData data) => new(data);
}

public struct OpImageSampleWeightedQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleWeightedQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleWeightedQCOM | (1 << 16);
    }

    public OpImageSampleWeightedQCOM(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSampleWeightedQCOM(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Texture
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Weights
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleWeightedQCOM inst) => inst.ResultId;
    public OpImageSampleWeightedQCOM(int resultType, int resultId, int texture, int coordinates, int weights)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Texture = texture;
        Coordinates = coordinates;
        Weights = weights;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleWeightedQCOM, ResultType, ResultId, Texture, Coordinates, Weights];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "texture":
                    Texture = o.ToLiteral<int>();
                    break;
                case "coordinates":
                    Coordinates = o.ToLiteral<int>();
                    break;
                case "weights":
                    Weights = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleWeightedQCOM(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSampleWeightedQCOM(OpData data) => new(data);
}

public struct OpImageBoxFilterQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBoxFilterQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBoxFilterQCOM | (1 << 16);
    }

    public OpImageBoxFilterQCOM(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageBoxFilterQCOM(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Texture
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BoxSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageBoxFilterQCOM inst) => inst.ResultId;
    public OpImageBoxFilterQCOM(int resultType, int resultId, int texture, int coordinates, int boxSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Texture = texture;
        Coordinates = coordinates;
        BoxSize = boxSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBoxFilterQCOM, ResultType, ResultId, Texture, Coordinates, BoxSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "texture":
                    Texture = o.ToLiteral<int>();
                    break;
                case "coordinates":
                    Coordinates = o.ToLiteral<int>();
                    break;
                case "boxSize":
                    BoxSize = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageBoxFilterQCOM(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageBoxFilterQCOM(OpData data) => new(data);
}

public struct OpImageBlockMatchSSDQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchSSDQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchSSDQCOM | (1 << 16);
    }

    public OpImageBlockMatchSSDQCOM(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageBlockMatchSSDQCOM(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Reference
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageBlockMatchSSDQCOM inst) => inst.ResultId;
    public OpImageBlockMatchSSDQCOM(int resultType, int resultId, int target, int targetCoordinates, int reference, int referenceCoordinates, int blockSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Target = target;
        TargetCoordinates = targetCoordinates;
        Reference = reference;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchSSDQCOM, ResultType, ResultId, Target, TargetCoordinates, Reference, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "target":
                    Target = o.ToLiteral<int>();
                    break;
                case "targetCoordinates":
                    TargetCoordinates = o.ToLiteral<int>();
                    break;
                case "reference":
                    Reference = o.ToLiteral<int>();
                    break;
                case "referenceCoordinates":
                    ReferenceCoordinates = o.ToLiteral<int>();
                    break;
                case "blockSize":
                    BlockSize = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageBlockMatchSSDQCOM(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageBlockMatchSSDQCOM(OpData data) => new(data);
}

public struct OpImageBlockMatchSADQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchSADQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchSADQCOM | (1 << 16);
    }

    public OpImageBlockMatchSADQCOM(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageBlockMatchSADQCOM(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Reference
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageBlockMatchSADQCOM inst) => inst.ResultId;
    public OpImageBlockMatchSADQCOM(int resultType, int resultId, int target, int targetCoordinates, int reference, int referenceCoordinates, int blockSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Target = target;
        TargetCoordinates = targetCoordinates;
        Reference = reference;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchSADQCOM, ResultType, ResultId, Target, TargetCoordinates, Reference, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "target":
                    Target = o.ToLiteral<int>();
                    break;
                case "targetCoordinates":
                    TargetCoordinates = o.ToLiteral<int>();
                    break;
                case "reference":
                    Reference = o.ToLiteral<int>();
                    break;
                case "referenceCoordinates":
                    ReferenceCoordinates = o.ToLiteral<int>();
                    break;
                case "blockSize":
                    BlockSize = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageBlockMatchSADQCOM(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageBlockMatchSADQCOM(OpData data) => new(data);
}

public struct OpImageBlockMatchWindowSSDQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchWindowSSDQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchWindowSSDQCOM | (1 << 16);
    }

    public OpImageBlockMatchWindowSSDQCOM(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageBlockMatchWindowSSDQCOM(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageBlockMatchWindowSSDQCOM inst) => inst.ResultId;
    public OpImageBlockMatchWindowSSDQCOM(int resultType, int resultId, int targetSampledImage, int targetCoordinates, int referenceSampledImage, int referenceCoordinates, int blockSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        TargetSampledImage = targetSampledImage;
        TargetCoordinates = targetCoordinates;
        ReferenceSampledImage = referenceSampledImage;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchWindowSSDQCOM, ResultType, ResultId, TargetSampledImage, TargetCoordinates, ReferenceSampledImage, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "targetSampledImage":
                    TargetSampledImage = o.ToLiteral<int>();
                    break;
                case "targetCoordinates":
                    TargetCoordinates = o.ToLiteral<int>();
                    break;
                case "referenceSampledImage":
                    ReferenceSampledImage = o.ToLiteral<int>();
                    break;
                case "referenceCoordinates":
                    ReferenceCoordinates = o.ToLiteral<int>();
                    break;
                case "blockSize":
                    BlockSize = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageBlockMatchWindowSSDQCOM(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageBlockMatchWindowSSDQCOM(OpData data) => new(data);
}

public struct OpImageBlockMatchWindowSADQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchWindowSADQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchWindowSADQCOM | (1 << 16);
    }

    public OpImageBlockMatchWindowSADQCOM(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageBlockMatchWindowSADQCOM(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageBlockMatchWindowSADQCOM inst) => inst.ResultId;
    public OpImageBlockMatchWindowSADQCOM(int resultType, int resultId, int targetSampledImage, int targetCoordinates, int referenceSampledImage, int referenceCoordinates, int blockSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        TargetSampledImage = targetSampledImage;
        TargetCoordinates = targetCoordinates;
        ReferenceSampledImage = referenceSampledImage;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchWindowSADQCOM, ResultType, ResultId, TargetSampledImage, TargetCoordinates, ReferenceSampledImage, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "targetSampledImage":
                    TargetSampledImage = o.ToLiteral<int>();
                    break;
                case "targetCoordinates":
                    TargetCoordinates = o.ToLiteral<int>();
                    break;
                case "referenceSampledImage":
                    ReferenceSampledImage = o.ToLiteral<int>();
                    break;
                case "referenceCoordinates":
                    ReferenceCoordinates = o.ToLiteral<int>();
                    break;
                case "blockSize":
                    BlockSize = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageBlockMatchWindowSADQCOM(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageBlockMatchWindowSADQCOM(OpData data) => new(data);
}

public struct OpImageBlockMatchGatherSSDQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchGatherSSDQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchGatherSSDQCOM | (1 << 16);
    }

    public OpImageBlockMatchGatherSSDQCOM(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageBlockMatchGatherSSDQCOM(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageBlockMatchGatherSSDQCOM inst) => inst.ResultId;
    public OpImageBlockMatchGatherSSDQCOM(int resultType, int resultId, int targetSampledImage, int targetCoordinates, int referenceSampledImage, int referenceCoordinates, int blockSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        TargetSampledImage = targetSampledImage;
        TargetCoordinates = targetCoordinates;
        ReferenceSampledImage = referenceSampledImage;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchGatherSSDQCOM, ResultType, ResultId, TargetSampledImage, TargetCoordinates, ReferenceSampledImage, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "targetSampledImage":
                    TargetSampledImage = o.ToLiteral<int>();
                    break;
                case "targetCoordinates":
                    TargetCoordinates = o.ToLiteral<int>();
                    break;
                case "referenceSampledImage":
                    ReferenceSampledImage = o.ToLiteral<int>();
                    break;
                case "referenceCoordinates":
                    ReferenceCoordinates = o.ToLiteral<int>();
                    break;
                case "blockSize":
                    BlockSize = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageBlockMatchGatherSSDQCOM(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageBlockMatchGatherSSDQCOM(OpData data) => new(data);
}

public struct OpImageBlockMatchGatherSADQCOM : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageBlockMatchGatherSADQCOM()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageBlockMatchGatherSADQCOM | (1 << 16);
    }

    public OpImageBlockMatchGatherSADQCOM(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageBlockMatchGatherSADQCOM(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TargetCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceSampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceCoordinates
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageBlockMatchGatherSADQCOM inst) => inst.ResultId;
    public OpImageBlockMatchGatherSADQCOM(int resultType, int resultId, int targetSampledImage, int targetCoordinates, int referenceSampledImage, int referenceCoordinates, int blockSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        TargetSampledImage = targetSampledImage;
        TargetCoordinates = targetCoordinates;
        ReferenceSampledImage = referenceSampledImage;
        ReferenceCoordinates = referenceCoordinates;
        BlockSize = blockSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageBlockMatchGatherSADQCOM, ResultType, ResultId, TargetSampledImage, TargetCoordinates, ReferenceSampledImage, ReferenceCoordinates, BlockSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "targetSampledImage":
                    TargetSampledImage = o.ToLiteral<int>();
                    break;
                case "targetCoordinates":
                    TargetCoordinates = o.ToLiteral<int>();
                    break;
                case "referenceSampledImage":
                    ReferenceSampledImage = o.ToLiteral<int>();
                    break;
                case "referenceCoordinates":
                    ReferenceCoordinates = o.ToLiteral<int>();
                    break;
                case "blockSize":
                    BlockSize = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpImageBlockMatchGatherSADQCOM(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageBlockMatchGatherSADQCOM(OpData data) => new(data);
}

public struct OpGroupIAddNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupIAddNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupIAddNonUniformAMD | (1 << 16);
    }

    public OpGroupIAddNonUniformAMD(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupIAddNonUniformAMD(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupIAddNonUniformAMD inst) => inst.ResultId;
    public OpGroupIAddNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupIAddNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupIAddNonUniformAMD(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupIAddNonUniformAMD(OpData data) => new(data);
}

public struct OpGroupFAddNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFAddNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFAddNonUniformAMD | (1 << 16);
    }

    public OpGroupFAddNonUniformAMD(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupFAddNonUniformAMD(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupFAddNonUniformAMD inst) => inst.ResultId;
    public OpGroupFAddNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFAddNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupFAddNonUniformAMD(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupFAddNonUniformAMD(OpData data) => new(data);
}

public struct OpGroupFMinNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFMinNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFMinNonUniformAMD | (1 << 16);
    }

    public OpGroupFMinNonUniformAMD(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupFMinNonUniformAMD(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupFMinNonUniformAMD inst) => inst.ResultId;
    public OpGroupFMinNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFMinNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupFMinNonUniformAMD(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupFMinNonUniformAMD(OpData data) => new(data);
}

public struct OpGroupUMinNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupUMinNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupUMinNonUniformAMD | (1 << 16);
    }

    public OpGroupUMinNonUniformAMD(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupUMinNonUniformAMD(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupUMinNonUniformAMD inst) => inst.ResultId;
    public OpGroupUMinNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupUMinNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupUMinNonUniformAMD(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupUMinNonUniformAMD(OpData data) => new(data);
}

public struct OpGroupSMinNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupSMinNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupSMinNonUniformAMD | (1 << 16);
    }

    public OpGroupSMinNonUniformAMD(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupSMinNonUniformAMD(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupSMinNonUniformAMD inst) => inst.ResultId;
    public OpGroupSMinNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupSMinNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupSMinNonUniformAMD(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupSMinNonUniformAMD(OpData data) => new(data);
}

public struct OpGroupFMaxNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFMaxNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFMaxNonUniformAMD | (1 << 16);
    }

    public OpGroupFMaxNonUniformAMD(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupFMaxNonUniformAMD(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupFMaxNonUniformAMD inst) => inst.ResultId;
    public OpGroupFMaxNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFMaxNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupFMaxNonUniformAMD(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupFMaxNonUniformAMD(OpData data) => new(data);
}

public struct OpGroupUMaxNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupUMaxNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupUMaxNonUniformAMD | (1 << 16);
    }

    public OpGroupUMaxNonUniformAMD(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupUMaxNonUniformAMD(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupUMaxNonUniformAMD inst) => inst.ResultId;
    public OpGroupUMaxNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupUMaxNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupUMaxNonUniformAMD(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupUMaxNonUniformAMD(OpData data) => new(data);
}

public struct OpGroupSMaxNonUniformAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupSMaxNonUniformAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupSMaxNonUniformAMD | (1 << 16);
    }

    public OpGroupSMaxNonUniformAMD(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupSMaxNonUniformAMD(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupSMaxNonUniformAMD inst) => inst.ResultId;
    public OpGroupSMaxNonUniformAMD(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupSMaxNonUniformAMD, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupSMaxNonUniformAMD(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupSMaxNonUniformAMD(OpData data) => new(data);
}

public struct OpFragmentMaskFetchAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFragmentMaskFetchAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFragmentMaskFetchAMD | (1 << 16);
    }

    public OpFragmentMaskFetchAMD(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFragmentMaskFetchAMD(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFragmentMaskFetchAMD inst) => inst.ResultId;
    public OpFragmentMaskFetchAMD(int resultType, int resultId, int image, int coordinate)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFragmentMaskFetchAMD, ResultType, ResultId, Image, Coordinate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFragmentMaskFetchAMD(OpDataIndex odi) => new(odi);
    public static implicit operator OpFragmentMaskFetchAMD(OpData data) => new(data);
}

public struct OpFragmentFetchAMD : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFragmentFetchAMD()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFragmentFetchAMD | (1 << 16);
    }

    public OpFragmentFetchAMD(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFragmentFetchAMD(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FragmentIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFragmentFetchAMD inst) => inst.ResultId;
    public OpFragmentFetchAMD(int resultType, int resultId, int image, int coordinate, int fragmentIndex)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        FragmentIndex = fragmentIndex;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFragmentFetchAMD, ResultType, ResultId, Image, Coordinate, FragmentIndex];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "fragmentIndex":
                    FragmentIndex = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFragmentFetchAMD(OpDataIndex odi) => new(odi);
    public static implicit operator OpFragmentFetchAMD(OpData data) => new(data);
}

public struct OpReadClockKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReadClockKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReadClockKHR | (1 << 16);
    }

    public OpReadClockKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpReadClockKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Scope
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpReadClockKHR inst) => inst.ResultId;
    public OpReadClockKHR(int resultType, int resultId, int scope)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Scope = scope;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReadClockKHR, ResultType, ResultId, Scope];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "scope":
                    Scope = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpReadClockKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpReadClockKHR(OpData data) => new(data);
}

public struct OpAllocateNodePayloadsAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAllocateNodePayloadsAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAllocateNodePayloadsAMDX | (1 << 16);
    }

    public OpAllocateNodePayloadsAMDX(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAllocateNodePayloadsAMDX(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Visibility
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NodeIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAllocateNodePayloadsAMDX inst) => inst.ResultId;
    public OpAllocateNodePayloadsAMDX(int resultType, int resultId, int visibility, int payloadCount, int nodeIndex)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Visibility = visibility;
        PayloadCount = payloadCount;
        NodeIndex = nodeIndex;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAllocateNodePayloadsAMDX, ResultType, ResultId, Visibility, PayloadCount, NodeIndex];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "visibility":
                    Visibility = o.ToLiteral<int>();
                    break;
                case "payloadCount":
                    PayloadCount = o.ToLiteral<int>();
                    break;
                case "nodeIndex":
                    NodeIndex = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAllocateNodePayloadsAMDX(OpDataIndex odi) => new(odi);
    public static implicit operator OpAllocateNodePayloadsAMDX(OpData data) => new(data);
}

public struct OpEnqueueNodePayloadsAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEnqueueNodePayloadsAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEnqueueNodePayloadsAMDX | (1 << 16);
    }

    public OpEnqueueNodePayloadsAMDX(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpEnqueueNodePayloadsAMDX(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int PayloadArray
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEnqueueNodePayloadsAMDX(int payloadArray)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        PayloadArray = payloadArray;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEnqueueNodePayloadsAMDX, PayloadArray];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "payloadArray":
                    PayloadArray = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpEnqueueNodePayloadsAMDX(OpDataIndex odi) => new(odi);
    public static implicit operator OpEnqueueNodePayloadsAMDX(OpData data) => new(data);
}

public struct OpTypeNodePayloadArrayAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeNodePayloadArrayAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeNodePayloadArrayAMDX | (1 << 16);
    }

    public OpTypeNodePayloadArrayAMDX(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeNodePayloadArrayAMDX(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeNodePayloadArrayAMDX inst) => inst.ResultId;
    public OpTypeNodePayloadArrayAMDX(int resultId, int payloadType)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        PayloadType = payloadType;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeNodePayloadArrayAMDX, ResultId, PayloadType];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payloadType":
                    PayloadType = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeNodePayloadArrayAMDX(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeNodePayloadArrayAMDX(OpData data) => new(data);
}

public struct OpFinishWritingNodePayloadAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFinishWritingNodePayloadAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFinishWritingNodePayloadAMDX | (1 << 16);
    }

    public OpFinishWritingNodePayloadAMDX(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFinishWritingNodePayloadAMDX(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFinishWritingNodePayloadAMDX inst) => inst.ResultId;
    public OpFinishWritingNodePayloadAMDX(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFinishWritingNodePayloadAMDX, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFinishWritingNodePayloadAMDX(OpDataIndex odi) => new(odi);
    public static implicit operator OpFinishWritingNodePayloadAMDX(OpData data) => new(data);
}

public struct OpNodePayloadArrayLengthAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpNodePayloadArrayLengthAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpNodePayloadArrayLengthAMDX | (1 << 16);
    }

    public OpNodePayloadArrayLengthAMDX(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpNodePayloadArrayLengthAMDX(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadArray
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpNodePayloadArrayLengthAMDX inst) => inst.ResultId;
    public OpNodePayloadArrayLengthAMDX(int resultType, int resultId, int payloadArray)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        PayloadArray = payloadArray;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpNodePayloadArrayLengthAMDX, ResultType, ResultId, PayloadArray];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payloadArray":
                    PayloadArray = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpNodePayloadArrayLengthAMDX(OpDataIndex odi) => new(odi);
    public static implicit operator OpNodePayloadArrayLengthAMDX(OpData data) => new(data);
}

public struct OpIsNodePayloadValidAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsNodePayloadValidAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsNodePayloadValidAMDX | (1 << 16);
    }

    public OpIsNodePayloadValidAMDX(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIsNodePayloadValidAMDX(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NodeIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIsNodePayloadValidAMDX inst) => inst.ResultId;
    public OpIsNodePayloadValidAMDX(int resultType, int resultId, int payloadType, int nodeIndex)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        PayloadType = payloadType;
        NodeIndex = nodeIndex;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsNodePayloadValidAMDX, ResultType, ResultId, PayloadType, NodeIndex];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payloadType":
                    PayloadType = o.ToLiteral<int>();
                    break;
                case "nodeIndex":
                    NodeIndex = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpIsNodePayloadValidAMDX(OpDataIndex odi) => new(odi);
    public static implicit operator OpIsNodePayloadValidAMDX(OpData data) => new(data);
}

public struct OpConstantStringAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantStringAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantStringAMDX | (1 << 16);
    }

    public OpConstantStringAMDX(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConstantStringAMDX(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string LiteralString
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantStringAMDX inst) => inst.ResultId;
    public OpConstantStringAMDX(int resultId, string literalString)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        LiteralString = literalString;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantStringAMDX, ResultId, ..LiteralString.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "literalString":
                    LiteralString = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpConstantStringAMDX(OpDataIndex odi) => new(odi);
    public static implicit operator OpConstantStringAMDX(OpData data) => new(data);
}

public struct OpSpecConstantStringAMDX : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantStringAMDX()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantStringAMDX | (1 << 16);
    }

    public OpSpecConstantStringAMDX(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSpecConstantStringAMDX(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string LiteralString
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSpecConstantStringAMDX inst) => inst.ResultId;
    public OpSpecConstantStringAMDX(int resultId, string literalString)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        LiteralString = literalString;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantStringAMDX, ResultId, ..LiteralString.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "literalString":
                    LiteralString = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpSpecConstantStringAMDX(OpDataIndex odi) => new(odi);
    public static implicit operator OpSpecConstantStringAMDX(OpData data) => new(data);
}

public struct OpGroupNonUniformQuadAllKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformQuadAllKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformQuadAllKHR | (1 << 16);
    }

    public OpGroupNonUniformQuadAllKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformQuadAllKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformQuadAllKHR inst) => inst.ResultId;
    public OpGroupNonUniformQuadAllKHR(int resultType, int resultId, int predicate)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformQuadAllKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformQuadAllKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformQuadAllKHR(OpData data) => new(data);
}

public struct OpGroupNonUniformQuadAnyKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformQuadAnyKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformQuadAnyKHR | (1 << 16);
    }

    public OpGroupNonUniformQuadAnyKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformQuadAnyKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Predicate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformQuadAnyKHR inst) => inst.ResultId;
    public OpGroupNonUniformQuadAnyKHR(int resultType, int resultId, int predicate)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Predicate = predicate;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformQuadAnyKHR, ResultType, ResultId, Predicate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "predicate":
                    Predicate = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformQuadAnyKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformQuadAnyKHR(OpData data) => new(data);
}

public struct OpHitObjectRecordHitMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordHitMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordHitMotionNV | (1 << 16);
    }

    public OpHitObjectRecordHitMotionNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectRecordHitMotionNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CurrentTime
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObjectAttributes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordHitMotionNV(int hitObject, int accelerationStructure, int instanceId, int primitiveId, int geometryIndex, int hitKind, int sBTRecordOffset, int sBTRecordStride, int origin, int tMin, int direction, int tMax, int currentTime, int hitObjectAttributes)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        InstanceId = instanceId;
        PrimitiveId = primitiveId;
        GeometryIndex = geometryIndex;
        HitKind = hitKind;
        SBTRecordOffset = sBTRecordOffset;
        SBTRecordStride = sBTRecordStride;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        CurrentTime = currentTime;
        HitObjectAttributes = hitObjectAttributes;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordHitMotionNV, HitObject, AccelerationStructure, InstanceId, PrimitiveId, GeometryIndex, HitKind, SBTRecordOffset, SBTRecordStride, Origin, TMin, Direction, TMax, CurrentTime, HitObjectAttributes];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "accelerationStructure":
                    AccelerationStructure = o.ToLiteral<int>();
                    break;
                case "instanceId":
                    InstanceId = o.ToLiteral<int>();
                    break;
                case "primitiveId":
                    PrimitiveId = o.ToLiteral<int>();
                    break;
                case "geometryIndex":
                    GeometryIndex = o.ToLiteral<int>();
                    break;
                case "hitKind":
                    HitKind = o.ToLiteral<int>();
                    break;
                case "sBTRecordOffset":
                    SBTRecordOffset = o.ToLiteral<int>();
                    break;
                case "sBTRecordStride":
                    SBTRecordStride = o.ToLiteral<int>();
                    break;
                case "origin":
                    Origin = o.ToLiteral<int>();
                    break;
                case "tMin":
                    TMin = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "tMax":
                    TMax = o.ToLiteral<int>();
                    break;
                case "currentTime":
                    CurrentTime = o.ToLiteral<int>();
                    break;
                case "hitObjectAttributes":
                    HitObjectAttributes = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectRecordHitMotionNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectRecordHitMotionNV(OpData data) => new(data);
}

public struct OpHitObjectRecordHitWithIndexMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordHitWithIndexMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordHitWithIndexMotionNV | (1 << 16);
    }

    public OpHitObjectRecordHitWithIndexMotionNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectRecordHitWithIndexMotionNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CurrentTime
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObjectAttributes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordHitWithIndexMotionNV(int hitObject, int accelerationStructure, int instanceId, int primitiveId, int geometryIndex, int hitKind, int sBTRecordIndex, int origin, int tMin, int direction, int tMax, int currentTime, int hitObjectAttributes)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        InstanceId = instanceId;
        PrimitiveId = primitiveId;
        GeometryIndex = geometryIndex;
        HitKind = hitKind;
        SBTRecordIndex = sBTRecordIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        CurrentTime = currentTime;
        HitObjectAttributes = hitObjectAttributes;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordHitWithIndexMotionNV, HitObject, AccelerationStructure, InstanceId, PrimitiveId, GeometryIndex, HitKind, SBTRecordIndex, Origin, TMin, Direction, TMax, CurrentTime, HitObjectAttributes];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "accelerationStructure":
                    AccelerationStructure = o.ToLiteral<int>();
                    break;
                case "instanceId":
                    InstanceId = o.ToLiteral<int>();
                    break;
                case "primitiveId":
                    PrimitiveId = o.ToLiteral<int>();
                    break;
                case "geometryIndex":
                    GeometryIndex = o.ToLiteral<int>();
                    break;
                case "hitKind":
                    HitKind = o.ToLiteral<int>();
                    break;
                case "sBTRecordIndex":
                    SBTRecordIndex = o.ToLiteral<int>();
                    break;
                case "origin":
                    Origin = o.ToLiteral<int>();
                    break;
                case "tMin":
                    TMin = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "tMax":
                    TMax = o.ToLiteral<int>();
                    break;
                case "currentTime":
                    CurrentTime = o.ToLiteral<int>();
                    break;
                case "hitObjectAttributes":
                    HitObjectAttributes = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectRecordHitWithIndexMotionNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectRecordHitWithIndexMotionNV(OpData data) => new(data);
}

public struct OpHitObjectRecordMissMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordMissMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordMissMotionNV | (1 << 16);
    }

    public OpHitObjectRecordMissMotionNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectRecordMissMotionNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CurrentTime
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordMissMotionNV(int hitObject, int sBTIndex, int origin, int tMin, int direction, int tMax, int currentTime)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        HitObject = hitObject;
        SBTIndex = sBTIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        CurrentTime = currentTime;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordMissMotionNV, HitObject, SBTIndex, Origin, TMin, Direction, TMax, CurrentTime];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "sBTIndex":
                    SBTIndex = o.ToLiteral<int>();
                    break;
                case "origin":
                    Origin = o.ToLiteral<int>();
                    break;
                case "tMin":
                    TMin = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "tMax":
                    TMax = o.ToLiteral<int>();
                    break;
                case "currentTime":
                    CurrentTime = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectRecordMissMotionNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectRecordMissMotionNV(OpData data) => new(data);
}

public struct OpHitObjectGetWorldToObjectNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetWorldToObjectNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetWorldToObjectNV | (1 << 16);
    }

    public OpHitObjectGetWorldToObjectNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetWorldToObjectNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetWorldToObjectNV inst) => inst.ResultId;
    public OpHitObjectGetWorldToObjectNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetWorldToObjectNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetWorldToObjectNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetWorldToObjectNV(OpData data) => new(data);
}

public struct OpHitObjectGetObjectToWorldNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetObjectToWorldNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetObjectToWorldNV | (1 << 16);
    }

    public OpHitObjectGetObjectToWorldNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetObjectToWorldNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetObjectToWorldNV inst) => inst.ResultId;
    public OpHitObjectGetObjectToWorldNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetObjectToWorldNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetObjectToWorldNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetObjectToWorldNV(OpData data) => new(data);
}

public struct OpHitObjectGetObjectRayDirectionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetObjectRayDirectionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetObjectRayDirectionNV | (1 << 16);
    }

    public OpHitObjectGetObjectRayDirectionNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetObjectRayDirectionNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetObjectRayDirectionNV inst) => inst.ResultId;
    public OpHitObjectGetObjectRayDirectionNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetObjectRayDirectionNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetObjectRayDirectionNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetObjectRayDirectionNV(OpData data) => new(data);
}

public struct OpHitObjectGetObjectRayOriginNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetObjectRayOriginNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetObjectRayOriginNV | (1 << 16);
    }

    public OpHitObjectGetObjectRayOriginNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetObjectRayOriginNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetObjectRayOriginNV inst) => inst.ResultId;
    public OpHitObjectGetObjectRayOriginNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetObjectRayOriginNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetObjectRayOriginNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetObjectRayOriginNV(OpData data) => new(data);
}

public struct OpHitObjectTraceRayMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectTraceRayMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectTraceRayMotionNV | (1 << 16);
    }

    public OpHitObjectTraceRayMotionNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectTraceRayMotionNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Cullmask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Time
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectTraceRayMotionNV(int hitObject, int accelerationStructure, int rayFlags, int cullmask, int sBTRecordOffset, int sBTRecordStride, int missIndex, int origin, int tMin, int direction, int tMax, int time, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        RayFlags = rayFlags;
        Cullmask = cullmask;
        SBTRecordOffset = sBTRecordOffset;
        SBTRecordStride = sBTRecordStride;
        MissIndex = missIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        Time = time;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectTraceRayMotionNV, HitObject, AccelerationStructure, RayFlags, Cullmask, SBTRecordOffset, SBTRecordStride, MissIndex, Origin, TMin, Direction, TMax, Time, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "accelerationStructure":
                    AccelerationStructure = o.ToLiteral<int>();
                    break;
                case "rayFlags":
                    RayFlags = o.ToLiteral<int>();
                    break;
                case "cullmask":
                    Cullmask = o.ToLiteral<int>();
                    break;
                case "sBTRecordOffset":
                    SBTRecordOffset = o.ToLiteral<int>();
                    break;
                case "sBTRecordStride":
                    SBTRecordStride = o.ToLiteral<int>();
                    break;
                case "missIndex":
                    MissIndex = o.ToLiteral<int>();
                    break;
                case "origin":
                    Origin = o.ToLiteral<int>();
                    break;
                case "tMin":
                    TMin = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "tMax":
                    TMax = o.ToLiteral<int>();
                    break;
                case "time":
                    Time = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectTraceRayMotionNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectTraceRayMotionNV(OpData data) => new(data);
}

public struct OpHitObjectGetShaderRecordBufferHandleNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetShaderRecordBufferHandleNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetShaderRecordBufferHandleNV | (1 << 16);
    }

    public OpHitObjectGetShaderRecordBufferHandleNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetShaderRecordBufferHandleNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetShaderRecordBufferHandleNV inst) => inst.ResultId;
    public OpHitObjectGetShaderRecordBufferHandleNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetShaderRecordBufferHandleNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetShaderRecordBufferHandleNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetShaderRecordBufferHandleNV(OpData data) => new(data);
}

public struct OpHitObjectGetShaderBindingTableRecordIndexNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetShaderBindingTableRecordIndexNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetShaderBindingTableRecordIndexNV | (1 << 16);
    }

    public OpHitObjectGetShaderBindingTableRecordIndexNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetShaderBindingTableRecordIndexNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetShaderBindingTableRecordIndexNV inst) => inst.ResultId;
    public OpHitObjectGetShaderBindingTableRecordIndexNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetShaderBindingTableRecordIndexNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetShaderBindingTableRecordIndexNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetShaderBindingTableRecordIndexNV(OpData data) => new(data);
}

public struct OpHitObjectRecordEmptyNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordEmptyNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordEmptyNV | (1 << 16);
    }

    public OpHitObjectRecordEmptyNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectRecordEmptyNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordEmptyNV(int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordEmptyNV, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectRecordEmptyNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectRecordEmptyNV(OpData data) => new(data);
}

public struct OpHitObjectTraceRayNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectTraceRayNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectTraceRayNV | (1 << 16);
    }

    public OpHitObjectTraceRayNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectTraceRayNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Cullmask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectTraceRayNV(int hitObject, int accelerationStructure, int rayFlags, int cullmask, int sBTRecordOffset, int sBTRecordStride, int missIndex, int origin, int tMin, int direction, int tMax, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        RayFlags = rayFlags;
        Cullmask = cullmask;
        SBTRecordOffset = sBTRecordOffset;
        SBTRecordStride = sBTRecordStride;
        MissIndex = missIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectTraceRayNV, HitObject, AccelerationStructure, RayFlags, Cullmask, SBTRecordOffset, SBTRecordStride, MissIndex, Origin, TMin, Direction, TMax, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "accelerationStructure":
                    AccelerationStructure = o.ToLiteral<int>();
                    break;
                case "rayFlags":
                    RayFlags = o.ToLiteral<int>();
                    break;
                case "cullmask":
                    Cullmask = o.ToLiteral<int>();
                    break;
                case "sBTRecordOffset":
                    SBTRecordOffset = o.ToLiteral<int>();
                    break;
                case "sBTRecordStride":
                    SBTRecordStride = o.ToLiteral<int>();
                    break;
                case "missIndex":
                    MissIndex = o.ToLiteral<int>();
                    break;
                case "origin":
                    Origin = o.ToLiteral<int>();
                    break;
                case "tMin":
                    TMin = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "tMax":
                    TMax = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectTraceRayNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectTraceRayNV(OpData data) => new(data);
}

public struct OpHitObjectRecordHitNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordHitNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordHitNV | (1 << 16);
    }

    public OpHitObjectRecordHitNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectRecordHitNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObjectAttributes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordHitNV(int hitObject, int accelerationStructure, int instanceId, int primitiveId, int geometryIndex, int hitKind, int sBTRecordOffset, int sBTRecordStride, int origin, int tMin, int direction, int tMax, int hitObjectAttributes)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        InstanceId = instanceId;
        PrimitiveId = primitiveId;
        GeometryIndex = geometryIndex;
        HitKind = hitKind;
        SBTRecordOffset = sBTRecordOffset;
        SBTRecordStride = sBTRecordStride;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        HitObjectAttributes = hitObjectAttributes;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordHitNV, HitObject, AccelerationStructure, InstanceId, PrimitiveId, GeometryIndex, HitKind, SBTRecordOffset, SBTRecordStride, Origin, TMin, Direction, TMax, HitObjectAttributes];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "accelerationStructure":
                    AccelerationStructure = o.ToLiteral<int>();
                    break;
                case "instanceId":
                    InstanceId = o.ToLiteral<int>();
                    break;
                case "primitiveId":
                    PrimitiveId = o.ToLiteral<int>();
                    break;
                case "geometryIndex":
                    GeometryIndex = o.ToLiteral<int>();
                    break;
                case "hitKind":
                    HitKind = o.ToLiteral<int>();
                    break;
                case "sBTRecordOffset":
                    SBTRecordOffset = o.ToLiteral<int>();
                    break;
                case "sBTRecordStride":
                    SBTRecordStride = o.ToLiteral<int>();
                    break;
                case "origin":
                    Origin = o.ToLiteral<int>();
                    break;
                case "tMin":
                    TMin = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "tMax":
                    TMax = o.ToLiteral<int>();
                    break;
                case "hitObjectAttributes":
                    HitObjectAttributes = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectRecordHitNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectRecordHitNV(OpData data) => new(data);
}

public struct OpHitObjectRecordHitWithIndexNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordHitWithIndexNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordHitWithIndexNV | (1 << 16);
    }

    public OpHitObjectRecordHitWithIndexNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectRecordHitWithIndexNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AccelerationStructure
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTRecordIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObjectAttributes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordHitWithIndexNV(int hitObject, int accelerationStructure, int instanceId, int primitiveId, int geometryIndex, int hitKind, int sBTRecordIndex, int origin, int tMin, int direction, int tMax, int hitObjectAttributes)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        HitObject = hitObject;
        AccelerationStructure = accelerationStructure;
        InstanceId = instanceId;
        PrimitiveId = primitiveId;
        GeometryIndex = geometryIndex;
        HitKind = hitKind;
        SBTRecordIndex = sBTRecordIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
        HitObjectAttributes = hitObjectAttributes;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordHitWithIndexNV, HitObject, AccelerationStructure, InstanceId, PrimitiveId, GeometryIndex, HitKind, SBTRecordIndex, Origin, TMin, Direction, TMax, HitObjectAttributes];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "accelerationStructure":
                    AccelerationStructure = o.ToLiteral<int>();
                    break;
                case "instanceId":
                    InstanceId = o.ToLiteral<int>();
                    break;
                case "primitiveId":
                    PrimitiveId = o.ToLiteral<int>();
                    break;
                case "geometryIndex":
                    GeometryIndex = o.ToLiteral<int>();
                    break;
                case "hitKind":
                    HitKind = o.ToLiteral<int>();
                    break;
                case "sBTRecordIndex":
                    SBTRecordIndex = o.ToLiteral<int>();
                    break;
                case "origin":
                    Origin = o.ToLiteral<int>();
                    break;
                case "tMin":
                    TMin = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "tMax":
                    TMax = o.ToLiteral<int>();
                    break;
                case "hitObjectAttributes":
                    HitObjectAttributes = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectRecordHitWithIndexNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectRecordHitWithIndexNV(OpData data) => new(data);
}

public struct OpHitObjectRecordMissNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectRecordMissNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectRecordMissNV | (1 << 16);
    }

    public OpHitObjectRecordMissNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectRecordMissNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Origin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TMax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectRecordMissNV(int hitObject, int sBTIndex, int origin, int tMin, int direction, int tMax)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        HitObject = hitObject;
        SBTIndex = sBTIndex;
        Origin = origin;
        TMin = tMin;
        Direction = direction;
        TMax = tMax;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectRecordMissNV, HitObject, SBTIndex, Origin, TMin, Direction, TMax];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "sBTIndex":
                    SBTIndex = o.ToLiteral<int>();
                    break;
                case "origin":
                    Origin = o.ToLiteral<int>();
                    break;
                case "tMin":
                    TMin = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "tMax":
                    TMax = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectRecordMissNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectRecordMissNV(OpData data) => new(data);
}

public struct OpHitObjectExecuteShaderNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectExecuteShaderNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectExecuteShaderNV | (1 << 16);
    }

    public OpHitObjectExecuteShaderNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectExecuteShaderNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectExecuteShaderNV(int hitObject, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        HitObject = hitObject;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectExecuteShaderNV, HitObject, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectExecuteShaderNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectExecuteShaderNV(OpData data) => new(data);
}

public struct OpHitObjectGetCurrentTimeNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetCurrentTimeNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetCurrentTimeNV | (1 << 16);
    }

    public OpHitObjectGetCurrentTimeNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetCurrentTimeNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetCurrentTimeNV inst) => inst.ResultId;
    public OpHitObjectGetCurrentTimeNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetCurrentTimeNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetCurrentTimeNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetCurrentTimeNV(OpData data) => new(data);
}

public struct OpHitObjectGetAttributesNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetAttributesNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetAttributesNV | (1 << 16);
    }

    public OpHitObjectGetAttributesNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetAttributesNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObjectAttribute
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpHitObjectGetAttributesNV(int hitObject, int hitObjectAttribute)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        HitObject = hitObject;
        HitObjectAttribute = hitObjectAttribute;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetAttributesNV, HitObject, HitObjectAttribute];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "hitObjectAttribute":
                    HitObjectAttribute = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetAttributesNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetAttributesNV(OpData data) => new(data);
}

public struct OpHitObjectGetHitKindNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetHitKindNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetHitKindNV | (1 << 16);
    }

    public OpHitObjectGetHitKindNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetHitKindNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetHitKindNV inst) => inst.ResultId;
    public OpHitObjectGetHitKindNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetHitKindNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetHitKindNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetHitKindNV(OpData data) => new(data);
}

public struct OpHitObjectGetPrimitiveIndexNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetPrimitiveIndexNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetPrimitiveIndexNV | (1 << 16);
    }

    public OpHitObjectGetPrimitiveIndexNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetPrimitiveIndexNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetPrimitiveIndexNV inst) => inst.ResultId;
    public OpHitObjectGetPrimitiveIndexNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetPrimitiveIndexNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetPrimitiveIndexNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetPrimitiveIndexNV(OpData data) => new(data);
}

public struct OpHitObjectGetGeometryIndexNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetGeometryIndexNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetGeometryIndexNV | (1 << 16);
    }

    public OpHitObjectGetGeometryIndexNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetGeometryIndexNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetGeometryIndexNV inst) => inst.ResultId;
    public OpHitObjectGetGeometryIndexNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetGeometryIndexNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetGeometryIndexNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetGeometryIndexNV(OpData data) => new(data);
}

public struct OpHitObjectGetInstanceIdNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetInstanceIdNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetInstanceIdNV | (1 << 16);
    }

    public OpHitObjectGetInstanceIdNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetInstanceIdNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetInstanceIdNV inst) => inst.ResultId;
    public OpHitObjectGetInstanceIdNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetInstanceIdNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetInstanceIdNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetInstanceIdNV(OpData data) => new(data);
}

public struct OpHitObjectGetInstanceCustomIndexNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetInstanceCustomIndexNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetInstanceCustomIndexNV | (1 << 16);
    }

    public OpHitObjectGetInstanceCustomIndexNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetInstanceCustomIndexNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetInstanceCustomIndexNV inst) => inst.ResultId;
    public OpHitObjectGetInstanceCustomIndexNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetInstanceCustomIndexNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetInstanceCustomIndexNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetInstanceCustomIndexNV(OpData data) => new(data);
}

public struct OpHitObjectGetWorldRayDirectionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetWorldRayDirectionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetWorldRayDirectionNV | (1 << 16);
    }

    public OpHitObjectGetWorldRayDirectionNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetWorldRayDirectionNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetWorldRayDirectionNV inst) => inst.ResultId;
    public OpHitObjectGetWorldRayDirectionNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetWorldRayDirectionNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetWorldRayDirectionNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetWorldRayDirectionNV(OpData data) => new(data);
}

public struct OpHitObjectGetWorldRayOriginNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetWorldRayOriginNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetWorldRayOriginNV | (1 << 16);
    }

    public OpHitObjectGetWorldRayOriginNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetWorldRayOriginNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetWorldRayOriginNV inst) => inst.ResultId;
    public OpHitObjectGetWorldRayOriginNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetWorldRayOriginNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetWorldRayOriginNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetWorldRayOriginNV(OpData data) => new(data);
}

public struct OpHitObjectGetRayTMaxNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetRayTMaxNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetRayTMaxNV | (1 << 16);
    }

    public OpHitObjectGetRayTMaxNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetRayTMaxNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetRayTMaxNV inst) => inst.ResultId;
    public OpHitObjectGetRayTMaxNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetRayTMaxNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetRayTMaxNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetRayTMaxNV(OpData data) => new(data);
}

public struct OpHitObjectGetRayTMinNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectGetRayTMinNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectGetRayTMinNV | (1 << 16);
    }

    public OpHitObjectGetRayTMinNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectGetRayTMinNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectGetRayTMinNV inst) => inst.ResultId;
    public OpHitObjectGetRayTMinNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectGetRayTMinNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectGetRayTMinNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectGetRayTMinNV(OpData data) => new(data);
}

public struct OpHitObjectIsEmptyNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectIsEmptyNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectIsEmptyNV | (1 << 16);
    }

    public OpHitObjectIsEmptyNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectIsEmptyNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectIsEmptyNV inst) => inst.ResultId;
    public OpHitObjectIsEmptyNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectIsEmptyNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectIsEmptyNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectIsEmptyNV(OpData data) => new(data);
}

public struct OpHitObjectIsHitNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectIsHitNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectIsHitNV | (1 << 16);
    }

    public OpHitObjectIsHitNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectIsHitNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectIsHitNV inst) => inst.ResultId;
    public OpHitObjectIsHitNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectIsHitNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectIsHitNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectIsHitNV(OpData data) => new(data);
}

public struct OpHitObjectIsMissNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpHitObjectIsMissNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpHitObjectIsMissNV | (1 << 16);
    }

    public OpHitObjectIsMissNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpHitObjectIsMissNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpHitObjectIsMissNV inst) => inst.ResultId;
    public OpHitObjectIsMissNV(int resultType, int resultId, int hitObject)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        HitObject = hitObject;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpHitObjectIsMissNV, ResultType, ResultId, HitObject];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpHitObjectIsMissNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpHitObjectIsMissNV(OpData data) => new(data);
}

public struct OpReorderThreadWithHitObjectNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReorderThreadWithHitObjectNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReorderThreadWithHitObjectNV | (1 << 16);
    }

    public OpReorderThreadWithHitObjectNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpReorderThreadWithHitObjectNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int HitObject
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Hint
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Bits
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReorderThreadWithHitObjectNV(int hitObject, int? hint, int? bits)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        HitObject = hitObject;
        Hint = hint;
        Bits = bits;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReorderThreadWithHitObjectNV, HitObject, ..(Hint is null ? (Span<int>)[] : [Hint.Value]), ..(Bits is null ? (Span<int>)[] : [Bits.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hitObject":
                    HitObject = o.ToLiteral<int>();
                    break;
                case "hint":
                    if (o.Words.Length > 0)
                        Hint = o.ToLiteral<int?>();
                    break;
                case "bits":
                    if (o.Words.Length > 0)
                        Bits = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpReorderThreadWithHitObjectNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpReorderThreadWithHitObjectNV(OpData data) => new(data);
}

public struct OpReorderThreadWithHintNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReorderThreadWithHintNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReorderThreadWithHintNV | (1 << 16);
    }

    public OpReorderThreadWithHintNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpReorderThreadWithHintNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Hint
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Bits
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpReorderThreadWithHintNV(int hint, int bits)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Hint = hint;
        Bits = bits;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReorderThreadWithHintNV, Hint, Bits];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "hint":
                    Hint = o.ToLiteral<int>();
                    break;
                case "bits":
                    Bits = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpReorderThreadWithHintNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpReorderThreadWithHintNV(OpData data) => new(data);
}

public struct OpTypeHitObjectNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeHitObjectNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeHitObjectNV | (1 << 16);
    }

    public OpTypeHitObjectNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeHitObjectNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeHitObjectNV inst) => inst.ResultId;
    public OpTypeHitObjectNV(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeHitObjectNV, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeHitObjectNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeHitObjectNV(OpData data) => new(data);
}

public struct OpImageSampleFootprintNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpImageSampleFootprintNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpImageSampleFootprintNV | (1 << 16);
    }

    public OpImageSampleFootprintNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpImageSampleFootprintNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SampledImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Granularity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coarse
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<ImageOperandsMask>? Imageoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpImageSampleFootprintNV inst) => inst.ResultId;
    public OpImageSampleFootprintNV(int resultType, int resultId, int sampledImage, int coordinate, int granularity, int coarse, ParameterizedFlag<ImageOperandsMask>? imageoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SampledImage = sampledImage;
        Coordinate = coordinate;
        Granularity = granularity;
        Coarse = coarse;
        Imageoperands = imageoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpImageSampleFootprintNV, ResultType, ResultId, SampledImage, Coordinate, Granularity, Coarse, ..(Imageoperands is null ? (Span<int>)[] : [(int)Imageoperands.Value.Value, ..Imageoperands.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sampledImage":
                    SampledImage = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "granularity":
                    Granularity = o.ToLiteral<int>();
                    break;
                case "coarse":
                    Coarse = o.ToLiteral<int>();
                    break;
                case "imageoperands":
                    if (o.Words.Length > 0)
                        Imageoperands = o.ToEnum<ImageOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpImageSampleFootprintNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpImageSampleFootprintNV(OpData data) => new(data);
}

public struct OpCooperativeMatrixConvertNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixConvertNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixConvertNV | (1 << 16);
    }

    public OpCooperativeMatrixConvertNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCooperativeMatrixConvertNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixConvertNV inst) => inst.ResultId;
    public OpCooperativeMatrixConvertNV(int resultType, int resultId, int matrix)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixConvertNV, ResultType, ResultId, Matrix];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "matrix":
                    Matrix = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixConvertNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpCooperativeMatrixConvertNV(OpData data) => new(data);
}

public struct OpEmitMeshTasksEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEmitMeshTasksEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEmitMeshTasksEXT | (1 << 16);
    }

    public OpEmitMeshTasksEXT(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpEmitMeshTasksEXT(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int GroupCountX
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GroupCountY
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GroupCountZ
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpEmitMeshTasksEXT(int groupCountX, int groupCountY, int groupCountZ, int? payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        GroupCountX = groupCountX;
        GroupCountY = groupCountY;
        GroupCountZ = groupCountZ;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEmitMeshTasksEXT, GroupCountX, GroupCountY, GroupCountZ, ..(Payload is null ? (Span<int>)[] : [Payload.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "groupCountX":
                    GroupCountX = o.ToLiteral<int>();
                    break;
                case "groupCountY":
                    GroupCountY = o.ToLiteral<int>();
                    break;
                case "groupCountZ":
                    GroupCountZ = o.ToLiteral<int>();
                    break;
                case "payload":
                    if (o.Words.Length > 0)
                        Payload = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpEmitMeshTasksEXT(OpDataIndex odi) => new(odi);
    public static implicit operator OpEmitMeshTasksEXT(OpData data) => new(data);
}

public struct OpSetMeshOutputsEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSetMeshOutputsEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSetMeshOutputsEXT | (1 << 16);
    }

    public OpSetMeshOutputsEXT(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSetMeshOutputsEXT(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int VertexCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSetMeshOutputsEXT(int vertexCount, int primitiveCount)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        VertexCount = vertexCount;
        PrimitiveCount = primitiveCount;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSetMeshOutputsEXT, VertexCount, PrimitiveCount];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "vertexCount":
                    VertexCount = o.ToLiteral<int>();
                    break;
                case "primitiveCount":
                    PrimitiveCount = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSetMeshOutputsEXT(OpDataIndex odi) => new(odi);
    public static implicit operator OpSetMeshOutputsEXT(OpData data) => new(data);
}

public struct OpGroupNonUniformPartitionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupNonUniformPartitionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupNonUniformPartitionNV | (1 << 16);
    }

    public OpGroupNonUniformPartitionNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupNonUniformPartitionNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupNonUniformPartitionNV inst) => inst.ResultId;
    public OpGroupNonUniformPartitionNV(int resultType, int resultId, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupNonUniformPartitionNV, ResultType, ResultId, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupNonUniformPartitionNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupNonUniformPartitionNV(OpData data) => new(data);
}

public struct OpWritePackedPrimitiveIndices4x8NV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpWritePackedPrimitiveIndices4x8NV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpWritePackedPrimitiveIndices4x8NV | (1 << 16);
    }

    public OpWritePackedPrimitiveIndices4x8NV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpWritePackedPrimitiveIndices4x8NV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int IndexOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedIndices
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpWritePackedPrimitiveIndices4x8NV(int indexOffset, int packedIndices)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        IndexOffset = indexOffset;
        PackedIndices = packedIndices;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpWritePackedPrimitiveIndices4x8NV, IndexOffset, PackedIndices];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "indexOffset":
                    IndexOffset = o.ToLiteral<int>();
                    break;
                case "packedIndices":
                    PackedIndices = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpWritePackedPrimitiveIndices4x8NV(OpDataIndex odi) => new(odi);
    public static implicit operator OpWritePackedPrimitiveIndices4x8NV(OpData data) => new(data);
}

public struct OpFetchMicroTriangleVertexPositionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFetchMicroTriangleVertexPositionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFetchMicroTriangleVertexPositionNV | (1 << 16);
    }

    public OpFetchMicroTriangleVertexPositionNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFetchMicroTriangleVertexPositionNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Barycentric
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFetchMicroTriangleVertexPositionNV inst) => inst.ResultId;
    public OpFetchMicroTriangleVertexPositionNV(int resultType, int resultId, int accel, int instanceId, int geometryIndex, int primitiveIndex, int barycentric)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Accel = accel;
        InstanceId = instanceId;
        GeometryIndex = geometryIndex;
        PrimitiveIndex = primitiveIndex;
        Barycentric = barycentric;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFetchMicroTriangleVertexPositionNV, ResultType, ResultId, Accel, InstanceId, GeometryIndex, PrimitiveIndex, Barycentric];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "accel":
                    Accel = o.ToLiteral<int>();
                    break;
                case "instanceId":
                    InstanceId = o.ToLiteral<int>();
                    break;
                case "geometryIndex":
                    GeometryIndex = o.ToLiteral<int>();
                    break;
                case "primitiveIndex":
                    PrimitiveIndex = o.ToLiteral<int>();
                    break;
                case "barycentric":
                    Barycentric = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFetchMicroTriangleVertexPositionNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpFetchMicroTriangleVertexPositionNV(OpData data) => new(data);
}

public struct OpFetchMicroTriangleVertexBarycentricNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFetchMicroTriangleVertexBarycentricNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFetchMicroTriangleVertexBarycentricNV | (1 << 16);
    }

    public OpFetchMicroTriangleVertexBarycentricNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFetchMicroTriangleVertexBarycentricNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InstanceId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int GeometryIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PrimitiveIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Barycentric
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFetchMicroTriangleVertexBarycentricNV inst) => inst.ResultId;
    public OpFetchMicroTriangleVertexBarycentricNV(int resultType, int resultId, int accel, int instanceId, int geometryIndex, int primitiveIndex, int barycentric)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Accel = accel;
        InstanceId = instanceId;
        GeometryIndex = geometryIndex;
        PrimitiveIndex = primitiveIndex;
        Barycentric = barycentric;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFetchMicroTriangleVertexBarycentricNV, ResultType, ResultId, Accel, InstanceId, GeometryIndex, PrimitiveIndex, Barycentric];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "accel":
                    Accel = o.ToLiteral<int>();
                    break;
                case "instanceId":
                    InstanceId = o.ToLiteral<int>();
                    break;
                case "geometryIndex":
                    GeometryIndex = o.ToLiteral<int>();
                    break;
                case "primitiveIndex":
                    PrimitiveIndex = o.ToLiteral<int>();
                    break;
                case "barycentric":
                    Barycentric = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFetchMicroTriangleVertexBarycentricNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpFetchMicroTriangleVertexBarycentricNV(OpData data) => new(data);
}

public struct OpReportIntersectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReportIntersectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReportIntersectionKHR | (1 << 16);
    }

    public OpReportIntersectionKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpReportIntersectionKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Hit
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HitKind
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpReportIntersectionKHR inst) => inst.ResultId;
    public OpReportIntersectionKHR(int resultType, int resultId, int hit, int hitKind)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Hit = hit;
        HitKind = hitKind;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReportIntersectionKHR, ResultType, ResultId, Hit, HitKind];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "hit":
                    Hit = o.ToLiteral<int>();
                    break;
                case "hitKind":
                    HitKind = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpReportIntersectionKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpReportIntersectionKHR(OpData data) => new(data);
}

public struct OpIgnoreIntersectionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIgnoreIntersectionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIgnoreIntersectionNV | (1 << 16);
    }

    public OpIgnoreIntersectionNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIgnoreIntersectionNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIgnoreIntersectionNV, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpIgnoreIntersectionNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpIgnoreIntersectionNV(OpData data) => new(data);
}

public struct OpTerminateRayNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTerminateRayNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTerminateRayNV | (1 << 16);
    }

    public OpTerminateRayNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTerminateRayNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTerminateRayNV, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpTerminateRayNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpTerminateRayNV(OpData data) => new(data);
}

public struct OpTraceNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTraceNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTraceNV | (1 << 16);
    }

    public OpTraceNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTraceNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTraceNV(int accel, int rayFlags, int cullMask, int sBTOffset, int sBTStride, int missIndex, int rayOrigin, int rayTmin, int rayDirection, int rayTmax, int payloadId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        SBTOffset = sBTOffset;
        SBTStride = sBTStride;
        MissIndex = missIndex;
        RayOrigin = rayOrigin;
        RayTmin = rayTmin;
        RayDirection = rayDirection;
        RayTmax = rayTmax;
        PayloadId = payloadId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTraceNV, Accel, RayFlags, CullMask, SBTOffset, SBTStride, MissIndex, RayOrigin, RayTmin, RayDirection, RayTmax, PayloadId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "accel":
                    Accel = o.ToLiteral<int>();
                    break;
                case "rayFlags":
                    RayFlags = o.ToLiteral<int>();
                    break;
                case "cullMask":
                    CullMask = o.ToLiteral<int>();
                    break;
                case "sBTOffset":
                    SBTOffset = o.ToLiteral<int>();
                    break;
                case "sBTStride":
                    SBTStride = o.ToLiteral<int>();
                    break;
                case "missIndex":
                    MissIndex = o.ToLiteral<int>();
                    break;
                case "rayOrigin":
                    RayOrigin = o.ToLiteral<int>();
                    break;
                case "rayTmin":
                    RayTmin = o.ToLiteral<int>();
                    break;
                case "rayDirection":
                    RayDirection = o.ToLiteral<int>();
                    break;
                case "rayTmax":
                    RayTmax = o.ToLiteral<int>();
                    break;
                case "payloadId":
                    PayloadId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTraceNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpTraceNV(OpData data) => new(data);
}

public struct OpTraceMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTraceMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTraceMotionNV | (1 << 16);
    }

    public OpTraceMotionNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTraceMotionNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Time
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PayloadId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTraceMotionNV(int accel, int rayFlags, int cullMask, int sBTOffset, int sBTStride, int missIndex, int rayOrigin, int rayTmin, int rayDirection, int rayTmax, int time, int payloadId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        SBTOffset = sBTOffset;
        SBTStride = sBTStride;
        MissIndex = missIndex;
        RayOrigin = rayOrigin;
        RayTmin = rayTmin;
        RayDirection = rayDirection;
        RayTmax = rayTmax;
        Time = time;
        PayloadId = payloadId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTraceMotionNV, Accel, RayFlags, CullMask, SBTOffset, SBTStride, MissIndex, RayOrigin, RayTmin, RayDirection, RayTmax, Time, PayloadId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "accel":
                    Accel = o.ToLiteral<int>();
                    break;
                case "rayFlags":
                    RayFlags = o.ToLiteral<int>();
                    break;
                case "cullMask":
                    CullMask = o.ToLiteral<int>();
                    break;
                case "sBTOffset":
                    SBTOffset = o.ToLiteral<int>();
                    break;
                case "sBTStride":
                    SBTStride = o.ToLiteral<int>();
                    break;
                case "missIndex":
                    MissIndex = o.ToLiteral<int>();
                    break;
                case "rayOrigin":
                    RayOrigin = o.ToLiteral<int>();
                    break;
                case "rayTmin":
                    RayTmin = o.ToLiteral<int>();
                    break;
                case "rayDirection":
                    RayDirection = o.ToLiteral<int>();
                    break;
                case "rayTmax":
                    RayTmax = o.ToLiteral<int>();
                    break;
                case "time":
                    Time = o.ToLiteral<int>();
                    break;
                case "payloadId":
                    PayloadId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTraceMotionNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpTraceMotionNV(OpData data) => new(data);
}

public struct OpTraceRayMotionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTraceRayMotionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTraceRayMotionNV | (1 << 16);
    }

    public OpTraceRayMotionNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTraceRayMotionNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Accel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayFlags
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CullMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SBTStride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MissIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayOrigin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmin
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayDirection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayTmax
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Time
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTraceRayMotionNV(int accel, int rayFlags, int cullMask, int sBTOffset, int sBTStride, int missIndex, int rayOrigin, int rayTmin, int rayDirection, int rayTmax, int time, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Accel = accel;
        RayFlags = rayFlags;
        CullMask = cullMask;
        SBTOffset = sBTOffset;
        SBTStride = sBTStride;
        MissIndex = missIndex;
        RayOrigin = rayOrigin;
        RayTmin = rayTmin;
        RayDirection = rayDirection;
        RayTmax = rayTmax;
        Time = time;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTraceRayMotionNV, Accel, RayFlags, CullMask, SBTOffset, SBTStride, MissIndex, RayOrigin, RayTmin, RayDirection, RayTmax, Time, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "accel":
                    Accel = o.ToLiteral<int>();
                    break;
                case "rayFlags":
                    RayFlags = o.ToLiteral<int>();
                    break;
                case "cullMask":
                    CullMask = o.ToLiteral<int>();
                    break;
                case "sBTOffset":
                    SBTOffset = o.ToLiteral<int>();
                    break;
                case "sBTStride":
                    SBTStride = o.ToLiteral<int>();
                    break;
                case "missIndex":
                    MissIndex = o.ToLiteral<int>();
                    break;
                case "rayOrigin":
                    RayOrigin = o.ToLiteral<int>();
                    break;
                case "rayTmin":
                    RayTmin = o.ToLiteral<int>();
                    break;
                case "rayDirection":
                    RayDirection = o.ToLiteral<int>();
                    break;
                case "rayTmax":
                    RayTmax = o.ToLiteral<int>();
                    break;
                case "time":
                    Time = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTraceRayMotionNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpTraceRayMotionNV(OpData data) => new(data);
}

public struct OpRayQueryGetIntersectionTriangleVertexPositionsKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionTriangleVertexPositionsKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionTriangleVertexPositionsKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionTriangleVertexPositionsKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetIntersectionTriangleVertexPositionsKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionTriangleVertexPositionsKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionTriangleVertexPositionsKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionTriangleVertexPositionsKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionTriangleVertexPositionsKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetIntersectionTriangleVertexPositionsKHR(OpData data) => new(data);
}

public struct OpTypeAccelerationStructureKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAccelerationStructureKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAccelerationStructureKHR | (1 << 16);
    }

    public OpTypeAccelerationStructureKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeAccelerationStructureKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAccelerationStructureKHR inst) => inst.ResultId;
    public OpTypeAccelerationStructureKHR(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAccelerationStructureKHR, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeAccelerationStructureKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeAccelerationStructureKHR(OpData data) => new(data);
}

public struct OpExecuteCallableNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExecuteCallableNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExecuteCallableNV | (1 << 16);
    }

    public OpExecuteCallableNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpExecuteCallableNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int SBTIndex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CallableDataId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpExecuteCallableNV(int sBTIndex, int callableDataId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        SBTIndex = sBTIndex;
        CallableDataId = callableDataId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExecuteCallableNV, SBTIndex, CallableDataId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "sBTIndex":
                    SBTIndex = o.ToLiteral<int>();
                    break;
                case "callableDataId":
                    CallableDataId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpExecuteCallableNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpExecuteCallableNV(OpData data) => new(data);
}

public struct OpTypeCooperativeMatrixNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeCooperativeMatrixNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeCooperativeMatrixNV | (1 << 16);
    }

    public OpTypeCooperativeMatrixNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeCooperativeMatrixNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ComponentType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Rows
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Columns
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeCooperativeMatrixNV inst) => inst.ResultId;
    public OpTypeCooperativeMatrixNV(int resultId, int componentType, int execution, int rows, int columns)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        ComponentType = componentType;
        Execution = execution;
        Rows = rows;
        Columns = columns;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeCooperativeMatrixNV, ResultId, ComponentType, Execution, Rows, Columns];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "componentType":
                    ComponentType = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "rows":
                    Rows = o.ToLiteral<int>();
                    break;
                case "columns":
                    Columns = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeCooperativeMatrixNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeCooperativeMatrixNV(OpData data) => new(data);
}

public struct OpCooperativeMatrixLoadNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixLoadNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixLoadNV | (1 << 16);
    }

    public OpCooperativeMatrixLoadNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCooperativeMatrixLoadNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Stride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ColumnMajor
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<MemoryAccessMask>? Memoryaccess
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixLoadNV inst) => inst.ResultId;
    public OpCooperativeMatrixLoadNV(int resultType, int resultId, int pointer, int stride, int columnMajor, ParameterizedFlag<MemoryAccessMask>? memoryaccess)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Stride = stride;
        ColumnMajor = columnMajor;
        Memoryaccess = memoryaccess;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixLoadNV, ResultType, ResultId, Pointer, Stride, ColumnMajor, ..(Memoryaccess is null ? (Span<int>)[] : [(int)Memoryaccess.Value.Value, ..Memoryaccess.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "stride":
                    Stride = o.ToLiteral<int>();
                    break;
                case "columnMajor":
                    ColumnMajor = o.ToLiteral<int>();
                    break;
                case "memoryaccess":
                    if (o.Words.Length > 0)
                        Memoryaccess = o.ToEnum<MemoryAccessMask>();
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixLoadNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpCooperativeMatrixLoadNV(OpData data) => new(data);
}

public struct OpCooperativeMatrixStoreNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixStoreNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixStoreNV | (1 << 16);
    }

    public OpCooperativeMatrixStoreNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCooperativeMatrixStoreNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Stride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ColumnMajor
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<MemoryAccessMask>? Memoryaccess
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixStoreNV(int pointer, int objectId, int stride, int columnMajor, ParameterizedFlag<MemoryAccessMask>? memoryaccess)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Pointer = pointer;
        ObjectId = objectId;
        Stride = stride;
        ColumnMajor = columnMajor;
        Memoryaccess = memoryaccess;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixStoreNV, Pointer, ObjectId, Stride, ColumnMajor, ..(Memoryaccess is null ? (Span<int>)[] : [(int)Memoryaccess.Value.Value, ..Memoryaccess.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "objectId":
                    ObjectId = o.ToLiteral<int>();
                    break;
                case "stride":
                    Stride = o.ToLiteral<int>();
                    break;
                case "columnMajor":
                    ColumnMajor = o.ToLiteral<int>();
                    break;
                case "memoryaccess":
                    if (o.Words.Length > 0)
                        Memoryaccess = o.ToEnum<MemoryAccessMask>();
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixStoreNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpCooperativeMatrixStoreNV(OpData data) => new(data);
}

public struct OpCooperativeMatrixMulAddNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixMulAddNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixMulAddNV | (1 << 16);
    }

    public OpCooperativeMatrixMulAddNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCooperativeMatrixMulAddNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int C
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixMulAddNV inst) => inst.ResultId;
    public OpCooperativeMatrixMulAddNV(int resultType, int resultId, int a, int b, int c)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        B = b;
        C = c;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixMulAddNV, ResultType, ResultId, A, B, C];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "c":
                    C = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixMulAddNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpCooperativeMatrixMulAddNV(OpData data) => new(data);
}

public struct OpCooperativeMatrixLengthNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixLengthNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixLengthNV | (1 << 16);
    }

    public OpCooperativeMatrixLengthNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCooperativeMatrixLengthNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Type
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixLengthNV inst) => inst.ResultId;
    public OpCooperativeMatrixLengthNV(int resultType, int resultId, int type)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Type = type;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixLengthNV, ResultType, ResultId, Type];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "type":
                    Type = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixLengthNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpCooperativeMatrixLengthNV(OpData data) => new(data);
}

public struct OpBeginInvocationInterlockEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpBeginInvocationInterlockEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpBeginInvocationInterlockEXT | (1 << 16);
    }

    public OpBeginInvocationInterlockEXT(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpBeginInvocationInterlockEXT(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpBeginInvocationInterlockEXT, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpBeginInvocationInterlockEXT(OpDataIndex odi) => new(odi);
    public static implicit operator OpBeginInvocationInterlockEXT(OpData data) => new(data);
}

public struct OpEndInvocationInterlockEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpEndInvocationInterlockEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpEndInvocationInterlockEXT | (1 << 16);
    }

    public OpEndInvocationInterlockEXT(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpEndInvocationInterlockEXT(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpEndInvocationInterlockEXT, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpEndInvocationInterlockEXT(OpDataIndex odi) => new(odi);
    public static implicit operator OpEndInvocationInterlockEXT(OpData data) => new(data);
}

public struct OpCooperativeMatrixReduceNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixReduceNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixReduceNV | (1 << 16);
    }

    public OpCooperativeMatrixReduceNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCooperativeMatrixReduceNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public CooperativeMatrixReduceMask Reduce
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CombineFunc
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixReduceNV inst) => inst.ResultId;
    public OpCooperativeMatrixReduceNV(int resultType, int resultId, int matrix, CooperativeMatrixReduceMask reduce, int combineFunc)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        Reduce = reduce;
        CombineFunc = combineFunc;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixReduceNV, ResultType, ResultId, Matrix, (int)Reduce, CombineFunc];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "matrix":
                    Matrix = o.ToLiteral<int>();
                    break;
                case "reduce":
                    Reduce = o.ToEnum<CooperativeMatrixReduceMask>();
                    break;
                case "combineFunc":
                    CombineFunc = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixReduceNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpCooperativeMatrixReduceNV(OpData data) => new(data);
}

public struct OpCooperativeMatrixLoadTensorNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixLoadTensorNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixLoadTensorNV | (1 << 16);
    }

    public OpCooperativeMatrixLoadTensorNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCooperativeMatrixLoadTensorNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<MemoryAccessMask> MemoryOperand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<TensorAddressingOperandsMask> TensorAddressingOperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixLoadTensorNV inst) => inst.ResultId;
    public OpCooperativeMatrixLoadTensorNV(int resultType, int resultId, int pointer, int objectId, int tensorLayout, ParameterizedFlag<MemoryAccessMask> memoryOperand, ParameterizedFlag<TensorAddressingOperandsMask> tensorAddressingOperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        ObjectId = objectId;
        TensorLayout = tensorLayout;
        MemoryOperand = memoryOperand;
        TensorAddressingOperands = tensorAddressingOperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixLoadTensorNV, ResultType, ResultId, Pointer, ObjectId, TensorLayout, ..(Span<int>)[(int)MemoryOperand.Value, ..MemoryOperand.Span], ..(Span<int>)[(int)TensorAddressingOperands.Value, ..TensorAddressingOperands.Span]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "objectId":
                    ObjectId = o.ToLiteral<int>();
                    break;
                case "tensorLayout":
                    TensorLayout = o.ToLiteral<int>();
                    break;
                case "memoryOperand":
                    MemoryOperand = o.ToEnum<MemoryAccessMask>();
                    break;
                case "tensorAddressingOperands":
                    TensorAddressingOperands = o.ToEnum<TensorAddressingOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixLoadTensorNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpCooperativeMatrixLoadTensorNV(OpData data) => new(data);
}

public struct OpCooperativeMatrixStoreTensorNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixStoreTensorNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixStoreTensorNV | (1 << 16);
    }

    public OpCooperativeMatrixStoreTensorNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCooperativeMatrixStoreTensorNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ObjectId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<MemoryAccessMask> MemoryOperand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<TensorAddressingOperandsMask> TensorAddressingOperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpCooperativeMatrixStoreTensorNV(int pointer, int objectId, int tensorLayout, ParameterizedFlag<MemoryAccessMask> memoryOperand, ParameterizedFlag<TensorAddressingOperandsMask> tensorAddressingOperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Pointer = pointer;
        ObjectId = objectId;
        TensorLayout = tensorLayout;
        MemoryOperand = memoryOperand;
        TensorAddressingOperands = tensorAddressingOperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixStoreTensorNV, Pointer, ObjectId, TensorLayout, ..(Span<int>)[(int)MemoryOperand.Value, ..MemoryOperand.Span], ..(Span<int>)[(int)TensorAddressingOperands.Value, ..TensorAddressingOperands.Span]];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "objectId":
                    ObjectId = o.ToLiteral<int>();
                    break;
                case "tensorLayout":
                    TensorLayout = o.ToLiteral<int>();
                    break;
                case "memoryOperand":
                    MemoryOperand = o.ToEnum<MemoryAccessMask>();
                    break;
                case "tensorAddressingOperands":
                    TensorAddressingOperands = o.ToEnum<TensorAddressingOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixStoreTensorNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpCooperativeMatrixStoreTensorNV(OpData data) => new(data);
}

public struct OpCooperativeMatrixPerElementOpNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixPerElementOpNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixPerElementOpNV | (1 << 16);
    }

    public OpCooperativeMatrixPerElementOpNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCooperativeMatrixPerElementOpNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Func
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixPerElementOpNV inst) => inst.ResultId;
    public OpCooperativeMatrixPerElementOpNV(int resultType, int resultId, int matrix, int func, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
        Func = func;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixPerElementOpNV, ResultType, ResultId, Matrix, Func, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "matrix":
                    Matrix = o.ToLiteral<int>();
                    break;
                case "func":
                    Func = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixPerElementOpNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpCooperativeMatrixPerElementOpNV(OpData data) => new(data);
}

public struct OpTypeTensorLayoutNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeTensorLayoutNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeTensorLayoutNV | (1 << 16);
    }

    public OpTypeTensorLayoutNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeTensorLayoutNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dim
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ClampMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeTensorLayoutNV inst) => inst.ResultId;
    public OpTypeTensorLayoutNV(int resultId, int dim, int clampMode)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        Dim = dim;
        ClampMode = clampMode;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeTensorLayoutNV, ResultId, Dim, ClampMode];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "dim":
                    Dim = o.ToLiteral<int>();
                    break;
                case "clampMode":
                    ClampMode = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeTensorLayoutNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeTensorLayoutNV(OpData data) => new(data);
}

public struct OpTypeTensorViewNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeTensorViewNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeTensorViewNV | (1 << 16);
    }

    public OpTypeTensorViewNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeTensorViewNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Dim
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int HasDimensions
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeTensorViewNV inst) => inst.ResultId;
    public OpTypeTensorViewNV(int resultId, int dim, int hasDimensions, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        Dim = dim;
        HasDimensions = hasDimensions;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeTensorViewNV, ResultId, Dim, HasDimensions, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "dim":
                    Dim = o.ToLiteral<int>();
                    break;
                case "hasDimensions":
                    HasDimensions = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeTensorViewNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeTensorViewNV(OpData data) => new(data);
}

public struct OpCreateTensorLayoutNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCreateTensorLayoutNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCreateTensorLayoutNV | (1 << 16);
    }

    public OpCreateTensorLayoutNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCreateTensorLayoutNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCreateTensorLayoutNV inst) => inst.ResultId;
    public OpCreateTensorLayoutNV(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCreateTensorLayoutNV, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCreateTensorLayoutNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpCreateTensorLayoutNV(OpData data) => new(data);
}

public struct OpTensorLayoutSetDimensionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorLayoutSetDimensionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorLayoutSetDimensionNV | (1 << 16);
    }

    public OpTensorLayoutSetDimensionNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTensorLayoutSetDimensionNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTensorLayoutSetDimensionNV inst) => inst.ResultId;
    public OpTensorLayoutSetDimensionNV(int resultType, int resultId, int tensorLayout, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorLayoutSetDimensionNV, ResultType, ResultId, TensorLayout, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "tensorLayout":
                    TensorLayout = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTensorLayoutSetDimensionNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpTensorLayoutSetDimensionNV(OpData data) => new(data);
}

public struct OpTensorLayoutSetStrideNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorLayoutSetStrideNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorLayoutSetStrideNV | (1 << 16);
    }

    public OpTensorLayoutSetStrideNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTensorLayoutSetStrideNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTensorLayoutSetStrideNV inst) => inst.ResultId;
    public OpTensorLayoutSetStrideNV(int resultType, int resultId, int tensorLayout, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorLayoutSetStrideNV, ResultType, ResultId, TensorLayout, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "tensorLayout":
                    TensorLayout = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTensorLayoutSetStrideNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpTensorLayoutSetStrideNV(OpData data) => new(data);
}

public struct OpTensorLayoutSliceNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorLayoutSliceNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorLayoutSliceNV | (1 << 16);
    }

    public OpTensorLayoutSliceNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTensorLayoutSliceNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTensorLayoutSliceNV inst) => inst.ResultId;
    public OpTensorLayoutSliceNV(int resultType, int resultId, int tensorLayout, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorLayoutSliceNV, ResultType, ResultId, TensorLayout, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "tensorLayout":
                    TensorLayout = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTensorLayoutSliceNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpTensorLayoutSliceNV(OpData data) => new(data);
}

public struct OpTensorLayoutSetClampValueNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorLayoutSetClampValueNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorLayoutSetClampValueNV | (1 << 16);
    }

    public OpTensorLayoutSetClampValueNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTensorLayoutSetClampValueNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTensorLayoutSetClampValueNV inst) => inst.ResultId;
    public OpTensorLayoutSetClampValueNV(int resultType, int resultId, int tensorLayout, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorLayoutSetClampValueNV, ResultType, ResultId, TensorLayout, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "tensorLayout":
                    TensorLayout = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTensorLayoutSetClampValueNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpTensorLayoutSetClampValueNV(OpData data) => new(data);
}

public struct OpCreateTensorViewNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCreateTensorViewNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCreateTensorViewNV | (1 << 16);
    }

    public OpCreateTensorViewNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCreateTensorViewNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCreateTensorViewNV inst) => inst.ResultId;
    public OpCreateTensorViewNV(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCreateTensorViewNV, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCreateTensorViewNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpCreateTensorViewNV(OpData data) => new(data);
}

public struct OpTensorViewSetDimensionNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorViewSetDimensionNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorViewSetDimensionNV | (1 << 16);
    }

    public OpTensorViewSetDimensionNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTensorViewSetDimensionNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorView
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTensorViewSetDimensionNV inst) => inst.ResultId;
    public OpTensorViewSetDimensionNV(int resultType, int resultId, int tensorView, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        TensorView = tensorView;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorViewSetDimensionNV, ResultType, ResultId, TensorView, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "tensorView":
                    TensorView = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTensorViewSetDimensionNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpTensorViewSetDimensionNV(OpData data) => new(data);
}

public struct OpTensorViewSetStrideNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorViewSetStrideNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorViewSetStrideNV | (1 << 16);
    }

    public OpTensorViewSetStrideNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTensorViewSetStrideNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorView
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTensorViewSetStrideNV inst) => inst.ResultId;
    public OpTensorViewSetStrideNV(int resultType, int resultId, int tensorView, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        TensorView = tensorView;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorViewSetStrideNV, ResultType, ResultId, TensorView, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "tensorView":
                    TensorView = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTensorViewSetStrideNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpTensorViewSetStrideNV(OpData data) => new(data);
}

public struct OpDemoteToHelperInvocation : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDemoteToHelperInvocation()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDemoteToHelperInvocation | (1 << 16);
    }

    public OpDemoteToHelperInvocation(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpDemoteToHelperInvocation(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDemoteToHelperInvocation, ];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
            }
        }
    }

    public static implicit operator OpDemoteToHelperInvocation(OpDataIndex odi) => new(odi);
    public static implicit operator OpDemoteToHelperInvocation(OpData data) => new(data);
}

public struct OpIsHelperInvocationEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIsHelperInvocationEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIsHelperInvocationEXT | (1 << 16);
    }

    public OpIsHelperInvocationEXT(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIsHelperInvocationEXT(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIsHelperInvocationEXT inst) => inst.ResultId;
    public OpIsHelperInvocationEXT(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIsHelperInvocationEXT, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpIsHelperInvocationEXT(OpDataIndex odi) => new(odi);
    public static implicit operator OpIsHelperInvocationEXT(OpData data) => new(data);
}

public struct OpTensorViewSetClipNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorViewSetClipNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorViewSetClipNV | (1 << 16);
    }

    public OpTensorViewSetClipNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTensorViewSetClipNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorView
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ClipRowOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ClipRowSpan
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ClipColOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ClipColSpan
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTensorViewSetClipNV inst) => inst.ResultId;
    public OpTensorViewSetClipNV(int resultType, int resultId, int tensorView, int clipRowOffset, int clipRowSpan, int clipColOffset, int clipColSpan)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        TensorView = tensorView;
        ClipRowOffset = clipRowOffset;
        ClipRowSpan = clipRowSpan;
        ClipColOffset = clipColOffset;
        ClipColSpan = clipColSpan;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorViewSetClipNV, ResultType, ResultId, TensorView, ClipRowOffset, ClipRowSpan, ClipColOffset, ClipColSpan];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "tensorView":
                    TensorView = o.ToLiteral<int>();
                    break;
                case "clipRowOffset":
                    ClipRowOffset = o.ToLiteral<int>();
                    break;
                case "clipRowSpan":
                    ClipRowSpan = o.ToLiteral<int>();
                    break;
                case "clipColOffset":
                    ClipColOffset = o.ToLiteral<int>();
                    break;
                case "clipColSpan":
                    ClipColSpan = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTensorViewSetClipNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpTensorViewSetClipNV(OpData data) => new(data);
}

public struct OpTensorLayoutSetBlockSizeNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTensorLayoutSetBlockSizeNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTensorLayoutSetBlockSizeNV | (1 << 16);
    }

    public OpTensorLayoutSetBlockSizeNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTensorLayoutSetBlockSizeNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int TensorLayout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTensorLayoutSetBlockSizeNV inst) => inst.ResultId;
    public OpTensorLayoutSetBlockSizeNV(int resultType, int resultId, int tensorLayout, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        TensorLayout = tensorLayout;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTensorLayoutSetBlockSizeNV, ResultType, ResultId, TensorLayout, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "tensorLayout":
                    TensorLayout = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTensorLayoutSetBlockSizeNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpTensorLayoutSetBlockSizeNV(OpData data) => new(data);
}

public struct OpCooperativeMatrixTransposeNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCooperativeMatrixTransposeNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCooperativeMatrixTransposeNV | (1 << 16);
    }

    public OpCooperativeMatrixTransposeNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCooperativeMatrixTransposeNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Matrix
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCooperativeMatrixTransposeNV inst) => inst.ResultId;
    public OpCooperativeMatrixTransposeNV(int resultType, int resultId, int matrix)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Matrix = matrix;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCooperativeMatrixTransposeNV, ResultType, ResultId, Matrix];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "matrix":
                    Matrix = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCooperativeMatrixTransposeNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpCooperativeMatrixTransposeNV(OpData data) => new(data);
}

public struct OpConvertUToImageNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToImageNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToImageNV | (1 << 16);
    }

    public OpConvertUToImageNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConvertUToImageNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertUToImageNV inst) => inst.ResultId;
    public OpConvertUToImageNV(int resultType, int resultId, int operand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToImageNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConvertUToImageNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpConvertUToImageNV(OpData data) => new(data);
}

public struct OpConvertUToSamplerNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToSamplerNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToSamplerNV | (1 << 16);
    }

    public OpConvertUToSamplerNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConvertUToSamplerNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertUToSamplerNV inst) => inst.ResultId;
    public OpConvertUToSamplerNV(int resultType, int resultId, int operand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToSamplerNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConvertUToSamplerNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpConvertUToSamplerNV(OpData data) => new(data);
}

public struct OpConvertImageToUNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertImageToUNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertImageToUNV | (1 << 16);
    }

    public OpConvertImageToUNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConvertImageToUNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertImageToUNV inst) => inst.ResultId;
    public OpConvertImageToUNV(int resultType, int resultId, int operand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertImageToUNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConvertImageToUNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpConvertImageToUNV(OpData data) => new(data);
}

public struct OpConvertSamplerToUNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertSamplerToUNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertSamplerToUNV | (1 << 16);
    }

    public OpConvertSamplerToUNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConvertSamplerToUNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertSamplerToUNV inst) => inst.ResultId;
    public OpConvertSamplerToUNV(int resultType, int resultId, int operand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertSamplerToUNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConvertSamplerToUNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpConvertSamplerToUNV(OpData data) => new(data);
}

public struct OpConvertUToSampledImageNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertUToSampledImageNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertUToSampledImageNV | (1 << 16);
    }

    public OpConvertUToSampledImageNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConvertUToSampledImageNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertUToSampledImageNV inst) => inst.ResultId;
    public OpConvertUToSampledImageNV(int resultType, int resultId, int operand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertUToSampledImageNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConvertUToSampledImageNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpConvertUToSampledImageNV(OpData data) => new(data);
}

public struct OpConvertSampledImageToUNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertSampledImageToUNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertSampledImageToUNV | (1 << 16);
    }

    public OpConvertSampledImageToUNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConvertSampledImageToUNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertSampledImageToUNV inst) => inst.ResultId;
    public OpConvertSampledImageToUNV(int resultType, int resultId, int operand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertSampledImageToUNV, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConvertSampledImageToUNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpConvertSampledImageToUNV(OpData data) => new(data);
}

public struct OpSamplerImageAddressingModeNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSamplerImageAddressingModeNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSamplerImageAddressingModeNV | (1 << 16);
    }

    public OpSamplerImageAddressingModeNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSamplerImageAddressingModeNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int BitWidth
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSamplerImageAddressingModeNV(int bitWidth)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        BitWidth = bitWidth;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSamplerImageAddressingModeNV, ..BitWidth.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "bitWidth":
                    BitWidth = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSamplerImageAddressingModeNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpSamplerImageAddressingModeNV(OpData data) => new(data);
}

public struct OpRawAccessChainNV : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRawAccessChainNV()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRawAccessChainNV | (1 << 16);
    }

    public OpRawAccessChainNV(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRawAccessChainNV(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BaseId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Bytestride
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Elementindex
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Byteoffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public RawAccessChainOperandsMask? Rawaccesschainoperands
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRawAccessChainNV inst) => inst.ResultId;
    public OpRawAccessChainNV(int resultType, int resultId, int baseId, int bytestride, int elementindex, int byteoffset, RawAccessChainOperandsMask? rawaccesschainoperands)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BaseId = baseId;
        Bytestride = bytestride;
        Elementindex = elementindex;
        Byteoffset = byteoffset;
        Rawaccesschainoperands = rawaccesschainoperands;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRawAccessChainNV, ResultType, ResultId, BaseId, Bytestride, Elementindex, Byteoffset, ..(Rawaccesschainoperands is null ? (Span<int>)[] : [(int)Rawaccesschainoperands.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "baseId":
                    BaseId = o.ToLiteral<int>();
                    break;
                case "bytestride":
                    Bytestride = o.ToLiteral<int>();
                    break;
                case "elementindex":
                    Elementindex = o.ToLiteral<int>();
                    break;
                case "byteoffset":
                    Byteoffset = o.ToLiteral<int>();
                    break;
                case "rawaccesschainoperands":
                    if (o.Words.Length > 0)
                        Rawaccesschainoperands = o.ToEnum<RawAccessChainOperandsMask>();
                    break;
            }
        }
    }

    public static implicit operator OpRawAccessChainNV(OpDataIndex odi) => new(odi);
    public static implicit operator OpRawAccessChainNV(OpData data) => new(data);
}

public struct OpSubgroupShuffleINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupShuffleINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupShuffleINTEL | (1 << 16);
    }

    public OpSubgroupShuffleINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupShuffleINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InvocationId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupShuffleINTEL inst) => inst.ResultId;
    public OpSubgroupShuffleINTEL(int resultType, int resultId, int data, int invocationId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Data = data;
        InvocationId = invocationId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupShuffleINTEL, ResultType, ResultId, Data, InvocationId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "data":
                    Data = o.ToLiteral<int>();
                    break;
                case "invocationId":
                    InvocationId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupShuffleINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupShuffleINTEL(OpData data) => new(data);
}

public struct OpSubgroupShuffleDownINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupShuffleDownINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupShuffleDownINTEL | (1 << 16);
    }

    public OpSubgroupShuffleDownINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupShuffleDownINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Current
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Next
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupShuffleDownINTEL inst) => inst.ResultId;
    public OpSubgroupShuffleDownINTEL(int resultType, int resultId, int current, int next, int delta)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Current = current;
        Next = next;
        Delta = delta;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupShuffleDownINTEL, ResultType, ResultId, Current, Next, Delta];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "current":
                    Current = o.ToLiteral<int>();
                    break;
                case "next":
                    Next = o.ToLiteral<int>();
                    break;
                case "delta":
                    Delta = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupShuffleDownINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupShuffleDownINTEL(OpData data) => new(data);
}

public struct OpSubgroupShuffleUpINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupShuffleUpINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupShuffleUpINTEL | (1 << 16);
    }

    public OpSubgroupShuffleUpINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupShuffleUpINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Previous
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Current
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Delta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupShuffleUpINTEL inst) => inst.ResultId;
    public OpSubgroupShuffleUpINTEL(int resultType, int resultId, int previous, int current, int delta)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Previous = previous;
        Current = current;
        Delta = delta;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupShuffleUpINTEL, ResultType, ResultId, Previous, Current, Delta];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "previous":
                    Previous = o.ToLiteral<int>();
                    break;
                case "current":
                    Current = o.ToLiteral<int>();
                    break;
                case "delta":
                    Delta = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupShuffleUpINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupShuffleUpINTEL(OpData data) => new(data);
}

public struct OpSubgroupShuffleXorINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupShuffleXorINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupShuffleXorINTEL | (1 << 16);
    }

    public OpSubgroupShuffleXorINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupShuffleXorINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupShuffleXorINTEL inst) => inst.ResultId;
    public OpSubgroupShuffleXorINTEL(int resultType, int resultId, int data, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Data = data;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupShuffleXorINTEL, ResultType, ResultId, Data, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "data":
                    Data = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupShuffleXorINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupShuffleXorINTEL(OpData data) => new(data);
}

public struct OpSubgroupBlockReadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupBlockReadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupBlockReadINTEL | (1 << 16);
    }

    public OpSubgroupBlockReadINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupBlockReadINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Ptr
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupBlockReadINTEL inst) => inst.ResultId;
    public OpSubgroupBlockReadINTEL(int resultType, int resultId, int ptr)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Ptr = ptr;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupBlockReadINTEL, ResultType, ResultId, Ptr];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "ptr":
                    Ptr = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupBlockReadINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupBlockReadINTEL(OpData data) => new(data);
}

public struct OpSubgroupBlockWriteINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupBlockWriteINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupBlockWriteINTEL | (1 << 16);
    }

    public OpSubgroupBlockWriteINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupBlockWriteINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Ptr
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupBlockWriteINTEL(int ptr, int data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Ptr = ptr;
        Data = data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupBlockWriteINTEL, Ptr, Data];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "ptr":
                    Ptr = o.ToLiteral<int>();
                    break;
                case "data":
                    Data = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupBlockWriteINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupBlockWriteINTEL(OpData data) => new(data);
}

public struct OpSubgroupImageBlockReadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupImageBlockReadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupImageBlockReadINTEL | (1 << 16);
    }

    public OpSubgroupImageBlockReadINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupImageBlockReadINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupImageBlockReadINTEL inst) => inst.ResultId;
    public OpSubgroupImageBlockReadINTEL(int resultType, int resultId, int image, int coordinate)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupImageBlockReadINTEL, ResultType, ResultId, Image, Coordinate];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupImageBlockReadINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupImageBlockReadINTEL(OpData data) => new(data);
}

public struct OpSubgroupImageBlockWriteINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupImageBlockWriteINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupImageBlockWriteINTEL | (1 << 16);
    }

    public OpSubgroupImageBlockWriteINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupImageBlockWriteINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupImageBlockWriteINTEL(int image, int coordinate, int data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Image = image;
        Coordinate = coordinate;
        Data = data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupImageBlockWriteINTEL, Image, Coordinate, Data];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "data":
                    Data = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupImageBlockWriteINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupImageBlockWriteINTEL(OpData data) => new(data);
}

public struct OpSubgroupImageMediaBlockReadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupImageMediaBlockReadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupImageMediaBlockReadINTEL | (1 << 16);
    }

    public OpSubgroupImageMediaBlockReadINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupImageMediaBlockReadINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Width
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Height
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupImageMediaBlockReadINTEL inst) => inst.ResultId;
    public OpSubgroupImageMediaBlockReadINTEL(int resultType, int resultId, int image, int coordinate, int width, int height)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Image = image;
        Coordinate = coordinate;
        Width = width;
        Height = height;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupImageMediaBlockReadINTEL, ResultType, ResultId, Image, Coordinate, Width, Height];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "width":
                    Width = o.ToLiteral<int>();
                    break;
                case "height":
                    Height = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupImageMediaBlockReadINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupImageMediaBlockReadINTEL(OpData data) => new(data);
}

public struct OpSubgroupImageMediaBlockWriteINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupImageMediaBlockWriteINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupImageMediaBlockWriteINTEL | (1 << 16);
    }

    public OpSubgroupImageMediaBlockWriteINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupImageMediaBlockWriteINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Image
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Coordinate
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Width
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Height
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Data
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupImageMediaBlockWriteINTEL(int image, int coordinate, int width, int height, int data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Image = image;
        Coordinate = coordinate;
        Width = width;
        Height = height;
        Data = data;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupImageMediaBlockWriteINTEL, Image, Coordinate, Width, Height, Data];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "image":
                    Image = o.ToLiteral<int>();
                    break;
                case "coordinate":
                    Coordinate = o.ToLiteral<int>();
                    break;
                case "width":
                    Width = o.ToLiteral<int>();
                    break;
                case "height":
                    Height = o.ToLiteral<int>();
                    break;
                case "data":
                    Data = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupImageMediaBlockWriteINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupImageMediaBlockWriteINTEL(OpData data) => new(data);
}

public struct OpUCountLeadingZerosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUCountLeadingZerosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUCountLeadingZerosINTEL | (1 << 16);
    }

    public OpUCountLeadingZerosINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUCountLeadingZerosINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUCountLeadingZerosINTEL inst) => inst.ResultId;
    public OpUCountLeadingZerosINTEL(int resultType, int resultId, int operand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUCountLeadingZerosINTEL, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUCountLeadingZerosINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpUCountLeadingZerosINTEL(OpData data) => new(data);
}

public struct OpUCountTrailingZerosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUCountTrailingZerosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUCountTrailingZerosINTEL | (1 << 16);
    }

    public OpUCountTrailingZerosINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUCountTrailingZerosINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUCountTrailingZerosINTEL inst) => inst.ResultId;
    public OpUCountTrailingZerosINTEL(int resultType, int resultId, int operand)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand = operand;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUCountTrailingZerosINTEL, ResultType, ResultId, Operand];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand":
                    Operand = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUCountTrailingZerosINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpUCountTrailingZerosINTEL(OpData data) => new(data);
}

public struct OpAbsISubINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAbsISubINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAbsISubINTEL | (1 << 16);
    }

    public OpAbsISubINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAbsISubINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAbsISubINTEL inst) => inst.ResultId;
    public OpAbsISubINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAbsISubINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAbsISubINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpAbsISubINTEL(OpData data) => new(data);
}

public struct OpAbsUSubINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAbsUSubINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAbsUSubINTEL | (1 << 16);
    }

    public OpAbsUSubINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAbsUSubINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAbsUSubINTEL inst) => inst.ResultId;
    public OpAbsUSubINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAbsUSubINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAbsUSubINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpAbsUSubINTEL(OpData data) => new(data);
}

public struct OpIAddSatINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIAddSatINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIAddSatINTEL | (1 << 16);
    }

    public OpIAddSatINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIAddSatINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIAddSatINTEL inst) => inst.ResultId;
    public OpIAddSatINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIAddSatINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpIAddSatINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpIAddSatINTEL(OpData data) => new(data);
}

public struct OpUAddSatINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUAddSatINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUAddSatINTEL | (1 << 16);
    }

    public OpUAddSatINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUAddSatINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUAddSatINTEL inst) => inst.ResultId;
    public OpUAddSatINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUAddSatINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUAddSatINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpUAddSatINTEL(OpData data) => new(data);
}

public struct OpIAverageINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIAverageINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIAverageINTEL | (1 << 16);
    }

    public OpIAverageINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIAverageINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIAverageINTEL inst) => inst.ResultId;
    public OpIAverageINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIAverageINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpIAverageINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpIAverageINTEL(OpData data) => new(data);
}

public struct OpUAverageINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUAverageINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUAverageINTEL | (1 << 16);
    }

    public OpUAverageINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUAverageINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUAverageINTEL inst) => inst.ResultId;
    public OpUAverageINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUAverageINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUAverageINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpUAverageINTEL(OpData data) => new(data);
}

public struct OpIAverageRoundedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIAverageRoundedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIAverageRoundedINTEL | (1 << 16);
    }

    public OpIAverageRoundedINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIAverageRoundedINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIAverageRoundedINTEL inst) => inst.ResultId;
    public OpIAverageRoundedINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIAverageRoundedINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpIAverageRoundedINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpIAverageRoundedINTEL(OpData data) => new(data);
}

public struct OpUAverageRoundedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUAverageRoundedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUAverageRoundedINTEL | (1 << 16);
    }

    public OpUAverageRoundedINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUAverageRoundedINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUAverageRoundedINTEL inst) => inst.ResultId;
    public OpUAverageRoundedINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUAverageRoundedINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUAverageRoundedINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpUAverageRoundedINTEL(OpData data) => new(data);
}

public struct OpISubSatINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpISubSatINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpISubSatINTEL | (1 << 16);
    }

    public OpISubSatINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpISubSatINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpISubSatINTEL inst) => inst.ResultId;
    public OpISubSatINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpISubSatINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpISubSatINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpISubSatINTEL(OpData data) => new(data);
}

public struct OpUSubSatINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUSubSatINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUSubSatINTEL | (1 << 16);
    }

    public OpUSubSatINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUSubSatINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUSubSatINTEL inst) => inst.ResultId;
    public OpUSubSatINTEL(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUSubSatINTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUSubSatINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpUSubSatINTEL(OpData data) => new(data);
}

public struct OpIMul32x16INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpIMul32x16INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpIMul32x16INTEL | (1 << 16);
    }

    public OpIMul32x16INTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpIMul32x16INTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpIMul32x16INTEL inst) => inst.ResultId;
    public OpIMul32x16INTEL(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpIMul32x16INTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpIMul32x16INTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpIMul32x16INTEL(OpData data) => new(data);
}

public struct OpUMul32x16INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpUMul32x16INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpUMul32x16INTEL | (1 << 16);
    }

    public OpUMul32x16INTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpUMul32x16INTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Operand2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpUMul32x16INTEL inst) => inst.ResultId;
    public OpUMul32x16INTEL(int resultType, int resultId, int operand1, int operand2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Operand1 = operand1;
        Operand2 = operand2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpUMul32x16INTEL, ResultType, ResultId, Operand1, Operand2];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "operand1":
                    Operand1 = o.ToLiteral<int>();
                    break;
                case "operand2":
                    Operand2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpUMul32x16INTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpUMul32x16INTEL(OpData data) => new(data);
}

public struct OpConstantFunctionPointerINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantFunctionPointerINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantFunctionPointerINTEL | (1 << 16);
    }

    public OpConstantFunctionPointerINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConstantFunctionPointerINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Function
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConstantFunctionPointerINTEL inst) => inst.ResultId;
    public OpConstantFunctionPointerINTEL(int resultType, int resultId, int function)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Function = function;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantFunctionPointerINTEL, ResultType, ResultId, Function];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "function":
                    Function = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConstantFunctionPointerINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpConstantFunctionPointerINTEL(OpData data) => new(data);
}

public struct OpFunctionPointerCallINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFunctionPointerCallINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFunctionPointerCallINTEL | (1 << 16);
    }

    public OpFunctionPointerCallINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFunctionPointerCallINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFunctionPointerCallINTEL inst) => inst.ResultId;
    public OpFunctionPointerCallINTEL(int resultType, int resultId, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFunctionPointerCallINTEL, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFunctionPointerCallINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpFunctionPointerCallINTEL(OpData data) => new(data);
}

public struct OpAsmTargetINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAsmTargetINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAsmTargetINTEL | (1 << 16);
    }

    public OpAsmTargetINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAsmTargetINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Asmtarget
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAsmTargetINTEL inst) => inst.ResultId;
    public OpAsmTargetINTEL(int resultType, int resultId, string asmtarget)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Asmtarget = asmtarget;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAsmTargetINTEL, ResultType, ResultId, ..Asmtarget.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "asmtarget":
                    Asmtarget = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpAsmTargetINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpAsmTargetINTEL(OpData data) => new(data);
}

public struct OpAsmINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAsmINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAsmINTEL | (1 << 16);
    }

    public OpAsmINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAsmINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Asmtype
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Asminstructions
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Constraints
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAsmINTEL inst) => inst.ResultId;
    public OpAsmINTEL(int resultType, int resultId, int asmtype, int target, string asminstructions, string constraints)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Asmtype = asmtype;
        Target = target;
        Asminstructions = asminstructions;
        Constraints = constraints;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAsmINTEL, ResultType, ResultId, Asmtype, Target, ..Asminstructions.AsDisposableLiteralValue().Words, ..Constraints.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "asmtype":
                    Asmtype = o.ToLiteral<int>();
                    break;
                case "target":
                    Target = o.ToLiteral<int>();
                    break;
                case "asminstructions":
                    Asminstructions = o.ToLiteral<string>();
                    break;
                case "constraints":
                    Constraints = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpAsmINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpAsmINTEL(OpData data) => new(data);
}

public struct OpAsmCallINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAsmCallINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAsmCallINTEL | (1 << 16);
    }

    public OpAsmCallINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAsmCallINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Asm
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAsmCallINTEL inst) => inst.ResultId;
    public OpAsmCallINTEL(int resultType, int resultId, int asm, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Asm = asm;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAsmCallINTEL, ResultType, ResultId, Asm, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "asm":
                    Asm = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAsmCallINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpAsmCallINTEL(OpData data) => new(data);
}

public struct OpAtomicFMinEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicFMinEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicFMinEXT | (1 << 16);
    }

    public OpAtomicFMinEXT(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicFMinEXT(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicFMinEXT inst) => inst.ResultId;
    public OpAtomicFMinEXT(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicFMinEXT, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicFMinEXT(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicFMinEXT(OpData data) => new(data);
}

public struct OpAtomicFMaxEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicFMaxEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicFMaxEXT | (1 << 16);
    }

    public OpAtomicFMaxEXT(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicFMaxEXT(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicFMaxEXT inst) => inst.ResultId;
    public OpAtomicFMaxEXT(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicFMaxEXT, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicFMaxEXT(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicFMaxEXT(OpData data) => new(data);
}

public struct OpAssumeTrueKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAssumeTrueKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAssumeTrueKHR | (1 << 16);
    }

    public OpAssumeTrueKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAssumeTrueKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Condition
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpAssumeTrueKHR(int condition)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Condition = condition;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAssumeTrueKHR, Condition];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "condition":
                    Condition = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAssumeTrueKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpAssumeTrueKHR(OpData data) => new(data);
}

public struct OpExpectKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpExpectKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExpectKHR | (1 << 16);
    }

    public OpExpectKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpExpectKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ExpectedValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpExpectKHR inst) => inst.ResultId;
    public OpExpectKHR(int resultType, int resultId, int value, int expectedValue)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Value = value;
        ExpectedValue = expectedValue;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExpectKHR, ResultType, ResultId, Value, ExpectedValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
                case "expectedValue":
                    ExpectedValue = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpExpectKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpExpectKHR(OpData data) => new(data);
}

public struct OpDecorateString : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpDecorateString()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpDecorateString | (1 << 16);
    }

    public OpDecorateString(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpDecorateString(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public Decoration Decoration
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpDecorateString(int target, Decoration decoration, string value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Target = target;
        Decoration = decoration;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpDecorateString, Target, (int)Decoration, ..Value.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "target":
                    Target = o.ToLiteral<int>();
                    break;
                case "decoration":
                    Decoration = o.ToEnum<Decoration>();
                    break;
                case "value":
                    Value = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpDecorateString(OpDataIndex odi) => new(odi);
    public static implicit operator OpDecorateString(OpData data) => new(data);
}

public struct OpMemberDecorateString : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMemberDecorateString()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMemberDecorateString | (1 << 16);
    }

    public OpMemberDecorateString(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpMemberDecorateString(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int StructType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Member
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public Decoration Decoration
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public string Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMemberDecorateString(int structType, int member, Decoration decoration, string value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        StructType = structType;
        Member = member;
        Decoration = decoration;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMemberDecorateString, StructType, ..Member.AsDisposableLiteralValue().Words, (int)Decoration, ..Value.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "structType":
                    StructType = o.ToLiteral<int>();
                    break;
                case "member":
                    Member = o.ToLiteral<int>();
                    break;
                case "decoration":
                    Decoration = o.ToEnum<Decoration>();
                    break;
                case "value":
                    Value = o.ToLiteral<string>();
                    break;
            }
        }
    }

    public static implicit operator OpMemberDecorateString(OpDataIndex odi) => new(odi);
    public static implicit operator OpMemberDecorateString(OpData data) => new(data);
}

public struct OpVmeImageINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVmeImageINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVmeImageINTEL | (1 << 16);
    }

    public OpVmeImageINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpVmeImageINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ImageType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Sampler
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVmeImageINTEL inst) => inst.ResultId;
    public OpVmeImageINTEL(int resultType, int resultId, int imageType, int sampler)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        ImageType = imageType;
        Sampler = sampler;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVmeImageINTEL, ResultType, ResultId, ImageType, Sampler];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "imageType":
                    ImageType = o.ToLiteral<int>();
                    break;
                case "sampler":
                    Sampler = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpVmeImageINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpVmeImageINTEL(OpData data) => new(data);
}

public struct OpTypeVmeImageINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeVmeImageINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeVmeImageINTEL | (1 << 16);
    }

    public OpTypeVmeImageINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeVmeImageINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ImageType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeVmeImageINTEL inst) => inst.ResultId;
    public OpTypeVmeImageINTEL(int resultId, int imageType)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        ImageType = imageType;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeVmeImageINTEL, ResultId, ImageType];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "imageType":
                    ImageType = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeVmeImageINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeVmeImageINTEL(OpData data) => new(data);
}

public struct OpTypeAvcImePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImePayloadINTEL | (1 << 16);
    }

    public OpTypeAvcImePayloadINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeAvcImePayloadINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcImePayloadINTEL inst) => inst.ResultId;
    public OpTypeAvcImePayloadINTEL(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImePayloadINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcImePayloadINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeAvcImePayloadINTEL(OpData data) => new(data);
}

public struct OpTypeAvcRefPayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcRefPayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcRefPayloadINTEL | (1 << 16);
    }

    public OpTypeAvcRefPayloadINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeAvcRefPayloadINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcRefPayloadINTEL inst) => inst.ResultId;
    public OpTypeAvcRefPayloadINTEL(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcRefPayloadINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcRefPayloadINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeAvcRefPayloadINTEL(OpData data) => new(data);
}

public struct OpTypeAvcSicPayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcSicPayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcSicPayloadINTEL | (1 << 16);
    }

    public OpTypeAvcSicPayloadINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeAvcSicPayloadINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcSicPayloadINTEL inst) => inst.ResultId;
    public OpTypeAvcSicPayloadINTEL(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcSicPayloadINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcSicPayloadINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeAvcSicPayloadINTEL(OpData data) => new(data);
}

public struct OpTypeAvcMcePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcMcePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcMcePayloadINTEL | (1 << 16);
    }

    public OpTypeAvcMcePayloadINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeAvcMcePayloadINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcMcePayloadINTEL inst) => inst.ResultId;
    public OpTypeAvcMcePayloadINTEL(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcMcePayloadINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcMcePayloadINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeAvcMcePayloadINTEL(OpData data) => new(data);
}

public struct OpTypeAvcMceResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcMceResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcMceResultINTEL | (1 << 16);
    }

    public OpTypeAvcMceResultINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeAvcMceResultINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcMceResultINTEL inst) => inst.ResultId;
    public OpTypeAvcMceResultINTEL(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcMceResultINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcMceResultINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeAvcMceResultINTEL(OpData data) => new(data);
}

public struct OpTypeAvcImeResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImeResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImeResultINTEL | (1 << 16);
    }

    public OpTypeAvcImeResultINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeAvcImeResultINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcImeResultINTEL inst) => inst.ResultId;
    public OpTypeAvcImeResultINTEL(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImeResultINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcImeResultINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeAvcImeResultINTEL(OpData data) => new(data);
}

public struct OpTypeAvcImeResultSingleReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImeResultSingleReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImeResultSingleReferenceStreamoutINTEL | (1 << 16);
    }

    public OpTypeAvcImeResultSingleReferenceStreamoutINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeAvcImeResultSingleReferenceStreamoutINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcImeResultSingleReferenceStreamoutINTEL inst) => inst.ResultId;
    public OpTypeAvcImeResultSingleReferenceStreamoutINTEL(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImeResultSingleReferenceStreamoutINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcImeResultSingleReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeAvcImeResultSingleReferenceStreamoutINTEL(OpData data) => new(data);
}

public struct OpTypeAvcImeResultDualReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImeResultDualReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImeResultDualReferenceStreamoutINTEL | (1 << 16);
    }

    public OpTypeAvcImeResultDualReferenceStreamoutINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeAvcImeResultDualReferenceStreamoutINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcImeResultDualReferenceStreamoutINTEL inst) => inst.ResultId;
    public OpTypeAvcImeResultDualReferenceStreamoutINTEL(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImeResultDualReferenceStreamoutINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcImeResultDualReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeAvcImeResultDualReferenceStreamoutINTEL(OpData data) => new(data);
}

public struct OpTypeAvcImeSingleReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImeSingleReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImeSingleReferenceStreaminINTEL | (1 << 16);
    }

    public OpTypeAvcImeSingleReferenceStreaminINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeAvcImeSingleReferenceStreaminINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcImeSingleReferenceStreaminINTEL inst) => inst.ResultId;
    public OpTypeAvcImeSingleReferenceStreaminINTEL(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImeSingleReferenceStreaminINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcImeSingleReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeAvcImeSingleReferenceStreaminINTEL(OpData data) => new(data);
}

public struct OpTypeAvcImeDualReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcImeDualReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcImeDualReferenceStreaminINTEL | (1 << 16);
    }

    public OpTypeAvcImeDualReferenceStreaminINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeAvcImeDualReferenceStreaminINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcImeDualReferenceStreaminINTEL inst) => inst.ResultId;
    public OpTypeAvcImeDualReferenceStreaminINTEL(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcImeDualReferenceStreaminINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcImeDualReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeAvcImeDualReferenceStreaminINTEL(OpData data) => new(data);
}

public struct OpTypeAvcRefResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcRefResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcRefResultINTEL | (1 << 16);
    }

    public OpTypeAvcRefResultINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeAvcRefResultINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcRefResultINTEL inst) => inst.ResultId;
    public OpTypeAvcRefResultINTEL(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcRefResultINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcRefResultINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeAvcRefResultINTEL(OpData data) => new(data);
}

public struct OpTypeAvcSicResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeAvcSicResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeAvcSicResultINTEL | (1 << 16);
    }

    public OpTypeAvcSicResultINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeAvcSicResultINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeAvcSicResultINTEL inst) => inst.ResultId;
    public OpTypeAvcSicResultINTEL(int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeAvcSicResultINTEL, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeAvcSicResultINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeAvcSicResultINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sliceType":
                    SliceType = o.ToLiteral<int>();
                    break;
                case "qp":
                    Qp = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceBasePenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(int resultType, int resultId, int referenceBasePenalty, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        ReferenceBasePenalty = referenceBasePenalty;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL, ResultType, ResultId, ReferenceBasePenalty, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "referenceBasePenalty":
                    ReferenceBasePenalty = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sliceType":
                    SliceType = o.ToLiteral<int>();
                    break;
                case "qp":
                    Qp = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceSetInterShapePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetInterShapePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetInterShapePenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceSetInterShapePenaltyINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceSetInterShapePenaltyINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedShapePenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceSetInterShapePenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceSetInterShapePenaltyINTEL(int resultType, int resultId, int packedShapePenalty, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        PackedShapePenalty = packedShapePenalty;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetInterShapePenaltyINTEL, ResultType, ResultId, PackedShapePenalty, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packedShapePenalty":
                    PackedShapePenalty = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceSetInterShapePenaltyINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceSetInterShapePenaltyINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sliceType":
                    SliceType = o.ToLiteral<int>();
                    break;
                case "qp":
                    Qp = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceSetInterDirectionPenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetInterDirectionPenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetInterDirectionPenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceSetInterDirectionPenaltyINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceSetInterDirectionPenaltyINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int DirectionCost
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceSetInterDirectionPenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceSetInterDirectionPenaltyINTEL(int resultType, int resultId, int directionCost, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        DirectionCost = directionCost;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetInterDirectionPenaltyINTEL, ResultType, ResultId, DirectionCost, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "directionCost":
                    DirectionCost = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceSetInterDirectionPenaltyINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceSetInterDirectionPenaltyINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sliceType":
                    SliceType = o.ToLiteral<int>();
                    break;
                case "qp":
                    Qp = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sliceType":
                    SliceType = o.ToLiteral<int>();
                    break;
                case "qp":
                    Qp = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedCostCenterDelta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedCostTable
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int CostPrecision
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(int resultType, int resultId, int packedCostCenterDelta, int packedCostTable, int costPrecision, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        PackedCostCenterDelta = packedCostCenterDelta;
        PackedCostTable = packedCostTable;
        CostPrecision = costPrecision;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL, ResultType, ResultId, PackedCostCenterDelta, PackedCostTable, CostPrecision, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packedCostCenterDelta":
                    PackedCostCenterDelta = o.ToLiteral<int>();
                    break;
                case "packedCostTable":
                    PackedCostTable = o.ToLiteral<int>();
                    break;
                case "costPrecision":
                    CostPrecision = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SliceType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Qp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(int resultType, int resultId, int sliceType, int qp)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SliceType = sliceType;
        Qp = qp;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL, ResultType, ResultId, SliceType, Qp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sliceType":
                    SliceType = o.ToLiteral<int>();
                    break;
                case "qp":
                    Qp = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceSetAcOnlyHaarINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetAcOnlyHaarINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetAcOnlyHaarINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceSetAcOnlyHaarINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceSetAcOnlyHaarINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceSetAcOnlyHaarINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceSetAcOnlyHaarINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetAcOnlyHaarINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceSetAcOnlyHaarINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceSetAcOnlyHaarINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SourceFieldPolarity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(int resultType, int resultId, int sourceFieldPolarity, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SourceFieldPolarity = sourceFieldPolarity;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL, ResultType, ResultId, SourceFieldPolarity, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "sourceFieldPolarity":
                    SourceFieldPolarity = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ReferenceFieldPolarity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(int resultType, int resultId, int referenceFieldPolarity, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        ReferenceFieldPolarity = referenceFieldPolarity;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL, ResultType, ResultId, ReferenceFieldPolarity, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "referenceFieldPolarity":
                    ReferenceFieldPolarity = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ForwardReferenceFieldPolarity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BackwardReferenceFieldPolarity
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(int resultType, int resultId, int forwardReferenceFieldPolarity, int backwardReferenceFieldPolarity, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        ForwardReferenceFieldPolarity = forwardReferenceFieldPolarity;
        BackwardReferenceFieldPolarity = backwardReferenceFieldPolarity;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL, ResultType, ResultId, ForwardReferenceFieldPolarity, BackwardReferenceFieldPolarity, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "forwardReferenceFieldPolarity":
                    ForwardReferenceFieldPolarity = o.ToLiteral<int>();
                    break;
                case "backwardReferenceFieldPolarity":
                    BackwardReferenceFieldPolarity = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceConvertToImePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToImePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToImePayloadINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceConvertToImePayloadINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceConvertToImePayloadINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceConvertToImePayloadINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceConvertToImePayloadINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToImePayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToImePayloadINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceConvertToImePayloadINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceConvertToImeResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToImeResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToImeResultINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceConvertToImeResultINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceConvertToImeResultINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceConvertToImeResultINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceConvertToImeResultINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToImeResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToImeResultINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceConvertToImeResultINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceConvertToRefPayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToRefPayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToRefPayloadINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceConvertToRefPayloadINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceConvertToRefPayloadINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceConvertToRefPayloadINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceConvertToRefPayloadINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToRefPayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToRefPayloadINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceConvertToRefPayloadINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceConvertToRefResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToRefResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToRefResultINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceConvertToRefResultINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceConvertToRefResultINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceConvertToRefResultINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceConvertToRefResultINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToRefResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToRefResultINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceConvertToRefResultINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceConvertToSicPayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToSicPayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToSicPayloadINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceConvertToSicPayloadINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceConvertToSicPayloadINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceConvertToSicPayloadINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceConvertToSicPayloadINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToSicPayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToSicPayloadINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceConvertToSicPayloadINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceConvertToSicResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceConvertToSicResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceConvertToSicResultINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceConvertToSicResultINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceConvertToSicResultINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceConvertToSicResultINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceConvertToSicResultINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceConvertToSicResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceConvertToSicResultINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceConvertToSicResultINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetMotionVectorsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetMotionVectorsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetMotionVectorsINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetMotionVectorsINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetMotionVectorsINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetMotionVectorsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetMotionVectorsINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetMotionVectorsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetMotionVectorsINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetMotionVectorsINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetInterDistortionsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterDistortionsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterDistortionsINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetInterDistortionsINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetInterDistortionsINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetInterDistortionsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetInterDistortionsINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterDistortionsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterDistortionsINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetInterDistortionsINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetBestInterDistortionsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetBestInterDistortionsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetBestInterDistortionsINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetBestInterDistortionsINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetBestInterDistortionsINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetBestInterDistortionsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetBestInterDistortionsINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetBestInterDistortionsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetBestInterDistortionsINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetBestInterDistortionsINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetInterMajorShapeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterMajorShapeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterMajorShapeINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetInterMajorShapeINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetInterMajorShapeINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetInterMajorShapeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetInterMajorShapeINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterMajorShapeINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterMajorShapeINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetInterMajorShapeINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetInterMinorShapeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterMinorShapeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterMinorShapeINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetInterMinorShapeINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetInterMinorShapeINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetInterMinorShapeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetInterMinorShapeINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterMinorShapeINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterMinorShapeINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetInterMinorShapeINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetInterDirectionsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterDirectionsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterDirectionsINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetInterDirectionsINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetInterDirectionsINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetInterDirectionsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetInterDirectionsINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterDirectionsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterDirectionsINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetInterDirectionsINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetInterMotionVectorCountINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterMotionVectorCountINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterMotionVectorCountINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetInterMotionVectorCountINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetInterMotionVectorCountINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetInterMotionVectorCountINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetInterMotionVectorCountINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterMotionVectorCountINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterMotionVectorCountINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetInterMotionVectorCountINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetInterReferenceIdsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterReferenceIdsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterReferenceIdsINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetInterReferenceIdsINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetInterReferenceIdsINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetInterReferenceIdsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetInterReferenceIdsINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterReferenceIdsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterReferenceIdsINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetInterReferenceIdsINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL | (1 << 16);
    }

    public OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceParameterFieldPolarities
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL inst) => inst.ResultId;
    public OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(int resultType, int resultId, int packedReferenceIds, int packedReferenceParameterFieldPolarities, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        PackedReferenceIds = packedReferenceIds;
        PackedReferenceParameterFieldPolarities = packedReferenceParameterFieldPolarities;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL, ResultType, ResultId, PackedReferenceIds, PackedReferenceParameterFieldPolarities, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packedReferenceIds":
                    PackedReferenceIds = o.ToLiteral<int>();
                    break;
                case "packedReferenceParameterFieldPolarities":
                    PackedReferenceParameterFieldPolarities = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeInitializeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeInitializeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeInitializeINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeInitializeINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeInitializeINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PartitionMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SADAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeInitializeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeInitializeINTEL(int resultType, int resultId, int srcCoord, int partitionMask, int sADAdjustment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcCoord = srcCoord;
        PartitionMask = partitionMask;
        SADAdjustment = sADAdjustment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeInitializeINTEL, ResultType, ResultId, SrcCoord, PartitionMask, SADAdjustment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcCoord":
                    SrcCoord = o.ToLiteral<int>();
                    break;
                case "partitionMask":
                    PartitionMask = o.ToLiteral<int>();
                    break;
                case "sADAdjustment":
                    SADAdjustment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeInitializeINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeInitializeINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeSetSingleReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetSingleReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetSingleReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeSetSingleReferenceINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeSetSingleReferenceINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SearchWindowConfig
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeSetSingleReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeSetSingleReferenceINTEL(int resultType, int resultId, int refOffset, int searchWindowConfig, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RefOffset = refOffset;
        SearchWindowConfig = searchWindowConfig;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetSingleReferenceINTEL, ResultType, ResultId, RefOffset, SearchWindowConfig, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "refOffset":
                    RefOffset = o.ToLiteral<int>();
                    break;
                case "searchWindowConfig":
                    SearchWindowConfig = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeSetSingleReferenceINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeSetSingleReferenceINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeSetDualReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetDualReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetDualReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeSetDualReferenceINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeSetDualReferenceINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int IdSearchWindowConfig
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeSetDualReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeSetDualReferenceINTEL(int resultType, int resultId, int fwdRefOffset, int bwdRefOffset, int idSearchWindowConfig, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        FwdRefOffset = fwdRefOffset;
        BwdRefOffset = bwdRefOffset;
        IdSearchWindowConfig = idSearchWindowConfig;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetDualReferenceINTEL, ResultType, ResultId, FwdRefOffset, BwdRefOffset, IdSearchWindowConfig, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "fwdRefOffset":
                    FwdRefOffset = o.ToLiteral<int>();
                    break;
                case "bwdRefOffset":
                    BwdRefOffset = o.ToLiteral<int>();
                    break;
                case "idSearchWindowConfig":
                    IdSearchWindowConfig = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeSetDualReferenceINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeSetDualReferenceINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeRefWindowSizeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeRefWindowSizeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeRefWindowSizeINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeRefWindowSizeINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeRefWindowSizeINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SearchWindowConfig
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int DualRef
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeRefWindowSizeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeRefWindowSizeINTEL(int resultType, int resultId, int searchWindowConfig, int dualRef)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SearchWindowConfig = searchWindowConfig;
        DualRef = dualRef;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeRefWindowSizeINTEL, ResultType, ResultId, SearchWindowConfig, DualRef];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "searchWindowConfig":
                    SearchWindowConfig = o.ToLiteral<int>();
                    break;
                case "dualRef":
                    DualRef = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeRefWindowSizeINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeRefWindowSizeINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeAdjustRefOffsetINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeAdjustRefOffsetINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeAdjustRefOffsetINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeAdjustRefOffsetINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeAdjustRefOffsetINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefOffset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefWindowSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ImageSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeAdjustRefOffsetINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeAdjustRefOffsetINTEL(int resultType, int resultId, int refOffset, int srcCoord, int refWindowSize, int imageSize)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RefOffset = refOffset;
        SrcCoord = srcCoord;
        RefWindowSize = refWindowSize;
        ImageSize = imageSize;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeAdjustRefOffsetINTEL, ResultType, ResultId, RefOffset, SrcCoord, RefWindowSize, ImageSize];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "refOffset":
                    RefOffset = o.ToLiteral<int>();
                    break;
                case "srcCoord":
                    SrcCoord = o.ToLiteral<int>();
                    break;
                case "refWindowSize":
                    RefWindowSize = o.ToLiteral<int>();
                    break;
                case "imageSize":
                    ImageSize = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeAdjustRefOffsetINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeAdjustRefOffsetINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeConvertToMcePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeConvertToMcePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeConvertToMcePayloadINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeConvertToMcePayloadINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeConvertToMcePayloadINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeConvertToMcePayloadINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeConvertToMcePayloadINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeConvertToMcePayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeConvertToMcePayloadINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeConvertToMcePayloadINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeSetMaxMotionVectorCountINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetMaxMotionVectorCountINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetMaxMotionVectorCountINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeSetMaxMotionVectorCountINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeSetMaxMotionVectorCountINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MaxMotionVectorCount
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeSetMaxMotionVectorCountINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeSetMaxMotionVectorCountINTEL(int resultType, int resultId, int maxMotionVectorCount, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        MaxMotionVectorCount = maxMotionVectorCount;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetMaxMotionVectorCountINTEL, ResultType, ResultId, MaxMotionVectorCount, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "maxMotionVectorCount":
                    MaxMotionVectorCount = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeSetMaxMotionVectorCountINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeSetMaxMotionVectorCountINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Threshold
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(int resultType, int resultId, int threshold, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Threshold = threshold;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL, ResultType, ResultId, Threshold, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "threshold":
                    Threshold = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeSetWeightedSadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeSetWeightedSadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeSetWeightedSadINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeSetWeightedSadINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeSetWeightedSadINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedSadWeights
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeSetWeightedSadINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeSetWeightedSadINTEL(int resultType, int resultId, int packedSadWeights, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        PackedSadWeights = packedSadWeights;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeSetWeightedSadINTEL, ResultType, ResultId, PackedSadWeights, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packedSadWeights":
                    PackedSadWeights = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeSetWeightedSadINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeSetWeightedSadINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(int resultType, int resultId, int srcImage, int refImage, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL, ResultType, ResultId, SrcImage, RefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "refImage":
                    RefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeEvaluateWithDualReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeEvaluateWithDualReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeEvaluateWithDualReferenceINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "fwdRefImage":
                    FwdRefImage = o.ToLiteral<int>();
                    break;
                case "bwdRefImage":
                    BwdRefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int StreaminComponents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(int resultType, int resultId, int srcImage, int refImage, int payload, int streaminComponents)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        StreaminComponents = streaminComponents;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL, ResultType, ResultId, SrcImage, RefImage, Payload, StreaminComponents];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "refImage":
                    RefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "streaminComponents":
                    StreaminComponents = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int StreaminComponents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload, int streaminComponents)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        StreaminComponents = streaminComponents;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload, StreaminComponents];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "fwdRefImage":
                    FwdRefImage = o.ToLiteral<int>();
                    break;
                case "bwdRefImage":
                    BwdRefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "streaminComponents":
                    StreaminComponents = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(int resultType, int resultId, int srcImage, int refImage, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL, ResultType, ResultId, SrcImage, RefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "refImage":
                    RefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "fwdRefImage":
                    FwdRefImage = o.ToLiteral<int>();
                    break;
                case "bwdRefImage":
                    BwdRefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int StreaminComponents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(int resultType, int resultId, int srcImage, int refImage, int payload, int streaminComponents)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
        StreaminComponents = streaminComponents;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL, ResultType, ResultId, SrcImage, RefImage, Payload, StreaminComponents];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "refImage":
                    RefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "streaminComponents":
                    StreaminComponents = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int StreaminComponents
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload, int streaminComponents)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
        StreaminComponents = streaminComponents;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload, StreaminComponents];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "fwdRefImage":
                    FwdRefImage = o.ToLiteral<int>();
                    break;
                case "bwdRefImage":
                    BwdRefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "streaminComponents":
                    StreaminComponents = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeConvertToMceResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeConvertToMceResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeConvertToMceResultINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeConvertToMceResultINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeConvertToMceResultINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeConvertToMceResultINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeConvertToMceResultINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeConvertToMceResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeConvertToMceResultINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeConvertToMceResultINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeGetSingleReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetSingleReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetSingleReferenceStreaminINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetSingleReferenceStreaminINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeGetSingleReferenceStreaminINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetSingleReferenceStreaminINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetSingleReferenceStreaminINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetSingleReferenceStreaminINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetSingleReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeGetSingleReferenceStreaminINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeGetDualReferenceStreaminINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetDualReferenceStreaminINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetDualReferenceStreaminINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetDualReferenceStreaminINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeGetDualReferenceStreaminINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetDualReferenceStreaminINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetDualReferenceStreaminINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetDualReferenceStreaminINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetDualReferenceStreaminINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeGetDualReferenceStreaminINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeStripDualReferenceStreamoutINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeStripDualReferenceStreamoutINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeStripDualReferenceStreamoutINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeStripDualReferenceStreamoutINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeStripDualReferenceStreamoutINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeStripDualReferenceStreamoutINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeStripDualReferenceStreamoutINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeStripDualReferenceStreamoutINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeStripDualReferenceStreamoutINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeStripDualReferenceStreamoutINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(int resultType, int resultId, int payload, int majorShape)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL, ResultType, ResultId, Payload, MajorShape];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "majorShape":
                    MajorShape = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(int resultType, int resultId, int payload, int majorShape)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL, ResultType, ResultId, Payload, MajorShape];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "majorShape":
                    MajorShape = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(int resultType, int resultId, int payload, int majorShape)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL, ResultType, ResultId, Payload, MajorShape];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "majorShape":
                    MajorShape = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(int resultType, int resultId, int payload, int majorShape, int direction)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        Direction = direction;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL, ResultType, ResultId, Payload, MajorShape, Direction];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "majorShape":
                    MajorShape = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(int resultType, int resultId, int payload, int majorShape, int direction)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        Direction = direction;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL, ResultType, ResultId, Payload, MajorShape, Direction];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "majorShape":
                    MajorShape = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShape
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(int resultType, int resultId, int payload, int majorShape, int direction)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
        MajorShape = majorShape;
        Direction = direction;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL, ResultType, ResultId, Payload, MajorShape, Direction];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
                case "majorShape":
                    MajorShape = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeGetBorderReachedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetBorderReachedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetBorderReachedINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetBorderReachedINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeGetBorderReachedINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ImageSelect
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetBorderReachedINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetBorderReachedINTEL(int resultType, int resultId, int imageSelect, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        ImageSelect = imageSelect;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetBorderReachedINTEL, ResultType, ResultId, ImageSelect, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "imageSelect":
                    ImageSelect = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetBorderReachedINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeGetBorderReachedINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL | (1 << 16);
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL inst) => inst.ResultId;
    public OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcFmeInitializeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcFmeInitializeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcFmeInitializeINTEL | (1 << 16);
    }

    public OpSubgroupAvcFmeInitializeINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcFmeInitializeINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MotionVectors
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShapes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinorShapes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PixelResolution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcFmeInitializeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcFmeInitializeINTEL(int resultType, int resultId, int srcCoord, int motionVectors, int majorShapes, int minorShapes, int direction, int pixelResolution, int sadAdjustment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcCoord = srcCoord;
        MotionVectors = motionVectors;
        MajorShapes = majorShapes;
        MinorShapes = minorShapes;
        Direction = direction;
        PixelResolution = pixelResolution;
        SadAdjustment = sadAdjustment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcFmeInitializeINTEL, ResultType, ResultId, SrcCoord, MotionVectors, MajorShapes, MinorShapes, Direction, PixelResolution, SadAdjustment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcCoord":
                    SrcCoord = o.ToLiteral<int>();
                    break;
                case "motionVectors":
                    MotionVectors = o.ToLiteral<int>();
                    break;
                case "majorShapes":
                    MajorShapes = o.ToLiteral<int>();
                    break;
                case "minorShapes":
                    MinorShapes = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "pixelResolution":
                    PixelResolution = o.ToLiteral<int>();
                    break;
                case "sadAdjustment":
                    SadAdjustment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcFmeInitializeINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcFmeInitializeINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcBmeInitializeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcBmeInitializeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcBmeInitializeINTEL | (1 << 16);
    }

    public OpSubgroupAvcBmeInitializeINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcBmeInitializeINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MotionVectors
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MajorShapes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinorShapes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PixelResolution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BidirectionalWeight
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcBmeInitializeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcBmeInitializeINTEL(int resultType, int resultId, int srcCoord, int motionVectors, int majorShapes, int minorShapes, int direction, int pixelResolution, int bidirectionalWeight, int sadAdjustment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcCoord = srcCoord;
        MotionVectors = motionVectors;
        MajorShapes = majorShapes;
        MinorShapes = minorShapes;
        Direction = direction;
        PixelResolution = pixelResolution;
        BidirectionalWeight = bidirectionalWeight;
        SadAdjustment = sadAdjustment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcBmeInitializeINTEL, ResultType, ResultId, SrcCoord, MotionVectors, MajorShapes, MinorShapes, Direction, PixelResolution, BidirectionalWeight, SadAdjustment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcCoord":
                    SrcCoord = o.ToLiteral<int>();
                    break;
                case "motionVectors":
                    MotionVectors = o.ToLiteral<int>();
                    break;
                case "majorShapes":
                    MajorShapes = o.ToLiteral<int>();
                    break;
                case "minorShapes":
                    MinorShapes = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
                case "pixelResolution":
                    PixelResolution = o.ToLiteral<int>();
                    break;
                case "bidirectionalWeight":
                    BidirectionalWeight = o.ToLiteral<int>();
                    break;
                case "sadAdjustment":
                    SadAdjustment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcBmeInitializeINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcBmeInitializeINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcRefConvertToMcePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefConvertToMcePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefConvertToMcePayloadINTEL | (1 << 16);
    }

    public OpSubgroupAvcRefConvertToMcePayloadINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcRefConvertToMcePayloadINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcRefConvertToMcePayloadINTEL inst) => inst.ResultId;
    public OpSubgroupAvcRefConvertToMcePayloadINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefConvertToMcePayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcRefConvertToMcePayloadINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcRefConvertToMcePayloadINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcRefSetBidirectionalMixDisableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefSetBidirectionalMixDisableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefSetBidirectionalMixDisableINTEL | (1 << 16);
    }

    public OpSubgroupAvcRefSetBidirectionalMixDisableINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcRefSetBidirectionalMixDisableINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcRefSetBidirectionalMixDisableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcRefSetBidirectionalMixDisableINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefSetBidirectionalMixDisableINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcRefSetBidirectionalMixDisableINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcRefSetBidirectionalMixDisableINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcRefSetBilinearFilterEnableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefSetBilinearFilterEnableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefSetBilinearFilterEnableINTEL | (1 << 16);
    }

    public OpSubgroupAvcRefSetBilinearFilterEnableINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcRefSetBilinearFilterEnableINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcRefSetBilinearFilterEnableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcRefSetBilinearFilterEnableINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefSetBilinearFilterEnableINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcRefSetBilinearFilterEnableINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcRefSetBilinearFilterEnableINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(int resultType, int resultId, int srcImage, int refImage, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL, ResultType, ResultId, SrcImage, RefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "refImage":
                    RefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcRefEvaluateWithDualReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefEvaluateWithDualReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefEvaluateWithDualReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcRefEvaluateWithDualReferenceINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcRefEvaluateWithDualReferenceINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcRefEvaluateWithDualReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcRefEvaluateWithDualReferenceINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefEvaluateWithDualReferenceINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "fwdRefImage":
                    FwdRefImage = o.ToLiteral<int>();
                    break;
                case "bwdRefImage":
                    BwdRefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcRefEvaluateWithDualReferenceINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcRefEvaluateWithDualReferenceINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(int resultType, int resultId, int srcImage, int packedReferenceIds, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        PackedReferenceIds = packedReferenceIds;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL, ResultType, ResultId, SrcImage, PackedReferenceIds, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "packedReferenceIds":
                    PackedReferenceIds = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL | (1 << 16);
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceFieldPolarities
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL inst) => inst.ResultId;
    public OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(int resultType, int resultId, int srcImage, int packedReferenceIds, int packedReferenceFieldPolarities, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        PackedReferenceIds = packedReferenceIds;
        PackedReferenceFieldPolarities = packedReferenceFieldPolarities;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL, ResultType, ResultId, SrcImage, PackedReferenceIds, PackedReferenceFieldPolarities, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "packedReferenceIds":
                    PackedReferenceIds = o.ToLiteral<int>();
                    break;
                case "packedReferenceFieldPolarities":
                    PackedReferenceFieldPolarities = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcRefConvertToMceResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcRefConvertToMceResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcRefConvertToMceResultINTEL | (1 << 16);
    }

    public OpSubgroupAvcRefConvertToMceResultINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcRefConvertToMceResultINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcRefConvertToMceResultINTEL inst) => inst.ResultId;
    public OpSubgroupAvcRefConvertToMceResultINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcRefConvertToMceResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcRefConvertToMceResultINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcRefConvertToMceResultINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicInitializeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicInitializeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicInitializeINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicInitializeINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicInitializeINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcCoord
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicInitializeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicInitializeINTEL(int resultType, int resultId, int srcCoord)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcCoord = srcCoord;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicInitializeINTEL, ResultType, ResultId, SrcCoord];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcCoord":
                    SrcCoord = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicInitializeINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicInitializeINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicConfigureSkcINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicConfigureSkcINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicConfigureSkcINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicConfigureSkcINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicConfigureSkcINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SkipBlockPartitionType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SkipMotionVectorMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MotionVectors
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BidirectionalWeight
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicConfigureSkcINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicConfigureSkcINTEL(int resultType, int resultId, int skipBlockPartitionType, int skipMotionVectorMask, int motionVectors, int bidirectionalWeight, int sadAdjustment, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SkipBlockPartitionType = skipBlockPartitionType;
        SkipMotionVectorMask = skipMotionVectorMask;
        MotionVectors = motionVectors;
        BidirectionalWeight = bidirectionalWeight;
        SadAdjustment = sadAdjustment;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicConfigureSkcINTEL, ResultType, ResultId, SkipBlockPartitionType, SkipMotionVectorMask, MotionVectors, BidirectionalWeight, SadAdjustment, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "skipBlockPartitionType":
                    SkipBlockPartitionType = o.ToLiteral<int>();
                    break;
                case "skipMotionVectorMask":
                    SkipMotionVectorMask = o.ToLiteral<int>();
                    break;
                case "motionVectors":
                    MotionVectors = o.ToLiteral<int>();
                    break;
                case "bidirectionalWeight":
                    BidirectionalWeight = o.ToLiteral<int>();
                    break;
                case "sadAdjustment":
                    SadAdjustment = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicConfigureSkcINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicConfigureSkcINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicConfigureIpeLumaINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicConfigureIpeLumaINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicConfigureIpeLumaINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicConfigureIpeLumaINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicConfigureIpeLumaINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LumaIntraPartitionMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int IntraNeighbourAvailabilty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LeftEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperLeftCornerLumaPixel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperRightEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicConfigureIpeLumaINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicConfigureIpeLumaINTEL(int resultType, int resultId, int lumaIntraPartitionMask, int intraNeighbourAvailabilty, int leftEdgeLumaPixels, int upperLeftCornerLumaPixel, int upperEdgeLumaPixels, int upperRightEdgeLumaPixels, int sadAdjustment, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        LumaIntraPartitionMask = lumaIntraPartitionMask;
        IntraNeighbourAvailabilty = intraNeighbourAvailabilty;
        LeftEdgeLumaPixels = leftEdgeLumaPixels;
        UpperLeftCornerLumaPixel = upperLeftCornerLumaPixel;
        UpperEdgeLumaPixels = upperEdgeLumaPixels;
        UpperRightEdgeLumaPixels = upperRightEdgeLumaPixels;
        SadAdjustment = sadAdjustment;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicConfigureIpeLumaINTEL, ResultType, ResultId, LumaIntraPartitionMask, IntraNeighbourAvailabilty, LeftEdgeLumaPixels, UpperLeftCornerLumaPixel, UpperEdgeLumaPixels, UpperRightEdgeLumaPixels, SadAdjustment, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "lumaIntraPartitionMask":
                    LumaIntraPartitionMask = o.ToLiteral<int>();
                    break;
                case "intraNeighbourAvailabilty":
                    IntraNeighbourAvailabilty = o.ToLiteral<int>();
                    break;
                case "leftEdgeLumaPixels":
                    LeftEdgeLumaPixels = o.ToLiteral<int>();
                    break;
                case "upperLeftCornerLumaPixel":
                    UpperLeftCornerLumaPixel = o.ToLiteral<int>();
                    break;
                case "upperEdgeLumaPixels":
                    UpperEdgeLumaPixels = o.ToLiteral<int>();
                    break;
                case "upperRightEdgeLumaPixels":
                    UpperRightEdgeLumaPixels = o.ToLiteral<int>();
                    break;
                case "sadAdjustment":
                    SadAdjustment = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicConfigureIpeLumaINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicConfigureIpeLumaINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicConfigureIpeLumaChromaINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicConfigureIpeLumaChromaINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicConfigureIpeLumaChromaINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicConfigureIpeLumaChromaINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicConfigureIpeLumaChromaINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LumaIntraPartitionMask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int IntraNeighbourAvailabilty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LeftEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperLeftCornerLumaPixel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperRightEdgeLumaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LeftEdgeChromaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperLeftCornerChromaPixel
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int UpperEdgeChromaPixels
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SadAdjustment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicConfigureIpeLumaChromaINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicConfigureIpeLumaChromaINTEL(int resultType, int resultId, int lumaIntraPartitionMask, int intraNeighbourAvailabilty, int leftEdgeLumaPixels, int upperLeftCornerLumaPixel, int upperEdgeLumaPixels, int upperRightEdgeLumaPixels, int leftEdgeChromaPixels, int upperLeftCornerChromaPixel, int upperEdgeChromaPixels, int sadAdjustment, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        LumaIntraPartitionMask = lumaIntraPartitionMask;
        IntraNeighbourAvailabilty = intraNeighbourAvailabilty;
        LeftEdgeLumaPixels = leftEdgeLumaPixels;
        UpperLeftCornerLumaPixel = upperLeftCornerLumaPixel;
        UpperEdgeLumaPixels = upperEdgeLumaPixels;
        UpperRightEdgeLumaPixels = upperRightEdgeLumaPixels;
        LeftEdgeChromaPixels = leftEdgeChromaPixels;
        UpperLeftCornerChromaPixel = upperLeftCornerChromaPixel;
        UpperEdgeChromaPixels = upperEdgeChromaPixels;
        SadAdjustment = sadAdjustment;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicConfigureIpeLumaChromaINTEL, ResultType, ResultId, LumaIntraPartitionMask, IntraNeighbourAvailabilty, LeftEdgeLumaPixels, UpperLeftCornerLumaPixel, UpperEdgeLumaPixels, UpperRightEdgeLumaPixels, LeftEdgeChromaPixels, UpperLeftCornerChromaPixel, UpperEdgeChromaPixels, SadAdjustment, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "lumaIntraPartitionMask":
                    LumaIntraPartitionMask = o.ToLiteral<int>();
                    break;
                case "intraNeighbourAvailabilty":
                    IntraNeighbourAvailabilty = o.ToLiteral<int>();
                    break;
                case "leftEdgeLumaPixels":
                    LeftEdgeLumaPixels = o.ToLiteral<int>();
                    break;
                case "upperLeftCornerLumaPixel":
                    UpperLeftCornerLumaPixel = o.ToLiteral<int>();
                    break;
                case "upperEdgeLumaPixels":
                    UpperEdgeLumaPixels = o.ToLiteral<int>();
                    break;
                case "upperRightEdgeLumaPixels":
                    UpperRightEdgeLumaPixels = o.ToLiteral<int>();
                    break;
                case "leftEdgeChromaPixels":
                    LeftEdgeChromaPixels = o.ToLiteral<int>();
                    break;
                case "upperLeftCornerChromaPixel":
                    UpperLeftCornerChromaPixel = o.ToLiteral<int>();
                    break;
                case "upperEdgeChromaPixels":
                    UpperEdgeChromaPixels = o.ToLiteral<int>();
                    break;
                case "sadAdjustment":
                    SadAdjustment = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicConfigureIpeLumaChromaINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicConfigureIpeLumaChromaINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicGetMotionVectorMaskINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetMotionVectorMaskINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetMotionVectorMaskINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetMotionVectorMaskINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicGetMotionVectorMaskINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SkipBlockPartitionType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Direction
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetMotionVectorMaskINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetMotionVectorMaskINTEL(int resultType, int resultId, int skipBlockPartitionType, int direction)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SkipBlockPartitionType = skipBlockPartitionType;
        Direction = direction;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetMotionVectorMaskINTEL, ResultType, ResultId, SkipBlockPartitionType, Direction];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "skipBlockPartitionType":
                    SkipBlockPartitionType = o.ToLiteral<int>();
                    break;
                case "direction":
                    Direction = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetMotionVectorMaskINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicGetMotionVectorMaskINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicConvertToMcePayloadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicConvertToMcePayloadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicConvertToMcePayloadINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicConvertToMcePayloadINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicConvertToMcePayloadINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicConvertToMcePayloadINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicConvertToMcePayloadINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicConvertToMcePayloadINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicConvertToMcePayloadINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicConvertToMcePayloadINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedShapePenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(int resultType, int resultId, int packedShapePenalty, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        PackedShapePenalty = packedShapePenalty;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL, ResultType, ResultId, PackedShapePenalty, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packedShapePenalty":
                    PackedShapePenalty = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LumaModePenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LumaPackedNeighborModes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int LumaPackedNonDcPenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(int resultType, int resultId, int lumaModePenalty, int lumaPackedNeighborModes, int lumaPackedNonDcPenalty, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        LumaModePenalty = lumaModePenalty;
        LumaPackedNeighborModes = lumaPackedNeighborModes;
        LumaPackedNonDcPenalty = lumaPackedNonDcPenalty;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL, ResultType, ResultId, LumaModePenalty, LumaPackedNeighborModes, LumaPackedNonDcPenalty, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "lumaModePenalty":
                    LumaModePenalty = o.ToLiteral<int>();
                    break;
                case "lumaPackedNeighborModes":
                    LumaPackedNeighborModes = o.ToLiteral<int>();
                    break;
                case "lumaPackedNonDcPenalty":
                    LumaPackedNonDcPenalty = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ChromaModeBasePenalty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(int resultType, int resultId, int chromaModeBasePenalty, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        ChromaModeBasePenalty = chromaModeBasePenalty;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL, ResultType, ResultId, ChromaModeBasePenalty, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "chromaModeBasePenalty":
                    ChromaModeBasePenalty = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicSetBilinearFilterEnableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetBilinearFilterEnableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetBilinearFilterEnableINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicSetBilinearFilterEnableINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicSetBilinearFilterEnableINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicSetBilinearFilterEnableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicSetBilinearFilterEnableINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetBilinearFilterEnableINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicSetBilinearFilterEnableINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicSetBilinearFilterEnableINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedSadCoefficients
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(int resultType, int resultId, int packedSadCoefficients, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        PackedSadCoefficients = packedSadCoefficients;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL, ResultType, ResultId, PackedSadCoefficients, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packedSadCoefficients":
                    PackedSadCoefficients = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BlockBasedSkipType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(int resultType, int resultId, int blockBasedSkipType, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BlockBasedSkipType = blockBasedSkipType;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL, ResultType, ResultId, BlockBasedSkipType, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "blockBasedSkipType":
                    BlockBasedSkipType = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicEvaluateIpeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicEvaluateIpeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicEvaluateIpeINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicEvaluateIpeINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicEvaluateIpeINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicEvaluateIpeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicEvaluateIpeINTEL(int resultType, int resultId, int srcImage, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicEvaluateIpeINTEL, ResultType, ResultId, SrcImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateIpeINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicEvaluateIpeINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(int resultType, int resultId, int srcImage, int refImage, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        RefImage = refImage;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL, ResultType, ResultId, SrcImage, RefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "refImage":
                    RefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicEvaluateWithDualReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicEvaluateWithDualReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicEvaluateWithDualReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicEvaluateWithDualReferenceINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicEvaluateWithDualReferenceINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BwdRefImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicEvaluateWithDualReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicEvaluateWithDualReferenceINTEL(int resultType, int resultId, int srcImage, int fwdRefImage, int bwdRefImage, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        FwdRefImage = fwdRefImage;
        BwdRefImage = bwdRefImage;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicEvaluateWithDualReferenceINTEL, ResultType, ResultId, SrcImage, FwdRefImage, BwdRefImage, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "fwdRefImage":
                    FwdRefImage = o.ToLiteral<int>();
                    break;
                case "bwdRefImage":
                    BwdRefImage = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateWithDualReferenceINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicEvaluateWithDualReferenceINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(int resultType, int resultId, int srcImage, int packedReferenceIds, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        PackedReferenceIds = packedReferenceIds;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL, ResultType, ResultId, SrcImage, PackedReferenceIds, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "packedReferenceIds":
                    PackedReferenceIds = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int SrcImage
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceIds
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PackedReferenceFieldPolarities
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(int resultType, int resultId, int srcImage, int packedReferenceIds, int packedReferenceFieldPolarities, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        SrcImage = srcImage;
        PackedReferenceIds = packedReferenceIds;
        PackedReferenceFieldPolarities = packedReferenceFieldPolarities;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL, ResultType, ResultId, SrcImage, PackedReferenceIds, PackedReferenceFieldPolarities, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "srcImage":
                    SrcImage = o.ToLiteral<int>();
                    break;
                case "packedReferenceIds":
                    PackedReferenceIds = o.ToLiteral<int>();
                    break;
                case "packedReferenceFieldPolarities":
                    PackedReferenceFieldPolarities = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicConvertToMceResultINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicConvertToMceResultINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicConvertToMceResultINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicConvertToMceResultINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicConvertToMceResultINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicConvertToMceResultINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicConvertToMceResultINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicConvertToMceResultINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicConvertToMceResultINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicConvertToMceResultINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicGetIpeLumaShapeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetIpeLumaShapeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetIpeLumaShapeINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetIpeLumaShapeINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicGetIpeLumaShapeINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetIpeLumaShapeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetIpeLumaShapeINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetIpeLumaShapeINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetIpeLumaShapeINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicGetIpeLumaShapeINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicGetPackedIpeLumaModesINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetPackedIpeLumaModesINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetPackedIpeLumaModesINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetPackedIpeLumaModesINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicGetPackedIpeLumaModesINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetPackedIpeLumaModesINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetPackedIpeLumaModesINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetPackedIpeLumaModesINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetPackedIpeLumaModesINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicGetPackedIpeLumaModesINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicGetIpeChromaModeINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetIpeChromaModeINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetIpeChromaModeINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetIpeChromaModeINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicGetIpeChromaModeINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetIpeChromaModeINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetIpeChromaModeINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetIpeChromaModeINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetIpeChromaModeINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicGetIpeChromaModeINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(OpData data) => new(data);
}

public struct OpSubgroupAvcSicGetInterRawSadsINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupAvcSicGetInterRawSadsINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupAvcSicGetInterRawSadsINTEL | (1 << 16);
    }

    public OpSubgroupAvcSicGetInterRawSadsINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupAvcSicGetInterRawSadsINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Payload
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSubgroupAvcSicGetInterRawSadsINTEL inst) => inst.ResultId;
    public OpSubgroupAvcSicGetInterRawSadsINTEL(int resultType, int resultId, int payload)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Payload = payload;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupAvcSicGetInterRawSadsINTEL, ResultType, ResultId, Payload];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "payload":
                    Payload = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupAvcSicGetInterRawSadsINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupAvcSicGetInterRawSadsINTEL(OpData data) => new(data);
}

public struct OpVariableLengthArrayINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpVariableLengthArrayINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpVariableLengthArrayINTEL | (1 << 16);
    }

    public OpVariableLengthArrayINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpVariableLengthArrayINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Lenght
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpVariableLengthArrayINTEL inst) => inst.ResultId;
    public OpVariableLengthArrayINTEL(int resultType, int resultId, int lenght)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Lenght = lenght;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpVariableLengthArrayINTEL, ResultType, ResultId, Lenght];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "lenght":
                    Lenght = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpVariableLengthArrayINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpVariableLengthArrayINTEL(OpData data) => new(data);
}

public struct OpSaveMemoryINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSaveMemoryINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSaveMemoryINTEL | (1 << 16);
    }

    public OpSaveMemoryINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSaveMemoryINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpSaveMemoryINTEL inst) => inst.ResultId;
    public OpSaveMemoryINTEL(int resultType, int resultId)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSaveMemoryINTEL, ResultType, ResultId];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSaveMemoryINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSaveMemoryINTEL(OpData data) => new(data);
}

public struct OpRestoreMemoryINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRestoreMemoryINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRestoreMemoryINTEL | (1 << 16);
    }

    public OpRestoreMemoryINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRestoreMemoryINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Ptr
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpRestoreMemoryINTEL(int ptr)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Ptr = ptr;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRestoreMemoryINTEL, Ptr];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "ptr":
                    Ptr = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRestoreMemoryINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpRestoreMemoryINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatSinCosPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSinCosPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSinCosPiINTEL | (1 << 16);
    }

    public OpArbitraryFloatSinCosPiINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatSinCosPiINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FromSign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatSinCosPiINTEL inst) => inst.ResultId;
    public OpArbitraryFloatSinCosPiINTEL(int resultType, int resultId, int a, int m1, int mout, int fromSign, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        FromSign = fromSign;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSinCosPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..FromSign.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "fromSign":
                    FromSign = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatSinCosPiINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatSinCosPiINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatCastINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCastINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCastINTEL | (1 << 16);
    }

    public OpArbitraryFloatCastINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatCastINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatCastINTEL inst) => inst.ResultId;
    public OpArbitraryFloatCastINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCastINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatCastINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatCastINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatCastFromIntINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCastFromIntINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCastFromIntINTEL | (1 << 16);
    }

    public OpArbitraryFloatCastFromIntINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatCastFromIntINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FromSign
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatCastFromIntINTEL inst) => inst.ResultId;
    public OpArbitraryFloatCastFromIntINTEL(int resultType, int resultId, int a, int mout, int fromSign, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        Mout = mout;
        FromSign = fromSign;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCastFromIntINTEL, ResultType, ResultId, A, ..Mout.AsDisposableLiteralValue().Words, ..FromSign.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "fromSign":
                    FromSign = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatCastFromIntINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatCastFromIntINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatCastToIntINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCastToIntINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCastToIntINTEL | (1 << 16);
    }

    public OpArbitraryFloatCastToIntINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatCastToIntINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatCastToIntINTEL inst) => inst.ResultId;
    public OpArbitraryFloatCastToIntINTEL(int resultType, int resultId, int a, int m1, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCastToIntINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatCastToIntINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatCastToIntINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatAddINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatAddINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatAddINTEL | (1 << 16);
    }

    public OpArbitraryFloatAddINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatAddINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatAddINTEL inst) => inst.ResultId;
    public OpArbitraryFloatAddINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatAddINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatAddINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatAddINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatSubINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSubINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSubINTEL | (1 << 16);
    }

    public OpArbitraryFloatSubINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatSubINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatSubINTEL inst) => inst.ResultId;
    public OpArbitraryFloatSubINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSubINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatSubINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatSubINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatMulINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatMulINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatMulINTEL | (1 << 16);
    }

    public OpArbitraryFloatMulINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatMulINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatMulINTEL inst) => inst.ResultId;
    public OpArbitraryFloatMulINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatMulINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatMulINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatMulINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatDivINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatDivINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatDivINTEL | (1 << 16);
    }

    public OpArbitraryFloatDivINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatDivINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatDivINTEL inst) => inst.ResultId;
    public OpArbitraryFloatDivINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatDivINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatDivINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatDivINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatGTINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatGTINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatGTINTEL | (1 << 16);
    }

    public OpArbitraryFloatGTINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatGTINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatGTINTEL inst) => inst.ResultId;
    public OpArbitraryFloatGTINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatGTINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatGTINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatGTINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatGEINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatGEINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatGEINTEL | (1 << 16);
    }

    public OpArbitraryFloatGEINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatGEINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatGEINTEL inst) => inst.ResultId;
    public OpArbitraryFloatGEINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatGEINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatGEINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatGEINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatLTINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLTINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLTINTEL | (1 << 16);
    }

    public OpArbitraryFloatLTINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatLTINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatLTINTEL inst) => inst.ResultId;
    public OpArbitraryFloatLTINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLTINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatLTINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatLTINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatLEINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLEINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLEINTEL | (1 << 16);
    }

    public OpArbitraryFloatLEINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatLEINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatLEINTEL inst) => inst.ResultId;
    public OpArbitraryFloatLEINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLEINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatLEINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatLEINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatEQINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatEQINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatEQINTEL | (1 << 16);
    }

    public OpArbitraryFloatEQINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatEQINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatEQINTEL inst) => inst.ResultId;
    public OpArbitraryFloatEQINTEL(int resultType, int resultId, int a, int m1, int b, int m2)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatEQINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatEQINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatEQINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatRecipINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatRecipINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatRecipINTEL | (1 << 16);
    }

    public OpArbitraryFloatRecipINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatRecipINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatRecipINTEL inst) => inst.ResultId;
    public OpArbitraryFloatRecipINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatRecipINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatRecipINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatRecipINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatRSqrtINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatRSqrtINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatRSqrtINTEL | (1 << 16);
    }

    public OpArbitraryFloatRSqrtINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatRSqrtINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatRSqrtINTEL inst) => inst.ResultId;
    public OpArbitraryFloatRSqrtINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatRSqrtINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatRSqrtINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatRSqrtINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatCbrtINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCbrtINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCbrtINTEL | (1 << 16);
    }

    public OpArbitraryFloatCbrtINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatCbrtINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatCbrtINTEL inst) => inst.ResultId;
    public OpArbitraryFloatCbrtINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCbrtINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatCbrtINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatCbrtINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatHypotINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatHypotINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatHypotINTEL | (1 << 16);
    }

    public OpArbitraryFloatHypotINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatHypotINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatHypotINTEL inst) => inst.ResultId;
    public OpArbitraryFloatHypotINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatHypotINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatHypotINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatHypotINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatSqrtINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSqrtINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSqrtINTEL | (1 << 16);
    }

    public OpArbitraryFloatSqrtINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatSqrtINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatSqrtINTEL inst) => inst.ResultId;
    public OpArbitraryFloatSqrtINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSqrtINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatSqrtINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatSqrtINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatLogINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLogINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLogINTEL | (1 << 16);
    }

    public OpArbitraryFloatLogINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatLogINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatLogINTEL inst) => inst.ResultId;
    public OpArbitraryFloatLogINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLogINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatLogINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatLogINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatLog2INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLog2INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLog2INTEL | (1 << 16);
    }

    public OpArbitraryFloatLog2INTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatLog2INTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatLog2INTEL inst) => inst.ResultId;
    public OpArbitraryFloatLog2INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLog2INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatLog2INTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatLog2INTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatLog10INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLog10INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLog10INTEL | (1 << 16);
    }

    public OpArbitraryFloatLog10INTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatLog10INTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatLog10INTEL inst) => inst.ResultId;
    public OpArbitraryFloatLog10INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLog10INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatLog10INTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatLog10INTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatLog1pINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatLog1pINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatLog1pINTEL | (1 << 16);
    }

    public OpArbitraryFloatLog1pINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatLog1pINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatLog1pINTEL inst) => inst.ResultId;
    public OpArbitraryFloatLog1pINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatLog1pINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatLog1pINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatLog1pINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatExpINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatExpINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatExpINTEL | (1 << 16);
    }

    public OpArbitraryFloatExpINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatExpINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatExpINTEL inst) => inst.ResultId;
    public OpArbitraryFloatExpINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatExpINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatExpINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatExpINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatExp2INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatExp2INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatExp2INTEL | (1 << 16);
    }

    public OpArbitraryFloatExp2INTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatExp2INTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatExp2INTEL inst) => inst.ResultId;
    public OpArbitraryFloatExp2INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatExp2INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatExp2INTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatExp2INTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatExp10INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatExp10INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatExp10INTEL | (1 << 16);
    }

    public OpArbitraryFloatExp10INTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatExp10INTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatExp10INTEL inst) => inst.ResultId;
    public OpArbitraryFloatExp10INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatExp10INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatExp10INTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatExp10INTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatExpm1INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatExpm1INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatExpm1INTEL | (1 << 16);
    }

    public OpArbitraryFloatExpm1INTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatExpm1INTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatExpm1INTEL inst) => inst.ResultId;
    public OpArbitraryFloatExpm1INTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatExpm1INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatExpm1INTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatExpm1INTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatSinINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSinINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSinINTEL | (1 << 16);
    }

    public OpArbitraryFloatSinINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatSinINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatSinINTEL inst) => inst.ResultId;
    public OpArbitraryFloatSinINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSinINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatSinINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatSinINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatCosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCosINTEL | (1 << 16);
    }

    public OpArbitraryFloatCosINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatCosINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatCosINTEL inst) => inst.ResultId;
    public OpArbitraryFloatCosINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCosINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatCosINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatCosINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatSinCosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSinCosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSinCosINTEL | (1 << 16);
    }

    public OpArbitraryFloatSinCosINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatSinCosINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatSinCosINTEL inst) => inst.ResultId;
    public OpArbitraryFloatSinCosINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSinCosINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatSinCosINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatSinCosINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatSinPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatSinPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatSinPiINTEL | (1 << 16);
    }

    public OpArbitraryFloatSinPiINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatSinPiINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatSinPiINTEL inst) => inst.ResultId;
    public OpArbitraryFloatSinPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatSinPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatSinPiINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatSinPiINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatCosPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatCosPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatCosPiINTEL | (1 << 16);
    }

    public OpArbitraryFloatCosPiINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatCosPiINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatCosPiINTEL inst) => inst.ResultId;
    public OpArbitraryFloatCosPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatCosPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatCosPiINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatCosPiINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatASinINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatASinINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatASinINTEL | (1 << 16);
    }

    public OpArbitraryFloatASinINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatASinINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatASinINTEL inst) => inst.ResultId;
    public OpArbitraryFloatASinINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatASinINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatASinINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatASinINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatASinPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatASinPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatASinPiINTEL | (1 << 16);
    }

    public OpArbitraryFloatASinPiINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatASinPiINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatASinPiINTEL inst) => inst.ResultId;
    public OpArbitraryFloatASinPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatASinPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatASinPiINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatASinPiINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatACosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatACosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatACosINTEL | (1 << 16);
    }

    public OpArbitraryFloatACosINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatACosINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatACosINTEL inst) => inst.ResultId;
    public OpArbitraryFloatACosINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatACosINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatACosINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatACosINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatACosPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatACosPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatACosPiINTEL | (1 << 16);
    }

    public OpArbitraryFloatACosPiINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatACosPiINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatACosPiINTEL inst) => inst.ResultId;
    public OpArbitraryFloatACosPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatACosPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatACosPiINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatACosPiINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatATanINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatATanINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatATanINTEL | (1 << 16);
    }

    public OpArbitraryFloatATanINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatATanINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatATanINTEL inst) => inst.ResultId;
    public OpArbitraryFloatATanINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatATanINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatATanINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatATanINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatATanPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatATanPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatATanPiINTEL | (1 << 16);
    }

    public OpArbitraryFloatATanPiINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatATanPiINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatATanPiINTEL inst) => inst.ResultId;
    public OpArbitraryFloatATanPiINTEL(int resultType, int resultId, int a, int m1, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatATanPiINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatATanPiINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatATanPiINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatATan2INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatATan2INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatATan2INTEL | (1 << 16);
    }

    public OpArbitraryFloatATan2INTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatATan2INTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatATan2INTEL inst) => inst.ResultId;
    public OpArbitraryFloatATan2INTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatATan2INTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatATan2INTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatATan2INTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatPowINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatPowINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatPowINTEL | (1 << 16);
    }

    public OpArbitraryFloatPowINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatPowINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatPowINTEL inst) => inst.ResultId;
    public OpArbitraryFloatPowINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatPowINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatPowINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatPowINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatPowRINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatPowRINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatPowRINTEL | (1 << 16);
    }

    public OpArbitraryFloatPowRINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatPowRINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M2
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatPowRINTEL inst) => inst.ResultId;
    public OpArbitraryFloatPowRINTEL(int resultType, int resultId, int a, int m1, int b, int m2, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        M2 = m2;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatPowRINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..M2.AsDisposableLiteralValue().Words, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "m2":
                    M2 = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatPowRINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatPowRINTEL(OpData data) => new(data);
}

public struct OpArbitraryFloatPowNINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArbitraryFloatPowNINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArbitraryFloatPowNINTEL | (1 << 16);
    }

    public OpArbitraryFloatPowNINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArbitraryFloatPowNINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int M1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mout
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int EnableSubnormals
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingMode
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RoundingAccuracy
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArbitraryFloatPowNINTEL inst) => inst.ResultId;
    public OpArbitraryFloatPowNINTEL(int resultType, int resultId, int a, int m1, int b, int mout, int enableSubnormals, int roundingMode, int roundingAccuracy)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        A = a;
        M1 = m1;
        B = b;
        Mout = mout;
        EnableSubnormals = enableSubnormals;
        RoundingMode = roundingMode;
        RoundingAccuracy = roundingAccuracy;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArbitraryFloatPowNINTEL, ResultType, ResultId, A, ..M1.AsDisposableLiteralValue().Words, B, ..Mout.AsDisposableLiteralValue().Words, ..EnableSubnormals.AsDisposableLiteralValue().Words, ..RoundingMode.AsDisposableLiteralValue().Words, ..RoundingAccuracy.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "m1":
                    M1 = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "mout":
                    Mout = o.ToLiteral<int>();
                    break;
                case "enableSubnormals":
                    EnableSubnormals = o.ToLiteral<int>();
                    break;
                case "roundingMode":
                    RoundingMode = o.ToLiteral<int>();
                    break;
                case "roundingAccuracy":
                    RoundingAccuracy = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArbitraryFloatPowNINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpArbitraryFloatPowNINTEL(OpData data) => new(data);
}

public struct OpLoopControlINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpLoopControlINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpLoopControlINTEL | (1 << 16);
    }

    public OpLoopControlINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpLoopControlINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpLoopControlINTEL(LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpLoopControlINTEL, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpLoopControlINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpLoopControlINTEL(OpData data) => new(data);
}

public struct OpAliasDomainDeclINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAliasDomainDeclINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAliasDomainDeclINTEL | (1 << 16);
    }

    public OpAliasDomainDeclINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAliasDomainDeclINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAliasDomainDeclINTEL inst) => inst.ResultId;
    public OpAliasDomainDeclINTEL(int resultId, int? name)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        Name = name;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAliasDomainDeclINTEL, ResultId, ..(Name is null ? (Span<int>)[] : [Name.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "name":
                    if (o.Words.Length > 0)
                        Name = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpAliasDomainDeclINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpAliasDomainDeclINTEL(OpData data) => new(data);
}

public struct OpAliasScopeDeclINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAliasScopeDeclINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAliasScopeDeclINTEL | (1 << 16);
    }

    public OpAliasScopeDeclINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAliasScopeDeclINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int AliasDomain
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int? Name
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAliasScopeDeclINTEL inst) => inst.ResultId;
    public OpAliasScopeDeclINTEL(int resultId, int aliasDomain, int? name)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        AliasDomain = aliasDomain;
        Name = name;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAliasScopeDeclINTEL, ResultId, AliasDomain, ..(Name is null ? (Span<int>)[] : [Name.Value])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "aliasDomain":
                    AliasDomain = o.ToLiteral<int>();
                    break;
                case "name":
                    if (o.Words.Length > 0)
                        Name = o.ToLiteral<int?>();
                    break;
            }
        }
    }

    public static implicit operator OpAliasScopeDeclINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpAliasScopeDeclINTEL(OpData data) => new(data);
}

public struct OpAliasScopeListDeclINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAliasScopeListDeclINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAliasScopeListDeclINTEL | (1 << 16);
    }

    public OpAliasScopeListDeclINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAliasScopeListDeclINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAliasScopeListDeclINTEL inst) => inst.ResultId;
    public OpAliasScopeListDeclINTEL(int resultId, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAliasScopeListDeclINTEL, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAliasScopeListDeclINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpAliasScopeListDeclINTEL(OpData data) => new(data);
}

public struct OpFixedSqrtINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedSqrtINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedSqrtINTEL | (1 << 16);
    }

    public OpFixedSqrtINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFixedSqrtINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedSqrtINTEL inst) => inst.ResultId;
    public OpFixedSqrtINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedSqrtINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFixedSqrtINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpFixedSqrtINTEL(OpData data) => new(data);
}

public struct OpFixedRecipINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedRecipINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedRecipINTEL | (1 << 16);
    }

    public OpFixedRecipINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFixedRecipINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedRecipINTEL inst) => inst.ResultId;
    public OpFixedRecipINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedRecipINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFixedRecipINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpFixedRecipINTEL(OpData data) => new(data);
}

public struct OpFixedRsqrtINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedRsqrtINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedRsqrtINTEL | (1 << 16);
    }

    public OpFixedRsqrtINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFixedRsqrtINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedRsqrtINTEL inst) => inst.ResultId;
    public OpFixedRsqrtINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedRsqrtINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFixedRsqrtINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpFixedRsqrtINTEL(OpData data) => new(data);
}

public struct OpFixedSinINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedSinINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedSinINTEL | (1 << 16);
    }

    public OpFixedSinINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFixedSinINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedSinINTEL inst) => inst.ResultId;
    public OpFixedSinINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedSinINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFixedSinINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpFixedSinINTEL(OpData data) => new(data);
}

public struct OpFixedCosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedCosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedCosINTEL | (1 << 16);
    }

    public OpFixedCosINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFixedCosINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedCosINTEL inst) => inst.ResultId;
    public OpFixedCosINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedCosINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFixedCosINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpFixedCosINTEL(OpData data) => new(data);
}

public struct OpFixedSinCosINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedSinCosINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedSinCosINTEL | (1 << 16);
    }

    public OpFixedSinCosINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFixedSinCosINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedSinCosINTEL inst) => inst.ResultId;
    public OpFixedSinCosINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedSinCosINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFixedSinCosINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpFixedSinCosINTEL(OpData data) => new(data);
}

public struct OpFixedSinPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedSinPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedSinPiINTEL | (1 << 16);
    }

    public OpFixedSinPiINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFixedSinPiINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedSinPiINTEL inst) => inst.ResultId;
    public OpFixedSinPiINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedSinPiINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFixedSinPiINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpFixedSinPiINTEL(OpData data) => new(data);
}

public struct OpFixedCosPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedCosPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedCosPiINTEL | (1 << 16);
    }

    public OpFixedCosPiINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFixedCosPiINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedCosPiINTEL inst) => inst.ResultId;
    public OpFixedCosPiINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedCosPiINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFixedCosPiINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpFixedCosPiINTEL(OpData data) => new(data);
}

public struct OpFixedSinCosPiINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedSinCosPiINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedSinCosPiINTEL | (1 << 16);
    }

    public OpFixedSinCosPiINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFixedSinCosPiINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedSinCosPiINTEL inst) => inst.ResultId;
    public OpFixedSinCosPiINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedSinCosPiINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFixedSinCosPiINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpFixedSinCosPiINTEL(OpData data) => new(data);
}

public struct OpFixedLogINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedLogINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedLogINTEL | (1 << 16);
    }

    public OpFixedLogINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFixedLogINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedLogINTEL inst) => inst.ResultId;
    public OpFixedLogINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedLogINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFixedLogINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpFixedLogINTEL(OpData data) => new(data);
}

public struct OpFixedExpINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFixedExpINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFixedExpINTEL | (1 << 16);
    }

    public OpFixedExpINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFixedExpINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int InputType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int S
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RI
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Q
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int O
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFixedExpINTEL inst) => inst.ResultId;
    public OpFixedExpINTEL(int resultType, int resultId, int inputType, int input, int s, int i, int rI, int q, int o)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        InputType = inputType;
        Input = input;
        S = s;
        I = i;
        RI = rI;
        Q = q;
        O = o;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFixedExpINTEL, ResultType, ResultId, InputType, Input, ..S.AsDisposableLiteralValue().Words, ..I.AsDisposableLiteralValue().Words, ..RI.AsDisposableLiteralValue().Words, ..Q.AsDisposableLiteralValue().Words, ..O.AsDisposableLiteralValue().Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "inputType":
                    InputType = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
                case "s":
                    S = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "rI":
                    RI = o.ToLiteral<int>();
                    break;
                case "q":
                    Q = o.ToLiteral<int>();
                    break;
                case "o":
                    O = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFixedExpINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpFixedExpINTEL(OpData data) => new(data);
}

public struct OpPtrCastToCrossWorkgroupINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpPtrCastToCrossWorkgroupINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpPtrCastToCrossWorkgroupINTEL | (1 << 16);
    }

    public OpPtrCastToCrossWorkgroupINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpPtrCastToCrossWorkgroupINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpPtrCastToCrossWorkgroupINTEL inst) => inst.ResultId;
    public OpPtrCastToCrossWorkgroupINTEL(int resultType, int resultId, int pointer)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpPtrCastToCrossWorkgroupINTEL, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpPtrCastToCrossWorkgroupINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpPtrCastToCrossWorkgroupINTEL(OpData data) => new(data);
}

public struct OpCrossWorkgroupCastToPtrINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCrossWorkgroupCastToPtrINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCrossWorkgroupCastToPtrINTEL | (1 << 16);
    }

    public OpCrossWorkgroupCastToPtrINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCrossWorkgroupCastToPtrINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCrossWorkgroupCastToPtrINTEL inst) => inst.ResultId;
    public OpCrossWorkgroupCastToPtrINTEL(int resultType, int resultId, int pointer)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCrossWorkgroupCastToPtrINTEL, ResultType, ResultId, Pointer];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCrossWorkgroupCastToPtrINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpCrossWorkgroupCastToPtrINTEL(OpData data) => new(data);
}

public struct OpReadPipeBlockingINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpReadPipeBlockingINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpReadPipeBlockingINTEL | (1 << 16);
    }

    public OpReadPipeBlockingINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpReadPipeBlockingINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpReadPipeBlockingINTEL inst) => inst.ResultId;
    public OpReadPipeBlockingINTEL(int resultType, int resultId, int packetSize, int packetAlignment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpReadPipeBlockingINTEL, ResultType, ResultId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpReadPipeBlockingINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpReadPipeBlockingINTEL(OpData data) => new(data);
}

public struct OpWritePipeBlockingINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpWritePipeBlockingINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpWritePipeBlockingINTEL | (1 << 16);
    }

    public OpWritePipeBlockingINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpWritePipeBlockingINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketSize
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PacketAlignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpWritePipeBlockingINTEL inst) => inst.ResultId;
    public OpWritePipeBlockingINTEL(int resultType, int resultId, int packetSize, int packetAlignment)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        PacketSize = packetSize;
        PacketAlignment = packetAlignment;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpWritePipeBlockingINTEL, ResultType, ResultId, PacketSize, PacketAlignment];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "packetSize":
                    PacketSize = o.ToLiteral<int>();
                    break;
                case "packetAlignment":
                    PacketAlignment = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpWritePipeBlockingINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpWritePipeBlockingINTEL(OpData data) => new(data);
}

public struct OpFPGARegINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpFPGARegINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpFPGARegINTEL | (1 << 16);
    }

    public OpFPGARegINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpFPGARegINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Result
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Input
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpFPGARegINTEL inst) => inst.ResultId;
    public OpFPGARegINTEL(int resultType, int resultId, int result, int input)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Result = result;
        Input = input;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpFPGARegINTEL, ResultType, ResultId, Result, Input];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "result":
                    Result = o.ToLiteral<int>();
                    break;
                case "input":
                    Input = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpFPGARegINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpFPGARegINTEL(OpData data) => new(data);
}

public struct OpRayQueryGetRayTMinKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetRayTMinKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetRayTMinKHR | (1 << 16);
    }

    public OpRayQueryGetRayTMinKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetRayTMinKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetRayTMinKHR inst) => inst.ResultId;
    public OpRayQueryGetRayTMinKHR(int resultType, int resultId, int rayQuery)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetRayTMinKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetRayTMinKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetRayTMinKHR(OpData data) => new(data);
}

public struct OpRayQueryGetRayFlagsKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetRayFlagsKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetRayFlagsKHR | (1 << 16);
    }

    public OpRayQueryGetRayFlagsKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetRayFlagsKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetRayFlagsKHR inst) => inst.ResultId;
    public OpRayQueryGetRayFlagsKHR(int resultType, int resultId, int rayQuery)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetRayFlagsKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetRayFlagsKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetRayFlagsKHR(OpData data) => new(data);
}

public struct OpRayQueryGetIntersectionTKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionTKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionTKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionTKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetIntersectionTKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionTKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionTKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionTKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionTKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetIntersectionTKHR(OpData data) => new(data);
}

public struct OpRayQueryGetIntersectionInstanceCustomIndexKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionInstanceCustomIndexKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionInstanceCustomIndexKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionInstanceCustomIndexKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetIntersectionInstanceCustomIndexKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionInstanceCustomIndexKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionInstanceCustomIndexKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionInstanceCustomIndexKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionInstanceCustomIndexKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetIntersectionInstanceCustomIndexKHR(OpData data) => new(data);
}

public struct OpRayQueryGetIntersectionInstanceIdKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionInstanceIdKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionInstanceIdKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionInstanceIdKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetIntersectionInstanceIdKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionInstanceIdKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionInstanceIdKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionInstanceIdKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionInstanceIdKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetIntersectionInstanceIdKHR(OpData data) => new(data);
}

public struct OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(OpData data) => new(data);
}

public struct OpRayQueryGetIntersectionGeometryIndexKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionGeometryIndexKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionGeometryIndexKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionGeometryIndexKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetIntersectionGeometryIndexKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionGeometryIndexKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionGeometryIndexKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionGeometryIndexKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionGeometryIndexKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetIntersectionGeometryIndexKHR(OpData data) => new(data);
}

public struct OpRayQueryGetIntersectionPrimitiveIndexKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionPrimitiveIndexKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionPrimitiveIndexKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionPrimitiveIndexKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetIntersectionPrimitiveIndexKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionPrimitiveIndexKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionPrimitiveIndexKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionPrimitiveIndexKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionPrimitiveIndexKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetIntersectionPrimitiveIndexKHR(OpData data) => new(data);
}

public struct OpRayQueryGetIntersectionBarycentricsKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionBarycentricsKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionBarycentricsKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionBarycentricsKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetIntersectionBarycentricsKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionBarycentricsKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionBarycentricsKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionBarycentricsKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionBarycentricsKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetIntersectionBarycentricsKHR(OpData data) => new(data);
}

public struct OpRayQueryGetIntersectionFrontFaceKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionFrontFaceKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionFrontFaceKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionFrontFaceKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetIntersectionFrontFaceKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionFrontFaceKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionFrontFaceKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionFrontFaceKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionFrontFaceKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetIntersectionFrontFaceKHR(OpData data) => new(data);
}

public struct OpRayQueryGetIntersectionCandidateAABBOpaqueKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionCandidateAABBOpaqueKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionCandidateAABBOpaqueKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionCandidateAABBOpaqueKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetIntersectionCandidateAABBOpaqueKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionCandidateAABBOpaqueKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionCandidateAABBOpaqueKHR(int resultType, int resultId, int rayQuery)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionCandidateAABBOpaqueKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionCandidateAABBOpaqueKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetIntersectionCandidateAABBOpaqueKHR(OpData data) => new(data);
}

public struct OpRayQueryGetIntersectionObjectRayDirectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionObjectRayDirectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionObjectRayDirectionKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionObjectRayDirectionKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetIntersectionObjectRayDirectionKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionObjectRayDirectionKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionObjectRayDirectionKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionObjectRayDirectionKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionObjectRayDirectionKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetIntersectionObjectRayDirectionKHR(OpData data) => new(data);
}

public struct OpRayQueryGetIntersectionObjectRayOriginKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionObjectRayOriginKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionObjectRayOriginKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionObjectRayOriginKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetIntersectionObjectRayOriginKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionObjectRayOriginKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionObjectRayOriginKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionObjectRayOriginKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionObjectRayOriginKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetIntersectionObjectRayOriginKHR(OpData data) => new(data);
}

public struct OpRayQueryGetWorldRayDirectionKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetWorldRayDirectionKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetWorldRayDirectionKHR | (1 << 16);
    }

    public OpRayQueryGetWorldRayDirectionKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetWorldRayDirectionKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetWorldRayDirectionKHR inst) => inst.ResultId;
    public OpRayQueryGetWorldRayDirectionKHR(int resultType, int resultId, int rayQuery)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetWorldRayDirectionKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetWorldRayDirectionKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetWorldRayDirectionKHR(OpData data) => new(data);
}

public struct OpRayQueryGetWorldRayOriginKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetWorldRayOriginKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetWorldRayOriginKHR | (1 << 16);
    }

    public OpRayQueryGetWorldRayOriginKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetWorldRayOriginKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetWorldRayOriginKHR inst) => inst.ResultId;
    public OpRayQueryGetWorldRayOriginKHR(int resultType, int resultId, int rayQuery)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetWorldRayOriginKHR, ResultType, ResultId, RayQuery];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetWorldRayOriginKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetWorldRayOriginKHR(OpData data) => new(data);
}

public struct OpRayQueryGetIntersectionObjectToWorldKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionObjectToWorldKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionObjectToWorldKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionObjectToWorldKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetIntersectionObjectToWorldKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionObjectToWorldKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionObjectToWorldKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionObjectToWorldKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionObjectToWorldKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetIntersectionObjectToWorldKHR(OpData data) => new(data);
}

public struct OpRayQueryGetIntersectionWorldToObjectKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpRayQueryGetIntersectionWorldToObjectKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpRayQueryGetIntersectionWorldToObjectKHR | (1 << 16);
    }

    public OpRayQueryGetIntersectionWorldToObjectKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpRayQueryGetIntersectionWorldToObjectKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int RayQuery
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Intersection
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpRayQueryGetIntersectionWorldToObjectKHR inst) => inst.ResultId;
    public OpRayQueryGetIntersectionWorldToObjectKHR(int resultType, int resultId, int rayQuery, int intersection)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        RayQuery = rayQuery;
        Intersection = intersection;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpRayQueryGetIntersectionWorldToObjectKHR, ResultType, ResultId, RayQuery, Intersection];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "rayQuery":
                    RayQuery = o.ToLiteral<int>();
                    break;
                case "intersection":
                    Intersection = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpRayQueryGetIntersectionWorldToObjectKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpRayQueryGetIntersectionWorldToObjectKHR(OpData data) => new(data);
}

public struct OpAtomicFAddEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpAtomicFAddEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpAtomicFAddEXT | (1 << 16);
    }

    public OpAtomicFAddEXT(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpAtomicFAddEXT(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Pointer
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpAtomicFAddEXT inst) => inst.ResultId;
    public OpAtomicFAddEXT(int resultType, int resultId, int pointer, int memory, int semantics, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Pointer = pointer;
        Memory = memory;
        Semantics = semantics;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpAtomicFAddEXT, ResultType, ResultId, Pointer, Memory, Semantics, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "pointer":
                    Pointer = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpAtomicFAddEXT(OpDataIndex odi) => new(odi);
    public static implicit operator OpAtomicFAddEXT(OpData data) => new(data);
}

public struct OpTypeBufferSurfaceINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeBufferSurfaceINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeBufferSurfaceINTEL | (1 << 16);
    }

    public OpTypeBufferSurfaceINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeBufferSurfaceINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public AccessQualifier AccessQualifier
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpTypeBufferSurfaceINTEL inst) => inst.ResultId;
    public OpTypeBufferSurfaceINTEL(int resultId, AccessQualifier accessQualifier)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultId = resultId;
        AccessQualifier = accessQualifier;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeBufferSurfaceINTEL, ResultId, (int)AccessQualifier];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "accessQualifier":
                    AccessQualifier = o.ToEnum<AccessQualifier>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeBufferSurfaceINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeBufferSurfaceINTEL(OpData data) => new(data);
}

public struct OpTypeStructContinuedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpTypeStructContinuedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpTypeStructContinuedINTEL | (1 << 16);
    }

    public OpTypeStructContinuedINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpTypeStructContinuedINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpTypeStructContinuedINTEL(LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpTypeStructContinuedINTEL, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpTypeStructContinuedINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpTypeStructContinuedINTEL(OpData data) => new(data);
}

public struct OpConstantCompositeContinuedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConstantCompositeContinuedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConstantCompositeContinuedINTEL | (1 << 16);
    }

    public OpConstantCompositeContinuedINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConstantCompositeContinuedINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpConstantCompositeContinuedINTEL(LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConstantCompositeContinuedINTEL, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConstantCompositeContinuedINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpConstantCompositeContinuedINTEL(OpData data) => new(data);
}

public struct OpSpecConstantCompositeContinuedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSpecConstantCompositeContinuedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSpecConstantCompositeContinuedINTEL | (1 << 16);
    }

    public OpSpecConstantCompositeContinuedINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSpecConstantCompositeContinuedINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSpecConstantCompositeContinuedINTEL(LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSpecConstantCompositeContinuedINTEL, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpSpecConstantCompositeContinuedINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSpecConstantCompositeContinuedINTEL(OpData data) => new(data);
}

public struct OpCompositeConstructContinuedINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpCompositeConstructContinuedINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpCompositeConstructContinuedINTEL | (1 << 16);
    }

    public OpCompositeConstructContinuedINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpCompositeConstructContinuedINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public LiteralArray<int> Values
    {
        get;
        set
        {
            field.Assign(value);
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpCompositeConstructContinuedINTEL inst) => inst.ResultId;
    public OpCompositeConstructContinuedINTEL(int resultType, int resultId, LiteralArray<int> values)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Values = values;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpCompositeConstructContinuedINTEL, ResultType, ResultId, ..Values.Words];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "values":
                    Values = o.ToLiteralArray<int>();
                    break;
            }
        }
    }

    public static implicit operator OpCompositeConstructContinuedINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpCompositeConstructContinuedINTEL(OpData data) => new(data);
}

public struct OpConvertFToBF16INTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertFToBF16INTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertFToBF16INTEL | (1 << 16);
    }

    public OpConvertFToBF16INTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConvertFToBF16INTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FloatValue
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertFToBF16INTEL inst) => inst.ResultId;
    public OpConvertFToBF16INTEL(int resultType, int resultId, int floatValue)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        FloatValue = floatValue;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertFToBF16INTEL, ResultType, ResultId, FloatValue];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "floatValue":
                    FloatValue = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConvertFToBF16INTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpConvertFToBF16INTEL(OpData data) => new(data);
}

public struct OpConvertBF16ToFINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpConvertBF16ToFINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpConvertBF16ToFINTEL | (1 << 16);
    }

    public OpConvertBF16ToFINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpConvertBF16ToFINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int BFloat16Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpConvertBF16ToFINTEL inst) => inst.ResultId;
    public OpConvertBF16ToFINTEL(int resultType, int resultId, int bFloat16Value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        BFloat16Value = bFloat16Value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpConvertBF16ToFINTEL, ResultType, ResultId, BFloat16Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "bFloat16Value":
                    BFloat16Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpConvertBF16ToFINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpConvertBF16ToFINTEL(OpData data) => new(data);
}

public struct OpControlBarrierArriveINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpControlBarrierArriveINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpControlBarrierArriveINTEL | (1 << 16);
    }

    public OpControlBarrierArriveINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpControlBarrierArriveINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpControlBarrierArriveINTEL(int execution, int memory, int semantics)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Execution = execution;
        Memory = memory;
        Semantics = semantics;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpControlBarrierArriveINTEL, Execution, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpControlBarrierArriveINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpControlBarrierArriveINTEL(OpData data) => new(data);
}

public struct OpControlBarrierWaitINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpControlBarrierWaitINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpControlBarrierWaitINTEL | (1 << 16);
    }

    public OpControlBarrierWaitINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpControlBarrierWaitINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Memory
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Semantics
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpControlBarrierWaitINTEL(int execution, int memory, int semantics)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Execution = execution;
        Memory = memory;
        Semantics = semantics;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpControlBarrierWaitINTEL, Execution, Memory, Semantics];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "memory":
                    Memory = o.ToLiteral<int>();
                    break;
                case "semantics":
                    Semantics = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpControlBarrierWaitINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpControlBarrierWaitINTEL(OpData data) => new(data);
}

public struct OpArithmeticFenceEXT : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpArithmeticFenceEXT()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpArithmeticFenceEXT | (1 << 16);
    }

    public OpArithmeticFenceEXT(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpArithmeticFenceEXT(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Target
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpArithmeticFenceEXT inst) => inst.ResultId;
    public OpArithmeticFenceEXT(int resultType, int resultId, int target)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Target = target;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpArithmeticFenceEXT, ResultType, ResultId, Target];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "target":
                    Target = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpArithmeticFenceEXT(OpDataIndex odi) => new(odi);
    public static implicit operator OpArithmeticFenceEXT(OpData data) => new(data);
}

public struct OpSubgroupBlockPrefetchINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpSubgroupBlockPrefetchINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpSubgroupBlockPrefetchINTEL | (1 << 16);
    }

    public OpSubgroupBlockPrefetchINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpSubgroupBlockPrefetchINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int Ptr
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int NumBytes
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public ParameterizedFlag<MemoryAccessMask>? Memoryaccess
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpSubgroupBlockPrefetchINTEL(int ptr, int numBytes, ParameterizedFlag<MemoryAccessMask>? memoryaccess)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Ptr = ptr;
        NumBytes = numBytes;
        Memoryaccess = memoryaccess;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpSubgroupBlockPrefetchINTEL, Ptr, NumBytes, ..(Memoryaccess is null ? (Span<int>)[] : [(int)Memoryaccess.Value.Value, ..Memoryaccess.Value.Span])];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "ptr":
                    Ptr = o.ToLiteral<int>();
                    break;
                case "numBytes":
                    NumBytes = o.ToLiteral<int>();
                    break;
                case "memoryaccess":
                    if (o.Words.Length > 0)
                        Memoryaccess = o.ToEnum<MemoryAccessMask>();
                    break;
            }
        }
    }

    public static implicit operator OpSubgroupBlockPrefetchINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpSubgroupBlockPrefetchINTEL(OpData data) => new(data);
}

public struct OpGroupIMulKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupIMulKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupIMulKHR | (1 << 16);
    }

    public OpGroupIMulKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupIMulKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupIMulKHR inst) => inst.ResultId;
    public OpGroupIMulKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupIMulKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupIMulKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupIMulKHR(OpData data) => new(data);
}

public struct OpGroupFMulKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupFMulKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupFMulKHR | (1 << 16);
    }

    public OpGroupFMulKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupFMulKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupFMulKHR inst) => inst.ResultId;
    public OpGroupFMulKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupFMulKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupFMulKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupFMulKHR(OpData data) => new(data);
}

public struct OpGroupBitwiseAndKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupBitwiseAndKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupBitwiseAndKHR | (1 << 16);
    }

    public OpGroupBitwiseAndKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupBitwiseAndKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupBitwiseAndKHR inst) => inst.ResultId;
    public OpGroupBitwiseAndKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupBitwiseAndKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupBitwiseAndKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupBitwiseAndKHR(OpData data) => new(data);
}

public struct OpGroupBitwiseOrKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupBitwiseOrKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupBitwiseOrKHR | (1 << 16);
    }

    public OpGroupBitwiseOrKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupBitwiseOrKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupBitwiseOrKHR inst) => inst.ResultId;
    public OpGroupBitwiseOrKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupBitwiseOrKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupBitwiseOrKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupBitwiseOrKHR(OpData data) => new(data);
}

public struct OpGroupBitwiseXorKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupBitwiseXorKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupBitwiseXorKHR | (1 << 16);
    }

    public OpGroupBitwiseXorKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupBitwiseXorKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupBitwiseXorKHR inst) => inst.ResultId;
    public OpGroupBitwiseXorKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupBitwiseXorKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupBitwiseXorKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupBitwiseXorKHR(OpData data) => new(data);
}

public struct OpGroupLogicalAndKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupLogicalAndKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupLogicalAndKHR | (1 << 16);
    }

    public OpGroupLogicalAndKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupLogicalAndKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupLogicalAndKHR inst) => inst.ResultId;
    public OpGroupLogicalAndKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupLogicalAndKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupLogicalAndKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupLogicalAndKHR(OpData data) => new(data);
}

public struct OpGroupLogicalOrKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupLogicalOrKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupLogicalOrKHR | (1 << 16);
    }

    public OpGroupLogicalOrKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupLogicalOrKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupLogicalOrKHR inst) => inst.ResultId;
    public OpGroupLogicalOrKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupLogicalOrKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupLogicalOrKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupLogicalOrKHR(OpData data) => new(data);
}

public struct OpGroupLogicalXorKHR : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpGroupLogicalXorKHR()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpGroupLogicalXorKHR | (1 << 16);
    }

    public OpGroupLogicalXorKHR(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpGroupLogicalXorKHR(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Execution
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public GroupOperation Operation
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpGroupLogicalXorKHR inst) => inst.ResultId;
    public OpGroupLogicalXorKHR(int resultType, int resultId, int execution, GroupOperation operation, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Execution = execution;
        Operation = operation;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpGroupLogicalXorKHR, ResultType, ResultId, Execution, (int)Operation, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "execution":
                    Execution = o.ToLiteral<int>();
                    break;
                case "operation":
                    Operation = o.ToEnum<GroupOperation>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpGroupLogicalXorKHR(OpDataIndex odi) => new(odi);
    public static implicit operator OpGroupLogicalXorKHR(OpData data) => new(data);
}

public struct OpMaskedGatherINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMaskedGatherINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMaskedGatherINTEL | (1 << 16);
    }

    public OpMaskedGatherINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpMaskedGatherINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PtrVector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Alignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int FillEmpty
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (OpMaskedGatherINTEL inst) => inst.ResultId;
    public OpMaskedGatherINTEL(int resultType, int resultId, int ptrVector, int alignment, int mask, int fillEmpty)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        PtrVector = ptrVector;
        Alignment = alignment;
        Mask = mask;
        FillEmpty = fillEmpty;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMaskedGatherINTEL, ResultType, ResultId, PtrVector, ..Alignment.AsDisposableLiteralValue().Words, Mask, FillEmpty];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "ptrVector":
                    PtrVector = o.ToLiteral<int>();
                    break;
                case "alignment":
                    Alignment = o.ToLiteral<int>();
                    break;
                case "mask":
                    Mask = o.ToLiteral<int>();
                    break;
                case "fillEmpty":
                    FillEmpty = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpMaskedGatherINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpMaskedGatherINTEL(OpData data) => new(data);
}

public struct OpMaskedScatterINTEL : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public OpMaskedScatterINTEL()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpMaskedScatterINTEL | (1 << 16);
    }

    public OpMaskedScatterINTEL(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public OpMaskedScatterINTEL(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int InputVector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int PtrVector
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Alignment
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Mask
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public OpMaskedScatterINTEL(int inputVector, int ptrVector, int alignment, int mask)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InputVector = inputVector;
        PtrVector = ptrVector;
        Alignment = alignment;
        Mask = mask;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpMaskedScatterINTEL, InputVector, PtrVector, ..Alignment.AsDisposableLiteralValue().Words, Mask];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "inputVector":
                    InputVector = o.ToLiteral<int>();
                    break;
                case "ptrVector":
                    PtrVector = o.ToLiteral<int>();
                    break;
                case "alignment":
                    Alignment = o.ToLiteral<int>();
                    break;
                case "mask":
                    Mask = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator OpMaskedScatterINTEL(OpDataIndex odi) => new(odi);
    public static implicit operator OpMaskedScatterINTEL(OpData data) => new(data);
}

public struct GLSLRound : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLRound()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLRound(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLRound(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLRound inst) => inst.ResultId;
    public GLSLRound(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLRound(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLRound(OpData data) => new(data);
}

public struct GLSLRoundEven : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLRoundEven()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLRoundEven(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLRoundEven(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLRoundEven inst) => inst.ResultId;
    public GLSLRoundEven(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLRoundEven(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLRoundEven(OpData data) => new(data);
}

public struct GLSLTrunc : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLTrunc()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLTrunc(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLTrunc(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLTrunc inst) => inst.ResultId;
    public GLSLTrunc(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLTrunc(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLTrunc(OpData data) => new(data);
}

public struct GLSLFAbs : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFAbs()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFAbs(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLFAbs(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFAbs inst) => inst.ResultId;
    public GLSLFAbs(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLFAbs(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLFAbs(OpData data) => new(data);
}

public struct GLSLSAbs : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSAbs()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSAbs(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLSAbs(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSAbs inst) => inst.ResultId;
    public GLSLSAbs(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLSAbs(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLSAbs(OpData data) => new(data);
}

public struct GLSLFSign : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFSign()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFSign(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLFSign(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFSign inst) => inst.ResultId;
    public GLSLFSign(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLFSign(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLFSign(OpData data) => new(data);
}

public struct GLSLSSign : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSSign()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSSign(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLSSign(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSSign inst) => inst.ResultId;
    public GLSLSSign(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLSSign(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLSSign(OpData data) => new(data);
}

public struct GLSLFloor : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFloor()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFloor(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLFloor(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFloor inst) => inst.ResultId;
    public GLSLFloor(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLFloor(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLFloor(OpData data) => new(data);
}

public struct GLSLCeil : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLCeil()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLCeil(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLCeil(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLCeil inst) => inst.ResultId;
    public GLSLCeil(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLCeil(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLCeil(OpData data) => new(data);
}

public struct GLSLFract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFract()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFract(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLFract(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFract inst) => inst.ResultId;
    public GLSLFract(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLFract(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLFract(OpData data) => new(data);
}

public struct GLSLRadians : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLRadians()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLRadians(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLRadians(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Degrees
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLRadians inst) => inst.ResultId;
    public GLSLRadians(int resultType, int resultId, int set, int degrees)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Degrees = degrees;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, Degrees];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "degrees":
                    Degrees = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLRadians(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLRadians(OpData data) => new(data);
}

public struct GLSLDegrees : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLDegrees()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLDegrees(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLDegrees(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Radians
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLDegrees inst) => inst.ResultId;
    public GLSLDegrees(int resultType, int resultId, int set, int radians)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Radians = radians;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, Radians];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "radians":
                    Radians = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLDegrees(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLDegrees(OpData data) => new(data);
}

public struct GLSLSin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSin(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLSin(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSin inst) => inst.ResultId;
    public GLSLSin(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLSin(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLSin(OpData data) => new(data);
}

public struct GLSLCos : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLCos()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLCos(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLCos(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLCos inst) => inst.ResultId;
    public GLSLCos(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLCos(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLCos(OpData data) => new(data);
}

public struct GLSLTan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLTan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLTan(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLTan(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLTan inst) => inst.ResultId;
    public GLSLTan(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLTan(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLTan(OpData data) => new(data);
}

public struct GLSLAsin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLAsin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLAsin(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLAsin(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLAsin inst) => inst.ResultId;
    public GLSLAsin(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLAsin(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLAsin(OpData data) => new(data);
}

public struct GLSLAcos : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLAcos()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLAcos(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLAcos(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLAcos inst) => inst.ResultId;
    public GLSLAcos(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLAcos(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLAcos(OpData data) => new(data);
}

public struct GLSLAtan : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLAtan()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLAtan(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLAtan(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y_over_x
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLAtan inst) => inst.ResultId;
    public GLSLAtan(int resultType, int resultId, int set, int y_over_x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Y_over_x = y_over_x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, Y_over_x];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "y_over_x":
                    Y_over_x = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLAtan(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLAtan(OpData data) => new(data);
}

public struct GLSLSinh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSinh()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSinh(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLSinh(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSinh inst) => inst.ResultId;
    public GLSLSinh(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLSinh(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLSinh(OpData data) => new(data);
}

public struct GLSLCosh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLCosh()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLCosh(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLCosh(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLCosh inst) => inst.ResultId;
    public GLSLCosh(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLCosh(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLCosh(OpData data) => new(data);
}

public struct GLSLTanh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLTanh()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLTanh(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLTanh(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLTanh inst) => inst.ResultId;
    public GLSLTanh(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLTanh(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLTanh(OpData data) => new(data);
}

public struct GLSLAsinh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLAsinh()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLAsinh(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLAsinh(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLAsinh inst) => inst.ResultId;
    public GLSLAsinh(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLAsinh(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLAsinh(OpData data) => new(data);
}

public struct GLSLAcosh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLAcosh()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLAcosh(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLAcosh(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLAcosh inst) => inst.ResultId;
    public GLSLAcosh(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLAcosh(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLAcosh(OpData data) => new(data);
}

public struct GLSLAtanh : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLAtanh()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLAtanh(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLAtanh(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLAtanh inst) => inst.ResultId;
    public GLSLAtanh(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLAtanh(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLAtanh(OpData data) => new(data);
}

public struct GLSLAtan2 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLAtan2()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLAtan2(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLAtan2(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLAtan2 inst) => inst.ResultId;
    public GLSLAtan2(int resultType, int resultId, int set, int y, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Y = y;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, Y, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLAtan2(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLAtan2(OpData data) => new(data);
}

public struct GLSLPow : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLPow()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLPow(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLPow(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLPow inst) => inst.ResultId;
    public GLSLPow(int resultType, int resultId, int set, int x, int y)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLPow(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLPow(OpData data) => new(data);
}

public struct GLSLExp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLExp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLExp(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLExp(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLExp inst) => inst.ResultId;
    public GLSLExp(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLExp(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLExp(OpData data) => new(data);
}

public struct GLSLLog : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLLog()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLLog(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLLog(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLLog inst) => inst.ResultId;
    public GLSLLog(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLLog(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLLog(OpData data) => new(data);
}

public struct GLSLExp2 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLExp2()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLExp2(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLExp2(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLExp2 inst) => inst.ResultId;
    public GLSLExp2(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLExp2(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLExp2(OpData data) => new(data);
}

public struct GLSLLog2 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLLog2()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLLog2(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLLog2(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLLog2 inst) => inst.ResultId;
    public GLSLLog2(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLLog2(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLLog2(OpData data) => new(data);
}

public struct GLSLSqrt : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSqrt()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSqrt(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLSqrt(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSqrt inst) => inst.ResultId;
    public GLSLSqrt(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLSqrt(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLSqrt(OpData data) => new(data);
}

public struct GLSLInverseSqrt : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLInverseSqrt()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLInverseSqrt(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLInverseSqrt(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLInverseSqrt inst) => inst.ResultId;
    public GLSLInverseSqrt(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLInverseSqrt(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLInverseSqrt(OpData data) => new(data);
}

public struct GLSLDeterminant : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLDeterminant()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLDeterminant(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLDeterminant(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLDeterminant inst) => inst.ResultId;
    public GLSLDeterminant(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLDeterminant(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLDeterminant(OpData data) => new(data);
}

public struct GLSLMatrixInverse : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLMatrixInverse()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLMatrixInverse(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLMatrixInverse(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLMatrixInverse inst) => inst.ResultId;
    public GLSLMatrixInverse(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLMatrixInverse(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLMatrixInverse(OpData data) => new(data);
}

public struct GLSLModf : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLModf()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLModf(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLModf(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLModf inst) => inst.ResultId;
    public GLSLModf(int resultType, int resultId, int set, int x, int i)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        I = i;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, I];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLModf(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLModf(OpData data) => new(data);
}

public struct GLSLModfStruct : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLModfStruct()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLModfStruct(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLModfStruct(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLModfStruct inst) => inst.ResultId;
    public GLSLModfStruct(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLModfStruct(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLModfStruct(OpData data) => new(data);
}

public struct GLSLFMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFMin(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLFMin(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFMin inst) => inst.ResultId;
    public GLSLFMin(int resultType, int resultId, int set, int x, int y)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLFMin(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLFMin(OpData data) => new(data);
}

public struct GLSLUMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUMin(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLUMin(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUMin inst) => inst.ResultId;
    public GLSLUMin(int resultType, int resultId, int set, int x, int y)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLUMin(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLUMin(OpData data) => new(data);
}

public struct GLSLSMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSMin(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLSMin(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSMin inst) => inst.ResultId;
    public GLSLSMin(int resultType, int resultId, int set, int x, int y)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLSMin(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLSMin(OpData data) => new(data);
}

public struct GLSLFMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFMax(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLFMax(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFMax inst) => inst.ResultId;
    public GLSLFMax(int resultType, int resultId, int set, int x, int y)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLFMax(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLFMax(OpData data) => new(data);
}

public struct GLSLUMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUMax(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLUMax(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUMax inst) => inst.ResultId;
    public GLSLUMax(int resultType, int resultId, int set, int x, int y)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLUMax(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLUMax(OpData data) => new(data);
}

public struct GLSLSMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSMax(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLSMax(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSMax inst) => inst.ResultId;
    public GLSLSMax(int resultType, int resultId, int set, int x, int y)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLSMax(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLSMax(OpData data) => new(data);
}

public struct GLSLFClamp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFClamp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFClamp(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLFClamp(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MaxVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFClamp inst) => inst.ResultId;
    public GLSLFClamp(int resultType, int resultId, int set, int x, int minVal, int maxVal)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        MinVal = minVal;
        MaxVal = maxVal;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, MinVal, MaxVal];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "minVal":
                    MinVal = o.ToLiteral<int>();
                    break;
                case "maxVal":
                    MaxVal = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLFClamp(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLFClamp(OpData data) => new(data);
}

public struct GLSLUClamp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUClamp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUClamp(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLUClamp(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MaxVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUClamp inst) => inst.ResultId;
    public GLSLUClamp(int resultType, int resultId, int set, int x, int minVal, int maxVal)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        MinVal = minVal;
        MaxVal = maxVal;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, MinVal, MaxVal];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "minVal":
                    MinVal = o.ToLiteral<int>();
                    break;
                case "maxVal":
                    MaxVal = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLUClamp(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLUClamp(OpData data) => new(data);
}

public struct GLSLSClamp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSClamp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSClamp(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLSClamp(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MaxVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSClamp inst) => inst.ResultId;
    public GLSLSClamp(int resultType, int resultId, int set, int x, int minVal, int maxVal)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        MinVal = minVal;
        MaxVal = maxVal;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, MinVal, MaxVal];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "minVal":
                    MinVal = o.ToLiteral<int>();
                    break;
                case "maxVal":
                    MaxVal = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLSClamp(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLSClamp(OpData data) => new(data);
}

public struct GLSLFMix : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFMix()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFMix(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLFMix(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFMix inst) => inst.ResultId;
    public GLSLFMix(int resultType, int resultId, int set, int x, int y, int a)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        A = a;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, Y, A];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLFMix(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLFMix(OpData data) => new(data);
}

public struct GLSLIMix : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLIMix()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLIMix(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLIMix(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLIMix inst) => inst.ResultId;
    public GLSLIMix(int resultType, int resultId, int set, int x, int y, int a)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
        A = a;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, Y, A];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLIMix(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLIMix(OpData data) => new(data);
}

public struct GLSLStep : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLStep()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLStep(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLStep(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Edge
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLStep inst) => inst.ResultId;
    public GLSLStep(int resultType, int resultId, int set, int edge, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Edge = edge;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, Edge, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "edge":
                    Edge = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLStep(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLStep(OpData data) => new(data);
}

public struct GLSLSmoothStep : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLSmoothStep()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLSmoothStep(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLSmoothStep(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Edge0
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Edge1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLSmoothStep inst) => inst.ResultId;
    public GLSLSmoothStep(int resultType, int resultId, int set, int edge0, int edge1, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Edge0 = edge0;
        Edge1 = edge1;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, Edge0, Edge1, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "edge0":
                    Edge0 = o.ToLiteral<int>();
                    break;
                case "edge1":
                    Edge1 = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLSmoothStep(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLSmoothStep(OpData data) => new(data);
}

public struct GLSLFma : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFma()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFma(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLFma(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int A
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int B
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int C
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFma inst) => inst.ResultId;
    public GLSLFma(int resultType, int resultId, int set, int a, int b, int c)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        A = a;
        B = b;
        C = c;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, A, B, C];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "a":
                    A = o.ToLiteral<int>();
                    break;
                case "b":
                    B = o.ToLiteral<int>();
                    break;
                case "c":
                    C = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLFma(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLFma(OpData data) => new(data);
}

public struct GLSLFrexp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFrexp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFrexp(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLFrexp(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Exp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFrexp inst) => inst.ResultId;
    public GLSLFrexp(int resultType, int resultId, int set, int x, int exp)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Exp = exp;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, Exp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "exp":
                    Exp = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLFrexp(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLFrexp(OpData data) => new(data);
}

public struct GLSLFrexpStruct : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFrexpStruct()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFrexpStruct(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLFrexpStruct(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFrexpStruct inst) => inst.ResultId;
    public GLSLFrexpStruct(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLFrexpStruct(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLFrexpStruct(OpData data) => new(data);
}

public struct GLSLLdexp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLLdexp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLLdexp(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLLdexp(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Exp
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLLdexp inst) => inst.ResultId;
    public GLSLLdexp(int resultType, int resultId, int set, int x, int exp)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Exp = exp;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, Exp];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "exp":
                    Exp = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLLdexp(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLLdexp(OpData data) => new(data);
}

public struct GLSLPackSnorm4x8 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLPackSnorm4x8()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLPackSnorm4x8(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLPackSnorm4x8(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLPackSnorm4x8 inst) => inst.ResultId;
    public GLSLPackSnorm4x8(int resultType, int resultId, int set, int v)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "v":
                    V = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLPackSnorm4x8(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLPackSnorm4x8(OpData data) => new(data);
}

public struct GLSLPackUnorm4x8 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLPackUnorm4x8()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLPackUnorm4x8(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLPackUnorm4x8(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLPackUnorm4x8 inst) => inst.ResultId;
    public GLSLPackUnorm4x8(int resultType, int resultId, int set, int v)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "v":
                    V = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLPackUnorm4x8(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLPackUnorm4x8(OpData data) => new(data);
}

public struct GLSLPackSnorm2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLPackSnorm2x16()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLPackSnorm2x16(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLPackSnorm2x16(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLPackSnorm2x16 inst) => inst.ResultId;
    public GLSLPackSnorm2x16(int resultType, int resultId, int set, int v)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "v":
                    V = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLPackSnorm2x16(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLPackSnorm2x16(OpData data) => new(data);
}

public struct GLSLPackUnorm2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLPackUnorm2x16()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLPackUnorm2x16(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLPackUnorm2x16(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLPackUnorm2x16 inst) => inst.ResultId;
    public GLSLPackUnorm2x16(int resultType, int resultId, int set, int v)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "v":
                    V = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLPackUnorm2x16(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLPackUnorm2x16(OpData data) => new(data);
}

public struct GLSLPackHalf2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLPackHalf2x16()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLPackHalf2x16(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLPackHalf2x16(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLPackHalf2x16 inst) => inst.ResultId;
    public GLSLPackHalf2x16(int resultType, int resultId, int set, int v)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "v":
                    V = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLPackHalf2x16(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLPackHalf2x16(OpData data) => new(data);
}

public struct GLSLPackDouble2x32 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLPackDouble2x32()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLPackDouble2x32(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLPackDouble2x32(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLPackDouble2x32 inst) => inst.ResultId;
    public GLSLPackDouble2x32(int resultType, int resultId, int set, int v)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "v":
                    V = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLPackDouble2x32(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLPackDouble2x32(OpData data) => new(data);
}

public struct GLSLUnpackSnorm2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUnpackSnorm2x16()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUnpackSnorm2x16(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLUnpackSnorm2x16(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUnpackSnorm2x16 inst) => inst.ResultId;
    public GLSLUnpackSnorm2x16(int resultType, int resultId, int set, int p)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P = p;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLUnpackSnorm2x16(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLUnpackSnorm2x16(OpData data) => new(data);
}

public struct GLSLUnpackUnorm2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUnpackUnorm2x16()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUnpackUnorm2x16(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLUnpackUnorm2x16(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUnpackUnorm2x16 inst) => inst.ResultId;
    public GLSLUnpackUnorm2x16(int resultType, int resultId, int set, int p)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P = p;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLUnpackUnorm2x16(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLUnpackUnorm2x16(OpData data) => new(data);
}

public struct GLSLUnpackHalf2x16 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUnpackHalf2x16()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUnpackHalf2x16(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLUnpackHalf2x16(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUnpackHalf2x16 inst) => inst.ResultId;
    public GLSLUnpackHalf2x16(int resultType, int resultId, int set, int v)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "v":
                    V = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLUnpackHalf2x16(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLUnpackHalf2x16(OpData data) => new(data);
}

public struct GLSLUnpackSnorm4x8 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUnpackSnorm4x8()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUnpackSnorm4x8(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLUnpackSnorm4x8(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUnpackSnorm4x8 inst) => inst.ResultId;
    public GLSLUnpackSnorm4x8(int resultType, int resultId, int set, int p)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P = p;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLUnpackSnorm4x8(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLUnpackSnorm4x8(OpData data) => new(data);
}

public struct GLSLUnpackUnorm4x8 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUnpackUnorm4x8()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUnpackUnorm4x8(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLUnpackUnorm4x8(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUnpackUnorm4x8 inst) => inst.ResultId;
    public GLSLUnpackUnorm4x8(int resultType, int resultId, int set, int p)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P = p;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, P];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "p":
                    P = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLUnpackUnorm4x8(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLUnpackUnorm4x8(OpData data) => new(data);
}

public struct GLSLUnpackDouble2x32 : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLUnpackDouble2x32()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLUnpackDouble2x32(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLUnpackDouble2x32(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int V
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLUnpackDouble2x32 inst) => inst.ResultId;
    public GLSLUnpackDouble2x32(int resultType, int resultId, int set, int v)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        V = v;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, V];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "v":
                    V = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLUnpackDouble2x32(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLUnpackDouble2x32(OpData data) => new(data);
}

public struct GLSLLength : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLLength()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLLength(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLLength(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLLength inst) => inst.ResultId;
    public GLSLLength(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLLength(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLLength(OpData data) => new(data);
}

public struct GLSLDistance : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLDistance()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLDistance(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLDistance(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P0
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int P1
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLDistance inst) => inst.ResultId;
    public GLSLDistance(int resultType, int resultId, int set, int p0, int p1)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        P0 = p0;
        P1 = p1;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, P0, P1];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "p0":
                    P0 = o.ToLiteral<int>();
                    break;
                case "p1":
                    P1 = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLDistance(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLDistance(OpData data) => new(data);
}

public struct GLSLCross : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLCross()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLCross(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLCross(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLCross inst) => inst.ResultId;
    public GLSLCross(int resultType, int resultId, int set, int x, int y)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLCross(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLCross(OpData data) => new(data);
}

public struct GLSLNormalize : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLNormalize()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLNormalize(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLNormalize(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLNormalize inst) => inst.ResultId;
    public GLSLNormalize(int resultType, int resultId, int set, int x)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLNormalize(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLNormalize(OpData data) => new(data);
}

public struct GLSLFaceForward : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFaceForward()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFaceForward(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLFaceForward(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int N
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Nref
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFaceForward inst) => inst.ResultId;
    public GLSLFaceForward(int resultType, int resultId, int set, int n, int i, int nref)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        N = n;
        I = i;
        Nref = nref;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, N, I, Nref];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "n":
                    N = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "nref":
                    Nref = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLFaceForward(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLFaceForward(OpData data) => new(data);
}

public struct GLSLReflect : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLReflect()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLReflect(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLReflect(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int N
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLReflect inst) => inst.ResultId;
    public GLSLReflect(int resultType, int resultId, int set, int i, int n)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        I = i;
        N = n;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, I, N];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "n":
                    N = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLReflect(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLReflect(OpData data) => new(data);
}

public struct GLSLRefract : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLRefract()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLRefract(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLRefract(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int I
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int N
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Eta
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLRefract inst) => inst.ResultId;
    public GLSLRefract(int resultType, int resultId, int set, int i, int n, int eta)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        I = i;
        N = n;
        Eta = eta;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, I, N, Eta];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "i":
                    I = o.ToLiteral<int>();
                    break;
                case "n":
                    N = o.ToLiteral<int>();
                    break;
                case "eta":
                    Eta = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLRefract(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLRefract(OpData data) => new(data);
}

public struct GLSLFindILsb : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFindILsb()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFindILsb(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLFindILsb(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFindILsb inst) => inst.ResultId;
    public GLSLFindILsb(int resultType, int resultId, int set, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLFindILsb(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLFindILsb(OpData data) => new(data);
}

public struct GLSLFindSMsb : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFindSMsb()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFindSMsb(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLFindSMsb(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFindSMsb inst) => inst.ResultId;
    public GLSLFindSMsb(int resultType, int resultId, int set, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLFindSMsb(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLFindSMsb(OpData data) => new(data);
}

public struct GLSLFindUMsb : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLFindUMsb()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLFindUMsb(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLFindUMsb(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Value
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLFindUMsb inst) => inst.ResultId;
    public GLSLFindUMsb(int resultType, int resultId, int set, int value)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Value = value;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, Value];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "value":
                    Value = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLFindUMsb(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLFindUMsb(OpData data) => new(data);
}

public struct GLSLInterpolateAtCentroid : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLInterpolateAtCentroid()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLInterpolateAtCentroid(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLInterpolateAtCentroid(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Interpolant
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLInterpolateAtCentroid inst) => inst.ResultId;
    public GLSLInterpolateAtCentroid(int resultType, int resultId, int set, int interpolant)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Interpolant = interpolant;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, Interpolant];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "interpolant":
                    Interpolant = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLInterpolateAtCentroid(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLInterpolateAtCentroid(OpData data) => new(data);
}

public struct GLSLInterpolateAtSample : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLInterpolateAtSample()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLInterpolateAtSample(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLInterpolateAtSample(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Interpolant
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Sample
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLInterpolateAtSample inst) => inst.ResultId;
    public GLSLInterpolateAtSample(int resultType, int resultId, int set, int interpolant, int sample)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Interpolant = interpolant;
        Sample = sample;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, Interpolant, Sample];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "interpolant":
                    Interpolant = o.ToLiteral<int>();
                    break;
                case "sample":
                    Sample = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLInterpolateAtSample(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLInterpolateAtSample(OpData data) => new(data);
}

public struct GLSLInterpolateAtOffset : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLInterpolateAtOffset()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLInterpolateAtOffset(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLInterpolateAtOffset(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Interpolant
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Offset
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLInterpolateAtOffset inst) => inst.ResultId;
    public GLSLInterpolateAtOffset(int resultType, int resultId, int set, int interpolant, int offset)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        Interpolant = interpolant;
        Offset = offset;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, Interpolant, Offset];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "interpolant":
                    Interpolant = o.ToLiteral<int>();
                    break;
                case "offset":
                    Offset = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLInterpolateAtOffset(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLInterpolateAtOffset(OpData data) => new(data);
}

public struct GLSLNMin : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLNMin()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLNMin(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLNMin(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLNMin inst) => inst.ResultId;
    public GLSLNMin(int resultType, int resultId, int set, int x, int y)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLNMin(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLNMin(OpData data) => new(data);
}

public struct GLSLNMax : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLNMax()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLNMax(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLNMax(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Y
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLNMax inst) => inst.ResultId;
    public GLSLNMax(int resultType, int resultId, int set, int x, int y)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        Y = y;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, Y];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "y":
                    Y = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLNMax(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLNMax(OpData data) => new(data);
}

public struct GLSLNClamp : IMemoryInstruction
{
    public OpDataIndex? DataIndex { get; set; }

    public MemoryOwner<int> InstructionMemory
    {
        readonly get
        {
            if (DataIndex is OpDataIndex odi)
                return odi.Data.Memory;
            else
                return field;
        }

        private set
        {
            if (DataIndex is OpDataIndex odi)
            {
                odi.Data.Memory.Dispose();
                odi.Data.Memory = value;
            }
            else
                field = value;
        }
    }

    public GLSLNClamp()
    {
        InstructionMemory = MemoryOwner<int>.Allocate(1);
        InstructionMemory.Span[0] = (int)Op.OpExtInst | (1 << 16);
    }

    public GLSLNClamp(OpDataIndex index)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        DataIndex = index;
        InitializeProperties(index.Data);
    }

    public GLSLNClamp(OpData data)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        InitializeProperties(data);
    }

    public int ResultType
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int ResultId
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int Set
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int X
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MinVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public int MaxVal
    {
        get;
        set
        {
            field = value;
            if (InstructionMemory is not null)
                UpdateInstructionMemory();
        }
    }

    public static implicit operator int (GLSLNClamp inst) => inst.ResultId;
    public GLSLNClamp(int resultType, int resultId, int set, int x, int minVal, int maxVal)
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        ResultType = resultType;
        ResultId = resultId;
        Set = set;
        X = x;
        MinVal = minVal;
        MaxVal = maxVal;
    }

    public void UpdateInstructionMemory()
    {
        InstructionMemory ??= MemoryOwner<int>.Empty;
        Span<int> instruction = [(int)Op.OpExtInst, ResultType, ResultId, Set, X, MinVal, MaxVal];
        instruction[0] |= instruction.Length << 16;
        if (instruction.Length == InstructionMemory.Length)
            instruction.CopyTo(InstructionMemory.Span);
        else
        {
            var tmp = MemoryOwner<int>.Allocate(instruction.Length);
            instruction.CopyTo(tmp.Span);
            InstructionMemory?.Dispose();
            InstructionMemory = tmp;
        }
    }

    private void InitializeProperties(OpData data)
    {
        foreach (var o in data)
        {
            switch (o.Name)
            {
                case "resultType":
                    ResultType = o.ToLiteral<int>();
                    break;
                case "resultId":
                    ResultId = o.ToLiteral<int>();
                    break;
                case "set":
                    Set = o.ToLiteral<int>();
                    break;
                case "x":
                    X = o.ToLiteral<int>();
                    break;
                case "minVal":
                    MinVal = o.ToLiteral<int>();
                    break;
                case "maxVal":
                    MaxVal = o.ToLiteral<int>();
                    break;
            }
        }
    }

    public static implicit operator GLSLNClamp(OpDataIndex odi) => new(odi);
    public static implicit operator GLSLNClamp(OpData data) => new(data);
}